# Phase 18.2-02: Projection Output Renderer

**Phase**: 18.2 - Content Mapping Workflow
**Requirement**: REQ-PROJ-03
**Priority**: P0
**Est. Effort**: 1 day
**Depends on**: 18.2-01 (Projection Shader Nodes)

## Goal

Create output rendering system for physical projectors at native resolution.

## Tasks

### 1. Create Output Types (`lib/cinematic/projection/physical/output/types.py`)

```python
from dataclasses import dataclass
from typing import Optional, Tuple, List
from enum import Enum
from pathlib import Path

class OutputFormat(Enum):
    """Output format for projector content."""
    IMAGE_SEQUENCE = "image_sequence"
    VIDEO = "video"
    EXR = "exr"

class ColorSpace(Enum):
    """Output color space."""
    SRGB = "sRGB"
    REC709 = "Rec709"
    REC2020 = "Rec2020"
    ACES = "ACES"

@dataclass
class ProjectionOutputConfig:
    """Configuration for projector output rendering."""
    # Resolution (from projector profile)
    resolution: Tuple[int, int] = (1920, 1080)

    # Frame range
    frame_start: int = 1
    frame_end: int = 250

    # Output format
    format: OutputFormat = OutputFormat.IMAGE_SEQUENCE
    color_space: ColorSpace = ColorSpace.SRGB

    # File settings
    output_path: str = "//projector_output/"
    file_prefix: str = "frame_"

    # Video settings (if format is VIDEO)
    video_codec: str = "H264"
    video_quality: int = 90
    frame_rate: int = 24

    # EXR settings (if format is EXR)
    exr_codec: str = "ZIP"
    exr_depth: int = 16

    # Rendering options
    use_motion_blur: bool = False
    motion_blur_shutter: float = 0.5
    use_transparent_bg: bool = False

@dataclass
class ProjectionOutputResult:
    """Result of projection output rendering."""
    output_files: List[Path]
    total_frames: int
    render_time_seconds: float
    output_size_bytes: int
```

### 2. Create Output Renderer (`lib/cinematic/projection/physical/output/renderer.py`)

```python
import bpy
from datetime import datetime
from pathlib import Path
from typing import Optional

class ProjectionOutputRenderer:
    """Render content for physical projector display."""

    def __init__(self, projector_profile: ProjectorProfile):
        self.profile = projector_profile
        self.config = ProjectionOutputConfig(
            resolution=projector_profile.native_resolution
        )

    def configure_scene_for_output(
        self,
        scene: bpy.types.Scene,
        config: ProjectionOutputConfig
    ) -> None:
        """
        Configure scene render settings for projector output.

        Sets resolution, frame rate, color space, etc.
        """
        # Set resolution
        scene.render.resolution_x = config.resolution[0]
        scene.render.resolution_y = config.resolution[1]
        scene.render.resolution_percentage = 100

        # Set frame range
        scene.frame_start = config.frame_start
        scene.frame_end = config.frame_end

        # Set frame rate
        scene.render.fps = config.frame_rate

        # Set output path
        scene.render.filepath = config.output_path + config.file_prefix

        # Set format
        if config.format == OutputFormat.IMAGE_SEQUENCE:
            scene.render.image_settings.file_format = 'PNG'
            scene.render.image_settings.color_mode = 'RGBA' if config.use_transparent_bg else 'RGB'
            scene.render.image_settings.color_depth = '16'

        elif config.format == OutputFormat.VIDEO:
            scene.render.image_settings.file_format = 'FFMPEG'
            scene.render.ffmpeg.codec = config.video_codec
            scene.render.ffmpeg.constant_rate_factor = 'HIGH'
            scene.render.ffmpeg.ffmpeg_preset = 'SLOW'

        elif config.format == OutputFormat.EXR:
            scene.render.image_settings.file_format = 'OPEN_EXR'
            scene.render.image_settings.exr_codec = config.exr_codec
            scene.render.image_settings.color_depth = str(config.exr_depth) + '_BIT'

        # Color management
        if config.color_space == ColorSpace.SRGB:
            scene.view_settings.view_transform = 'Standard'
        elif config.color_space == ColorSpace.ACES:
            scene.view_settings.view_transform = 'ACES'

        # Motion blur
        scene.render.use_motion_blur = config.use_motion_blur
        scene.render.motion_blur_shutter = config.motion_blur_shutter

    def render_single_frame(
        self,
        scene: bpy.types.Scene,
        frame: int,
        output_path: Optional[str] = None
    ) -> Path:
        """
        Render single frame from projector perspective.

        Args:
            scene: Blender scene
            frame: Frame number to render
            output_path: Optional override for output path

        Returns:
            Path to rendered file
        """
        scene.frame_set(frame)

        if output_path:
            scene.render.filepath = output_path

        bpy.ops.render.render(write_still=True)

        return Path(bpy.path.abspath(scene.render.filepath))

    def render_animation(
        self,
        scene: bpy.types.Scene,
        config: ProjectionOutputConfig
    ) -> ProjectionOutputResult:
        """
        Render full animation from projector perspective.

        Args:
            scene: Blender scene
            config: Output configuration

        Returns:
            ProjectionOutputResult with render statistics
        """
        # Configure scene
        self.configure_scene_for_output(scene, config)

        # Track timing
        start_time = datetime.now()

        # Render animation
        bpy.ops.render.render(animation=True)

        end_time = datetime.now()
        render_time = (end_time - start_time).total_seconds()

        # Collect output files
        output_dir = Path(bpy.path.abspath(config.output_path))
        output_files = list(output_dir.glob(f"{config.file_prefix}*"))

        # Calculate total size
        total_size = sum(f.stat().st_size for f in output_files if f.is_file())

        return ProjectionOutputResult(
            output_files=output_files,
            total_frames=config.frame_end - config.frame_start + 1,
            render_time_seconds=render_time,
            output_size_bytes=total_size
        )

    def render_calibration_pattern(
        self,
        pattern: CalibrationPattern,
        output_path: str
    ) -> Path:
        """
        Render calibration pattern for physical alignment.

        Creates a test pattern at projector native resolution.
        """
        # Generate pattern image
        if pattern.pattern_type == PatternType.CHECKERBOARD:
            image = generate_checkerboard_pattern(
                pattern.resolution,
                pattern.grid_size
            )
        elif pattern.pattern_type == PatternType.COLOR_BARS:
            image = generate_color_bars_pattern(pattern.resolution)
        elif pattern.pattern_type == PatternType.GRID:
            image = generate_grid_pattern(pattern.resolution)
        else:
            raise ValueError(f"Unknown pattern type: {pattern.pattern_type}")

        # Save to file
        image.filepath_raw = output_path
        image.save()

        return Path(output_path)
```

### 3. Create Multi-Surface Support (`lib/cinematic/projection/physical/output/multi_surface.py`)

```python
from dataclasses import dataclass
from typing import List, Dict
import bpy

@dataclass
class MultiSurfaceOutput:
    """Output configuration for multi-surface projection."""
    surfaces: Dict[str, bpy.types.Object]  # surface_name -> object
    content: Dict[str, str]                # surface_name -> content_path
    output_prefix: str = "surface_"

class MultiSurfaceRenderer:
    """Render for multi-surface projection targets."""

    def __init__(self, renderer: ProjectionOutputRenderer):
        self.renderer = renderer

    def render_multi_surface(
        self,
        config: MultiSurfaceOutput,
        output_dir: str
    ) -> Dict[str, ProjectionOutputResult]:
        """
        Render each surface to separate output files.

        For reading room with multiple cabinets/desks, each surface
        gets its own output or they're combined into one projection.
        """
        results = {}

        for surface_name, surface_obj in config.surfaces.items():
            # Hide other surfaces
            for other_name, other_obj in config.surfaces.items():
                other_obj.hide_render = (other_name != surface_name)

            # Set content for this surface
            content_path = config.content.get(surface_name)
            if content_path:
                # Apply content to surface material
                pass

            # Render
            output_path = f"{output_dir}/{config.output_prefix}{surface_name}_"
            result = self.renderer.render_animation(
                bpy.context.scene,
                self.renderer.config
            )

            results[surface_name] = result

        # Restore visibility
        for obj in config.surfaces.values():
            obj.hide_render = False

        return results

    def render_combined(
        self,
        config: MultiSurfaceOutput,
        output_path: str
    ) -> ProjectionOutputResult:
        """
        Render all surfaces combined into single output.

        All surfaces visible in projector frustum are rendered together.
        """
        # Ensure all surfaces visible
        for obj in config.surfaces.values():
            obj.hide_render = False

        return self.renderer.render_animation(
            bpy.context.scene,
            self.renderer.config
        )
```

### 4. Create Output Package Exports (`lib/cinematic/projection/physical/output/__init__.py`)

```python
"""
Projection output rendering for physical projectors.

Renders content at native projector resolution with proper
color space and format settings.
"""

from .types import (
    OutputFormat,
    ColorSpace,
    ProjectionOutputConfig,
    ProjectionOutputResult,
)

from .renderer import ProjectionOutputRenderer

from .multi_surface import (
    MultiSurfaceOutput,
    MultiSurfaceRenderer,
)

__all__ = [
    # Types
    'OutputFormat',
    'ColorSpace',
    'ProjectionOutputConfig',
    'ProjectionOutputResult',

    # Renderer
    'ProjectionOutputRenderer',

    # Multi-surface
    'MultiSurfaceOutput',
    'MultiSurfaceRenderer',
]
```

## Deliverables

```
lib/cinematic/projection/physical/output/
├── __init__.py
├── types.py               # OutputFormat, ProjectionOutputConfig
├── renderer.py            # ProjectionOutputRenderer
└── multi_surface.py       # Multi-surface rendering
```

## Tests

- `test_output_types.py`: Output configuration tests
- `test_renderer.py`: Renderer configuration tests
- `test_multi_surface.py`: Multi-surface rendering tests

## Acceptance Criteria

- [ ] Scene configures for projector native resolution
- [ ] Image sequence, video, EXR output supported
- [ ] Calibration pattern renders at correct resolution
- [ ] Multi-surface rendering works
- [ ] 15+ unit tests passing
