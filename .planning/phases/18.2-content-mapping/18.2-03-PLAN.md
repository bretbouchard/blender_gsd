# Phase 18.2-03: Content Mapping Integration & Package Exports

**Phase**: 18.2 - Content Mapping Workflow
**Requirement**: REQ-PROJ-03
**Priority**: P0
**Est. Effort**: 1 day
**Depends on**: 18.2-02 (Projection Output Renderer)

## Goal

Integrate shader, proxy geometry, and output systems into unified content mapping workflow. Complete package exports for Phase 18.2.

## Tasks

### 1. Create Content Mapping Workflow (`lib/cinematic/projection/physical/workflow.py`)

```python
from dataclasses import dataclass
from typing import Optional, List, Dict
import bpy
from pathlib import Path

from .projector.profiles import ProjectorProfile
from .calibration import SurfaceCalibration, CalibrationManager
from .shaders import ContentMapper, ProjectionShaderConfig
from .output import ProjectionOutputRenderer, ProjectionOutputConfig

@dataclass
class ContentMappingWorkflow:
    """
    Complete workflow for mapping content to physical projection surface.

    Orchestrates: calibration -> proxy geometry -> shader -> output
    """
    name: str
    projector_profile: ProjectorProfile
    calibration: SurfaceCalibration

    # Blender objects
    projector_camera: Optional[bpy.types.Object] = None
    proxy_geometry: Optional[bpy.types.Object] = None
    content_material: Optional[bpy.types.Material] = None

    # Configuration
    shader_config: Optional[ProjectionShaderConfig] = None
    output_config: Optional[ProjectionOutputConfig] = None

    def setup(self) -> 'ContentMappingWorkflow':
        """Step 1: Setup projector camera from profile."""
        from .projector.calibration import create_projector_camera

        self.projector_camera = create_projector_camera(
            self.projector_profile,
            name=f"{self.name}_Projector"
        )
        return self

    def calibrate(self) -> 'ContentMappingWorkflow':
        """Step 2: Apply calibration to projector camera."""
        from .calibration import align_surface

        result = align_surface(self.calibration, self.projector_profile)
        self.projector_camera.matrix_world = result.transform

        # Store calibration error for validation
        self._calibration_error = result.error

        return self

    def create_proxy(self) -> 'ContentMappingWorkflow':
        """Step 3: Create UV-mapped proxy geometry."""
        from .shaders.proxy_geometry import create_proxy_geometry_for_surface

        self.proxy_geometry = create_proxy_geometry_for_surface(self.calibration)
        self.proxy_geometry.name = f"{self.name}_Proxy"

        return self

    def map_content(self, content_path: str) -> 'ContentMappingWorkflow':
        """Step 4: Map content to surface via projection shader."""
        mapper = ContentMapper(self.projector_profile)

        self.content_material = mapper.map_content_to_surface(
            content_path=content_path,
            surface_object=self.proxy_geometry,
            projector_object=self.projector_camera,
            calibration=self.calibration
        )

        return self

    def configure_output(self, config: ProjectionOutputConfig) -> 'ContentMappingWorkflow':
        """Step 5: Configure output rendering."""
        self.output_config = config
        return self

    def render(self, output_dir: str) -> List[Path]:
        """Step 6: Render final output for projector."""
        if not self.output_config:
            raise ValueError("Output config not set. Call configure_output() first.")

        renderer = ProjectionOutputRenderer(self.output_config)

        # Set scene camera to projector camera
        bpy.context.scene.camera = self.projector_camera

        # Render
        result = renderer.render_animation(bpy.context.scene, self.output_config)

        return result.output_files

    def execute(self, content_path: str, output_dir: str) -> List[Path]:
        """
        Execute complete workflow in one call.

        setup -> calibrate -> create_proxy -> map_content -> render
        """
        return (
            self.setup()
            .calibrate()
            .create_proxy()
            .map_content(content_path)
            .configure_output(ProjectionOutputConfig(
                resolution=self.projector_profile.native_resolution,
                output_path=output_dir
            ))
            .render(output_dir)
        )


# Convenience function for simple use cases
def render_for_projector(
    content_path: str,
    projector_profile_name: str,
    calibration_points: List[tuple],
    output_dir: str = "//projector_output/"
) -> List[Path]:
    """
    Render content for physical projector in one function call.

    Args:
        content_path: Path to content image/video
        projector_profile_name: Name of projector profile (e.g., "epson_home_cinema_2150")
        calibration_points: List of (world_pos, projector_uv) tuples
        output_dir: Output directory for rendered files

    Returns:
        List of output file paths

    Example:
        >>> files = render_for_projector(
        ...     content_path="//content/animation.mp4",
        ...     projector_profile_name="epson_home_cinema_2150",
        ...     calibration_points=[
        ...         ((0, 0, 0), (0, 0)),       # Bottom-left
        ...         ((2, 0, 0), (1, 0)),       # Bottom-right
        ...         ((0, 1.5, 0), (0, 1)),     # Top-left
        ...     ],
        ...     output_dir="//projector_output/"
        ... )
    """
    from .projector.profile_database import load_profile
    from .calibration import CalibrationPoint, CalibrationType

    # Load profile
    profile = load_profile(projector_profile_name)

    # Create calibration
    calibration = SurfaceCalibration(
        name="auto_calibration",
        calibration_type=CalibrationType.THREE_POINT,
        points=[
            CalibrationPoint(
                world_position=wp,
                projector_uv=puv,
                label=f"Point {i+1}"
            )
            for i, (wp, puv) in enumerate(calibration_points)
        ]
    )

    # Create and execute workflow
    workflow = ContentMappingWorkflow(
        name="projection",
        projector_profile=profile,
        calibration=calibration
    )

    return workflow.execute(content_path, output_dir)
```

### 2. Update Physical Package Exports (`lib/cinematic/projection/physical/__init__.py`)

```python
"""
Physical projector mapping system.

Provides complete workflow for mapping content to physical
projection surfaces with real-world calibration.
"""

# Projector profiles (Phase 18.0)
from .projector import (
    ProjectorProfile,
    ProjectorType,
    AspectRatio,
    LensShift,
    KeystoneCorrection,
    load_profile,
    query_profiles_by_throw_ratio,
    query_profiles_by_resolution,
    create_projector_camera,
    configure_render_for_projector,
    throw_ratio_to_focal_length,
)

# Calibration (Phase 18.1)
from .calibration import (
    # Types
    CalibrationPoint,
    CalibrationType,
    SurfaceCalibration,
    CalibrationPattern,
    PatternType,
    AlignmentResult,

    # Alignment
    compute_alignment_transform,
    align_surface,
    four_point_dlt_alignment,

    # Patterns
    generate_checkerboard_pattern,
    generate_color_bars_pattern,
    generate_grid_pattern,

    # Keystone
    compute_keystone_correction,
    apply_keystone_to_camera,

    # Manager
    CalibrationManager,
)

# Shaders (Phase 18.2)
from .shaders import (
    # Types
    ProjectionMode,
    ProjectionShaderConfig,
    ProjectionShaderResult,

    # Shader creation
    create_projector_material,
    ensure_projector_projection_group,

    # Proxy geometry
    create_proxy_geometry_for_surface,
    ProxyGeometryConfig,

    # Content mapping
    ContentMapper,
)

# Output (Phase 18.2)
from .output import (
    # Types
    OutputFormat,
    ColorSpace,
    ProjectionOutputConfig,
    ProjectionOutputResult,

    # Renderer
    ProjectionOutputRenderer,

    # Multi-surface
    MultiSurfaceOutput,
    MultiSurfaceRenderer,
)

# Workflow
from .workflow import (
    ContentMappingWorkflow,
    render_for_projector,
)

# Stage pipeline (Phase 18.0)
from .stages import (
    StageContext,
    StageState,
    stage_normalize,
    stage_primary,
)

__all__ = [
    # Projector profiles
    'ProjectorProfile',
    'ProjectorType',
    'AspectRatio',
    'LensShift',
    'KeystoneCorrection',
    'load_profile',
    'query_profiles_by_throw_ratio',
    'query_profiles_by_resolution',
    'create_projector_camera',
    'configure_render_for_projector',
    'throw_ratio_to_focal_length',

    # Calibration
    'CalibrationPoint',
    'CalibrationType',
    'SurfaceCalibration',
    'CalibrationPattern',
    'PatternType',
    'AlignmentResult',
    'compute_alignment_transform',
    'align_surface',
    'four_point_dlt_alignment',
    'generate_checkerboard_pattern',
    'generate_color_bars_pattern',
    'generate_grid_pattern',
    'compute_keystone_correction',
    'apply_keystone_to_camera',
    'CalibrationManager',

    # Shaders
    'ProjectionMode',
    'ProjectionShaderConfig',
    'ProjectionShaderResult',
    'create_projector_material',
    'ensure_projector_projection_group',
    'create_proxy_geometry_for_surface',
    'ProxyGeometryConfig',
    'ContentMapper',

    # Output
    'OutputFormat',
    'ColorSpace',
    'ProjectionOutputConfig',
    'ProjectionOutputResult',
    'ProjectionOutputRenderer',
    'MultiSurfaceOutput',
    'MultiSurfaceRenderer',

    # Workflow
    'ContentMappingWorkflow',
    'render_for_projector',

    # Stages
    'StageContext',
    'StageState',
    'stage_normalize',
    'stage_primary',
]
```

### 3. Create Integration Tests (`tests/integration/test_projection_mapping.py`)

```python
"""Integration tests for physical projector mapping workflow."""

import pytest
import bpy
from pathlib import Path

from lib.cinematic.projection.physical import (
    ProjectorProfile,
    CalibrationPoint,
    CalibrationType,
    SurfaceCalibration,
    ContentMappingWorkflow,
    render_for_projector,
)


class TestProjectionMappingWorkflow:
    """Test complete projection mapping workflow."""

    def test_simple_workflow(self, tmp_path):
        """Test basic setup -> calibrate -> render workflow."""
        # Create test calibration points (1m x 1m surface)
        calibration_points = [
            ((0, 0, 0), (0, 0)),       # Bottom-left
            ((1, 0, 0), (1, 0)),       # Bottom-right
            ((0, 1, 0), (0, 1)),       # Top-left
        ]

        # Execute workflow
        output_files = render_for_projector(
            content_path="//tests/fixtures/test_pattern.png",
            projector_profile_name="epson_home_cinema_2150",
            calibration_points=calibration_points,
            output_dir=str(tmp_path) + "/"
        )

        # Verify output
        assert len(output_files) > 0
        assert all(f.exists() for f in output_files)

    def test_workflow_with_calibration_manager(self):
        """Test using CalibrationManager for workflow."""
        from lib.cinematic.projection.physical import (
            load_profile,
            CalibrationManager,
        )

        profile = load_profile("epson_home_cinema_2150")
        manager = CalibrationManager(profile)

        # Create calibration
        calibration = manager.create_calibration(
            name="test_calibration",
            calibration_type=CalibrationType.THREE_POINT,
            points=[
                CalibrationPoint((0, 0, 0), (0, 0), "Bottom-left"),
                CalibrationPoint((1, 0, 0), (1, 0), "Bottom-right"),
                CalibrationPoint((0, 1, 0), (0, 1), "Top-left"),
            ]
        )

        # Validate
        is_valid, errors = manager.validate_calibration(calibration)
        assert is_valid
        assert len(errors) == 0

    def test_four_point_dlt_workflow(self, tmp_path):
        """Test 4-point DLT calibration workflow."""
        calibration_points = [
            ((0, 0, 0), (0, 0)),
            ((1, 0, 0), (1, 0)),
            ((0, 1, 0), (0, 1)),
            ((1, 1, 0), (1, 1)),  # 4th point for DLT
        ]

        output_files = render_for_projector(
            content_path="//tests/fixtures/test_pattern.png",
            projector_profile_name="benq_tk700sti",
            calibration_points=calibration_points,
            output_dir=str(tmp_path) + "/"
        )

        assert len(output_files) > 0
```

## Deliverables

```
lib/cinematic/projection/physical/
├── workflow.py            # ContentMappingWorkflow, render_for_projector
└── __init__.py            # Complete package exports (60+ exports)

tests/integration/
└── test_projection_mapping.py  # Integration tests
```

## Tests

- `test_workflow.py`: Workflow execution tests
- Integration tests for complete pipeline

## Acceptance Criteria

- [ ] ContentMappingWorkflow orchestrates all steps
- [ ] render_for_projector() convenience function works
- [ ] Package exports 60+ functions/classes
- [ ] Integration tests pass
- [ ] Phase 18.2 complete with 60+ tests total
