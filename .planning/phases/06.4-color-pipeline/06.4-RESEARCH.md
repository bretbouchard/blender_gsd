# Phase 6.4: Color Pipeline - Research

**Researched:** 2026-02-18
**Domain:** Blender OpenColorIO, LUT Management, Color Management
**Confidence:** MEDIUM (Official docs verified, some compositor details inferred)

## Summary

This phase implements a color pipeline system for cinematic rendering in Blender. The research covers Blender's OpenColorIO-based color management system, LUT file handling (.cube format), compositor-based color grading, and auto-exposure via scene luminance sampling.

Blender's color management is accessed through `scene.view_settings` with view transforms (AgX recommended per requirements), exposure/gamma controls, and look presets. LUTs must be applied via compositor nodes (ColorBalance, CurveRGB) since Blender lacks a direct LUT node. The system follows the established dataclass pattern and YAML preset loading from existing modules.

**Primary recommendation:** Use Blender's built-in OpenColorIO system for view transforms, apply technical LUTs via compositor ColorBalance nodes early in pipeline (stage 8), creative LUTs late (stage 9). Store LUT files in `assets/luts/` with 65-cube precision for technical, 33-cube for film looks.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library/Component | Version | Purpose | Why Standard |
|-------------------|---------|---------|--------------|
| OpenColorIO | Built-in (Blender 4.x+) | Color management framework | Industry standard, Blender native |
| .cube format | 1.0 | LUT file format | Universal compatibility, OCIO native |
| AgX View Transform | Blender 4.x+ | High dynamic range viewing | Recommended in REQ-CINE-LUT |
| CompositorNodeColorBalance | Blender API | LUT-style color grading | Built-in, supports lift/gamma/gain |

### Supporting
| Component | Purpose | When to Use |
|-----------|---------|-------------|
| CompositorNodeExposure | Exposure adjustment | Auto-exposure offset application |
| CompositorNodeGamma | Gamma correction | Perceptual brightness tuning |
| CompositorNodeCurveRGB | Custom tone mapping | Film response curves |
| CompositorNodeMixRGB | LUT intensity blending | Mix original with graded |

### LUT Precision Requirements (per REQ-CINE-LUT)
| Type | Precision | Use Case |
|------|-----------|----------|
| Technical LUTs | 65^3 | Color space transforms (Rec.709 to sRGB, Linear to sRGB, ACEScg to Rec.709, Linear to Log) |
| Film LUTs | 33^3 | Creative looks (Kodak 2383, Fuji 3510, Cineon) |

### View Transform Presets (per REQ-CINE-LUT)
- srgb_standard
- agx_default
- agx_product
- agx_dramatic
- acescg
- filmic

**Installation:**
LUT files are stored in project directory, no pip install required.

## Architecture Patterns

### Recommended Project Structure
```
configs/
├── cinematic/
│   └── color/
│       ├── view_transforms.yaml    # View transform presets
│       ├── technical_luts.yaml     # Technical LUT definitions
│       └── film_luts.yaml          # Film look LUT definitions

assets/
└── luts/
    ├── technical/                   # 65^3 precision LUTs
    │   ├── rec709_to_srgb.cube
    │   ├── linear_to_srgb.cube
    │   ├── acescg_to_rec709.cube
    │   └── linear_to_log.cube
    └── film/                        # 33^3 precision LUTs
        ├── kodak_2383.cube
        ├── fuji_3510.cube
        └── cineon.cube

lib/
└── cinematic/
    ├── color.py                     # Color management module
    ├── luts.py                      # LUT loading and application
    └── exposure.py                  # Auto-exposure system
```

### Pattern 1: Color Management via View Settings
**What:** Control Blender's color management through scene.view_settings
**When to use:** Setting view transform, exposure, gamma, look
**Example:**
```python
# Source: Blender docs - https://docs.blender.org/api/current/bpy.types.Scene.html
import bpy

scene = bpy.context.scene

# Set view transform
scene.view_settings.view_transform = 'AgX'  # Options: Standard, AgX, Filmic, Filmic Log, False Color, Raw

# Set exposure and gamma
scene.view_settings.exposure = 0.0  # -inf to +inf, default 0
scene.view_settings.gamma = 1.0     # 0 to 5, default 1

# Set look preset
scene.view_settings.look = 'AgX - Medium High Contrast'  # Various film looks available

# Display device
scene.display_settings.display_device = 'sRGB'  # sRGB, Display P3, Rec.2020, etc.
```

### Pattern 2: Compositor LUT Application
**What:** Apply LUTs via compositor nodes since Blender lacks direct LUT node
**When to use:** Technical LUTs (stage 8), Creative LUTs (stage 9)
**Example:**
```python
# Source: Blender API + existing lenses.py pattern
def apply_lut_via_compositor(lut_path: str, intensity: float = 0.8) -> bool:
    """Apply LUT using ColorBalance node with intensity blend."""
    scene = bpy.context.scene
    scene.use_nodes = True
    tree = scene.node_tree

    # Get existing nodes
    render_layers = tree.nodes.get('Render Layers')
    composite = tree.nodes.get('Composite')

    # Create ColorBalance for LUT-style grading
    color_balance = tree.nodes.new('CompositorNodeColorBalance')
    color_balance.name = 'LUT_Application'
    color_balance.correction_method = 'LIFT_GAMMA_GAIN'

    # Apply LUT-like transformation (lift, gamma, gain)
    # Note: For actual .cube LUT loading, need custom implementation
    color_balance.lift = (0.0, 0.0, 0.0)
    color_balance.gamma = (1.0, 1.0, 1.0)
    color_balance.gain = (1.0, 1.0, 1.0)

    # Mix node for intensity blending
    mix = tree.nodes.new('CompositorNodeMixRGB')
    mix.name = 'LUT_Mix'
    mix.blend_type = 'MIX'
    mix.inputs['Fac'].default_value = intensity  # LUT intensity (0.8 default per requirements)

    # Connect: Render -> ColorBalance -> Mix[1], Render -> Mix[2]
    tree.links.new(render_layers.outputs['Image'], color_balance.inputs['Image'])
    tree.links.new(render_layers.outputs['Image'], mix.inputs[2])  # Original
    tree.links.new(color_balance.outputs['Image'], mix.inputs[1])   # Graded
    tree.links.new(mix.outputs['Image'], composite.inputs['Image'])

    return True
```

### Pattern 3: Dataclass Configuration
**What:** Use dataclass pattern with to_dict/from_dict (follow types.py)
**When to use:** ColorConfig, LUTConfig, ExposureConfig classes
**Example:**
```python
# Source: lib/cinematic/types.py pattern
from dataclasses import dataclass
from typing import Dict, Any, Optional, Tuple

@dataclass
class ColorConfig:
    """Color management configuration."""
    view_transform: str = "AgX"
    exposure: float = 0.0
    gamma: float = 1.0
    look: str = "None"

    def to_dict(self) -> Dict[str, Any]:
        return {
            "view_transform": self.view_transform,
            "exposure": self.exposure,
            "gamma": self.gamma,
            "look": self.look,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ColorConfig":
        return cls(
            view_transform=data.get("view_transform", "AgX"),
            exposure=data.get("exposure", 0.0),
            gamma=data.get("gamma", 1.0),
            look=data.get("look", "None"),
        )


@dataclass
class LUTConfig:
    """LUT configuration with intensity blending."""
    name: str
    lut_path: str
    intensity: float = 0.8  # Default per REQ-CINE-LUT
    enabled: bool = True

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "lut_path": self.lut_path,
            "intensity": self.intensity,
            "enabled": self.enabled,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "LUTConfig":
        return cls(
            name=data.get("name", ""),
            lut_path=data.get("lut_path", ""),
            intensity=data.get("intensity", 0.8),
            enabled=data.get("enabled", True),
        )


@dataclass
class ExposureLockConfig:
    """Auto-exposure lock configuration per REQ-CINE-LUT."""
    enabled: bool = False
    target_gray: float = 0.18  # 18% gray
    highlight_protection: float = 0.95
    shadow_protection: float = 0.02

    def to_dict(self) -> Dict[str, Any]:
        return {
            "enabled": self.enabled,
            "target_gray": self.target_gray,
            "highlight_protection": self.highlight_protection,
            "shadow_protection": self.shadow_protection,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExposureLockConfig":
        return cls(
            enabled=data.get("enabled", False),
            target_gray=data.get("target_gray", 0.18),
            highlight_protection=data.get("highlight_protection", 0.95),
            shadow_protection=data.get("shadow_protection", 0.02),
        )
```

### Pattern 4: YAML Preset Loading
**What:** Follow preset_loader.py pattern for color presets
**When to use:** View transform presets, LUT presets
**Example:**
```python
# Source: lib/cinematic/preset_loader.py pattern
from pathlib import Path
from typing import Dict, Any, List

COLOR_CONFIG_ROOT = Path("configs/cinematic/color")

def get_view_transform_preset(name: str) -> Dict[str, Any]:
    """Load view transform preset by name."""
    path = COLOR_CONFIG_ROOT / "view_transforms.yaml"
    data = load_preset(path)

    presets = data.get("view_transforms", {})
    if name not in presets:
        available = list(presets.keys())
        raise ValueError(f"View transform '{name}' not found. Available: {available}")

    return presets[name]

def get_technical_lut_preset(name: str) -> Dict[str, Any]:
    """Load technical LUT preset by name."""
    path = COLOR_CONFIG_ROOT / "technical_luts.yaml"
    data = load_preset(path)

    luts = data.get("technical_luts", {})
    if name not in luts:
        raise ValueError(f"Technical LUT '{name}' not found. Available: {list(luts.keys())}")

    return luts[name]

def get_film_lut_preset(name: str) -> Dict[str, Any]:
    """Load film LUT preset by name."""
    path = COLOR_CONFIG_ROOT / "film_luts.yaml"
    data = load_preset(path)

    luts = data.get("film_luts", {})
    if name not in luts:
        raise ValueError(f"Film LUT '{name}' not found. Available: {list(luts.keys())}")

    return luts[name]
```

### Anti-Patterns to Avoid
- **Manual color space math:** Don't implement custom color space transforms - use Blender's OCIO
- **Ignoring view_transform order:** Apply technical LUTs BEFORE creative - wrong order breaks pipeline
- **Hardcoding LUT paths:** Always use configurable paths with fallbacks (like hdri.py multi-path pattern)
- **Skipping intensity blend:** Always blend LUT with original (default 0.8 per requirements)

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Color space conversion | Custom matrix math | scene.view_settings.view_transform | OCIO handles edge cases, proper gamma |
| Exposure adjustment | Brightness multiply | scene.view_settings.exposure | HDR-aware, preserves highlights |
| Display calibration | Custom gamma curves | scene.display_settings.display_device | System-aware, color-managed |
| LUT file parsing | Custom .cube reader | OpenColorIO (if available) or validated library | Cube format has edge cases |

**Key insight:** Blender's OpenColorIO integration handles most color management. Custom implementations introduce color shifts and gamut clipping.

## Common Pitfalls

### Pitfall 1: Wrong Pipeline Order
**What goes wrong:** Applying creative LUTs before technical LUTs breaks color consistency
**Why it happens:** Not following REQ-CINE-LUT stage order (technical=8, creative=9)
**How to avoid:** Implement pipeline stages explicitly, apply LUTs in order
**Warning signs:** Colors look washed out or oversaturated unexpectedly

### Pitfall 2: LUT Precision Mismatch
**What goes wrong:** Using 33^3 LUT for color space transform causes banding
**Why it happens:** Technical transforms need 65^3 precision per requirements
**How to avoid:** Validate LUT precision at load time, reject wrong precision
**Warning signs:** Gradient banding, posterization in smooth areas

### Pitfall 3: Missing LUT Files
**What goes wrong:** Hardcoded paths fail when project moved
**Why it happens:** Not using multi-path search like hdri.py pattern
**How to avoid:** Search multiple paths: `assets/luts/`, `~/lut_library/`, config paths
**Warning signs:** FileNotFoundError at render time

### Pitfall 4: Intensity Not Applied
**What goes wrong:** Full-strength LUT looks too aggressive
**Why it happens:** Forgetting to blend with original using Mix node
**How to avoid:** Always create Mix node with intensity factor (default 0.8)
**Warning signs:** Crushed shadows, blown highlights, unnatural saturation

### Pitfall 5: Scene Luminance Access
**What goes wrong:** Can't read scene luminance for auto-exposure
**Why it happens:** Blender doesn't expose direct luminance query in Python
**How to avoid:** Use render pass or compositor to calculate luminance
**Warning signs:** Auto-exposure not adjusting to scene changes

## Code Examples

Verified patterns from official sources:

### Setting View Transform
```python
# Source: https://docs.blender.org/api/current/bpy.types.Scene.html
import bpy

def set_view_transform(preset_name: str) -> bool:
    """Set view transform from preset."""
    scene = bpy.context.scene

    preset_map = {
        "srgb_standard": "Standard",
        "agx_default": "AgX",
        "agx_product": "AgX",
        "agx_dramatic": "AgX",
        "acescg": "ACEScg",
        "filmic": "Filmic",
    }

    if preset_name not in preset_map:
        return False

    scene.view_settings.view_transform = preset_map[preset_name]

    # Apply look for dramatic variants
    if preset_name == "agx_dramatic":
        scene.view_settings.look = "AgX - Very High Contrast"
    elif preset_name == "agx_product":
        scene.view_settings.look = "AgX - Punchy"

    return True
```

### Exposure Lock System
```python
# Source: Blender compositor pattern + REQ-CINE-LUT spec
def calculate_auto_exposure(
    target_gray: float = 0.18,
    highlight_protection: float = 0.95,
    shadow_protection: float = 0.02
) -> float:
    """
    Calculate exposure adjustment for 18% gray targeting.

    Note: Direct luminance sampling requires render or compositor pass.
    This is a placeholder for the implementation approach.
    """
    # Implementation requires:
    # 1. Render luminance pass or sample from compositor
    # 2. Calculate average scene luminance
    # 3. Compute exposure offset to hit target_gray
    # 4. Clamp to protect highlights/shadows

    # Placeholder - actual implementation needs luminance data
    return 0.0


def apply_exposure_lock(config: ExposureLockConfig) -> bool:
    """Apply auto-exposure based on scene luminance."""
    if not config.enabled:
        return True

    # Calculate required exposure
    exposure = calculate_auto_exposure(
        target_gray=config.target_gray,
        highlight_protection=config.highlight_protection,
        shadow_protection=config.shadow_protection
    )

    # Apply to scene
    bpy.context.scene.view_settings.exposure = exposure
    return True
```

### Compositor Node Setup (Following lenses.py Pattern)
```python
# Source: lib/cinematic/lenses.py pattern + Blender API
def setup_compositor_for_color() -> bool:
    """Enable compositor and ensure basic nodes exist."""
    try:
        scene = bpy.context.scene
        scene.use_nodes = True

        tree = scene.node_tree
        if tree is None:
            return False

        # Check for Render Layers node
        render_layers = tree.nodes.get('Render Layers')
        if not render_layers:
            render_layers = tree.nodes.new('CompositorNodeRLayers')
            render_layers.name = 'Render Layers'

        # Check for Composite node
        composite = tree.nodes.get('Composite')
        if not composite:
            composite = tree.nodes.new('CompositorNodeComposite')
            composite.name = 'Composite'

        return True

    except Exception:
        return False
```

### LUT File Validation
```python
# Source: .cube format specification + requirements
from pathlib import Path

def validate_lut_file(path: Path, expected_precision: int) -> tuple[bool, str]:
    """
    Validate LUT file format and precision.

    Args:
        path: Path to .cube file
        expected_precision: Expected cube size (33 or 65)

    Returns:
        (valid, error_message)
    """
    if not path.exists():
        return False, f"LUT file not found: {path}"

    if path.suffix.lower() != '.cube':
        return False, f"Invalid format: expected .cube, got {path.suffix}"

    try:
        with open(path, 'r') as f:
            lines = f.readlines()

        # Find LUT_3D_SIZE
        for line in lines:
            if line.startswith('LUT_3D_SIZE'):
                size = int(line.split()[1])
                if size != expected_precision:
                    return False, f"Wrong precision: expected {expected_precision}^3, got {size}^3"
                break
        else:
            return False, "Missing LUT_3D_SIZE in .cube file"

        return True, ""

    except Exception as e:
        return False, f"Error reading LUT: {e}"
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| sRGB View Transform | AgX (HDR-aware) | Blender 4.0 | Better highlight handling, no clipping |
| Filmic Blender | Built-in AgX | Blender 4.0 | Simpler, official support |
| LUT via Color Management | Compositor nodes | Blender 2.8+ | More control, non-destructive |
| Fixed exposure | Scene-referred exposure | Blender 2.79+ | HDR workflow support |

**Deprecated/outdated:**
- Filmic Blender addon: Replaced by built-in AgX in Blender 4.0+
- sRGB view transform: Only for SDR delivery, not HDR work

## Open Questions

Things that couldn't be fully resolved:

1. **Direct LUT Loading in Compositor**
   - What we know: Blender lacks a native LUT loading compositor node
   - What's unclear: Best approach for .cube file parsing - custom implementation vs OCIO integration
   - Recommendation: Implement custom .cube reader with validation, apply via ColorBalance curves

2. **Scene Luminance Sampling**
   - What we know: Need luminance data for auto-exposure
   - What's unclear: Whether to use render passes, compositor sampling, or approximate from scene data
   - Recommendation: Use compositor with separate luminance calculation pass

3. **Per-Shot Color Overrides**
   - What we know: Requirements mention per-shot override capability
   - What's unclear: How to structure override hierarchy (shot > scene > project)
   - Recommendation: Follow state_manager.py pattern with YAML override files per shot

## Sources

### Primary (HIGH confidence)
- Blender API Documentation - https://docs.blender.org/api/current/bpy.types.Scene.html (view_settings, display_settings)
- Blender API Documentation - https://docs.blender.org/api/current/bpy.types.CompositorNodeTree.html (compositor nodes)
- Existing codebase patterns: lib/cinematic/types.py, lib/cinematic/preset_loader.py, lib/cinematic/lenses.py

### Secondary (MEDIUM confidence)
- Blender Color Management docs - https://docs.blender.org/manual/en/latest/render/color_management.html
- OpenColorIO .cube specification - Industry standard format

### Tertiary (LOW confidence)
- WebSearch returned empty results - marked for validation during implementation

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Blender API docs verified, existing codebase patterns
- Architecture: HIGH - Following established module patterns
- LUT loading: MEDIUM - No native node, implementation approach inferred
- Auto-exposure: MEDIUM - Luminance sampling approach needs validation
- Pitfalls: HIGH - Based on requirements and Blender limitations

**Research date:** 2026-02-18
**Valid until:** 30 days - Blender API stable for 4.x/5.x
