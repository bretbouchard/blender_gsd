---
phase: 06.4-color-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["06.4-01"]
files_modified:
  - lib/cinematic/color.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can set view transform via set_view_transform()"
    - "User can apply color management presets via apply_color_preset()"
    - "User can validate LUT files for correct precision via validate_lut_file()"
    - "User can apply LUTs to compositor via apply_lut()"
    - "LUT intensity blend is controlled via MixRGB node at config.intensity ratio"
    - "Exposure lock can calculate auto-exposure via calculate_auto_exposure()"
  artifacts:
    - path: "lib/cinematic/color.py"
      provides: "Color management and LUT functions"
      min_lines: 350
      exports: ["set_view_transform", "apply_color_preset", "validate_lut_file", "calculate_auto_exposure", "apply_exposure_lock", "apply_lut"]
  key_links:
    - from: "lib/cinematic/color.py"
      to: "bpy.context.scene.view_settings"
      via: "Blender API"
      pattern: "view_settings\\.view_transform"
    - from: "lib/cinematic/color.py"
      to: "bpy.context.scene.node_tree"
      via: "Blender Compositor API"
      pattern: "scene\\.node_tree|tree\\.nodes\\.new"
    - from: "lib/cinematic/color.py"
      to: "lib/cinematic/preset_loader.py"
      via: "import"
      pattern: "from .preset_loader import"
---

<objective>
Create the color.py module with color management, LUT validation, LUT application via compositor, and exposure lock functionality.

Purpose: Implement the core color pipeline module that interfaces with Blender's OpenColorIO system and compositor for LUT management. This is the main implementation module for REQ-CINE-LUT.

Output: lib/cinematic/color.py with color management functions, LUT validation, compositor-based LUT application with intensity blending, and exposure lock system.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research and existing patterns
@.planning/phases/06.4-color-pipeline/06.4-RESEARCH.md
@lib/cinematic/types.py
@lib/cinematic/enums.py
@lib/cinematic/preset_loader.py
@lib/cinematic/lenses.py
@configs/cinematic/color/color_management_presets.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create color.py with core color management functions</name>
  <files>lib/cinematic/color.py</files>
  <action>
Create lib/cinematic/color.py module implementing color management functions following the pattern from lenses.py.

**Module structure:**
```python
"""
Color Pipeline Module

Provides color management, LUT validation, compositor LUT application, and exposure lock functionality.

Usage:
    from lib.cinematic.color import (
        set_view_transform, apply_color_preset,
        validate_lut_file, apply_lut, calculate_auto_exposure
    )

    # Set view transform
    set_view_transform("AgX", look="AgX Default Medium High Contrast")

    # Apply color preset
    apply_color_preset("agx_default")

    # Validate and apply LUT
    valid, error = validate_lut_file(Path("luts/kodak_2383.cube"), 33)
    if valid:
        apply_lut(lut_config)
"""

from __future__ import annotations
from typing import Optional, Tuple, Dict, Any
from pathlib import Path

from .types import ColorConfig, LUTConfig, ExposureLockConfig
from .preset_loader import get_color_preset, COLOR_CONFIG_ROOT

try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False
```

**Implement these functions:**

1. **set_view_transform(view_transform: str, look: str = "None", exposure: float = 0.0, gamma: float = 1.0, display_device: str = "sRGB") -> bool**
   - Set scene.view_settings.view_transform
   - Set scene.view_settings.look
   - Set scene.view_settings.exposure
   - Set scene.view_settings.gamma
   - Set scene.display_settings.display_device
   - Return True on success, False if Blender not available or error

2. **apply_color_preset(preset_name: str) -> bool**
   - Load preset using get_color_preset()
   - Extract view_transform, look, exposure, gamma, display_device
   - Call set_view_transform() with extracted values
   - Return True on success, False on failure

3. **get_current_color_settings() -> Optional[ColorConfig]**
   - Get current view_transform, look, exposure, gamma from scene
   - Return ColorConfig with current settings
   - Return None if Blender not available

4. **reset_color_settings() -> bool**
   - Reset to Blender defaults: view_transform="AgX", look="None", exposure=0.0, gamma=1.0
   - Return True on success

5. **get_available_looks() -> list[str]**
   - Return list of available look presets from scene.view_settings
   - Access via bpy.types.Scene.bl_rna.properties['view_settings'].enum_items_static if available
   - Return empty list if not available

6. **set_working_color_space(working_space: str) -> bool**
   - Set the scene's working color space via scene.sequencer_colorspace_settings.name
   - Note: Blender 4.x primarily uses view_transform for color management
   - Return True on success, False if Blender not available
  </action>
  <verify>
grep -c "def set_view_transform" lib/cinematic/color.py && \
grep -c "def apply_color_preset" lib/cinematic/color.py && \
grep -c "def get_current_color_settings" lib/cinematic/color.py && \
grep -c "def set_working_color_space" lib/cinematic/color.py && \
grep -c "BLENDER_AVAILABLE" lib/cinematic/color.py
  </verify>
  <done>
color.py exists with set_view_transform, apply_color_preset, get_current_color_settings, reset_color_settings, get_available_looks, set_working_color_space functions.
</done>
</task>

<task type="auto">
  <name>Task 2: Add LUT validation functions to color.py</name>
  <files>lib/cinematic/color.py</files>
  <action>
Add LUT validation and loading functions to lib/cinematic/color.py.

**Implement these functions:**

1. **validate_lut_file(path: Path, expected_precision: int) -> Tuple[bool, str]**
   - Validate that LUT file exists and has correct precision
   - Open .cube file and find LUT_3D_SIZE line
   - Parse size value and compare to expected_precision
   - Return (True, "") if valid, (False, "error message") if invalid
   - Example implementation from research:
     ```python
     def validate_lut_file(path: Path, expected_precision: int) -> Tuple[bool, str]:
         if not path.exists():
             return False, f"LUT file not found: {path}"
         if path.suffix.lower() != '.cube':
             return False, f"Invalid format: expected .cube, got {path.suffix}"
         try:
             with open(path, 'r') as f:
                 lines = f.readlines()
             for line in lines:
                 if line.startswith('LUT_3D_SIZE'):
                     size = int(line.split()[1])
                     if size != expected_precision:
                         return False, f"Wrong precision: expected {expected_precision}^3, got {size}^3"
                     return True, ""
             return False, "Missing LUT_3D_SIZE in .cube file"
         except Exception as e:
             return False, f"Error reading LUT: {e}"
     ```

2. **find_lut_path(lut_filename: str, search_paths: Optional[list[Path]] = None) -> Optional[Path]**
   - Multi-path LUT search following hdri.py find_hdri_path pattern
   - Default search paths:
     - assets/luts/
     - ~/.lut_library/ (home directory)
     - COLOR_CONFIG_ROOT / "luts/"
   - Return first found Path or None

3. **load_lut_config(preset_name: str, lut_type: str = "film") -> Optional[LUTConfig]**
   - Load LUT preset using get_film_lut_preset() or get_technical_lut_preset()
   - Resolve lut_path using find_lut_path()
   - Validate precision matches expected (33 for film, 65 for technical)
   - Return LUTConfig or None if validation fails

4. **list_available_luts(lut_type: str = "film") -> list[str]**
   - Return list of available LUT preset names
   - Use list_film_lut_presets() or list_technical_lut_presets() based on type
  </action>
  <verify>
grep -c "def validate_lut_file" lib/cinematic/color.py && \
grep -c "def find_lut_path" lib/cinematic/color.py && \
grep -c "def load_lut_config" lib/cinematic/color.py && \
grep -c "LUT_3D_SIZE" lib/cinematic/color.py
  </verify>
  <done>
LUT validation functions exist: validate_lut_file, find_lut_path, load_lut_config, list_available_luts.
</done>
</task>

<task type="auto">
  <name>Task 3: Add compositor-based LUT application to color.py</name>
  <files>lib/cinematic/color.py</files>
  <action>
Add compositor-based LUT application function to lib/cinematic/color.py per REQ-CINE-LUT. This addresses the requirement for LUTs to be applied at stages 8 (technical) and 9 (creative).

**Implement these functions:**

1. **apply_lut(config: LUTConfig) -> bool**
   - Apply LUT using compositor nodes with intensity blending
   - Takes LUTConfig as parameter (which includes intensity field)
   - Creates compositor node setup to approximate LUT effect
   - Uses MixRGB node to blend LUT output with original at config.intensity ratio (default 0.8)
   - Returns True on success, False on failure

   **Implementation details:**
   ```python
   def apply_lut(config: LUTConfig) -> bool:
       """
       Apply LUT using compositor nodes with intensity blending.

       Creates a node chain:
       1. Render Layers -> ColorBalance (LUT-style grading) -> MixRGB[1]
       2. Render Layers -> MixRGB[2] (original)
       3. MixRGB blends at config.intensity ratio (default 0.8)
       4. Output -> Composite

       Note: Blender lacks a native LUT loading node. This implementation
       uses ColorBalance or CurveRGB nodes to approximate LUT effects.
       For actual .cube LUT loading, consider using OCIO or custom parsing.

       Args:
           config: LUTConfig with name, lut_path, intensity, enabled, lut_type, precision

       Returns:
           True on success, False on failure
       """
       if not BLENDER_AVAILABLE or not config.enabled:
           return False

       try:
           scene = bpy.context.scene
           scene.use_nodes = True
           tree = scene.node_tree

           if tree is None:
               return False

           # Get or create Render Layers node
           render_layers = tree.nodes.get('Render Layers')
           if not render_layers:
               render_layers = tree.nodes.new('CompositorNodeRLayers')
               render_layers.name = 'Render Layers'

           # Get or create Composite node
           composite = tree.nodes.get('Composite')
           if not composite:
               composite = tree.nodes.new('CompositorNodeComposite')
               composite.name = 'Composite'

           # Create ColorBalance node for LUT-style grading
           color_balance = tree.nodes.new('CompositorNodeColorBalance')
           color_balance.name = f'LUT_{config.name}'
           color_balance.correction_method = 'LIFT_GAMMA_GAIN'

           # Set position for clean layout
           color_balance.location = (300, 0)

           # Create MixRGB node for intensity blending
           mix = tree.nodes.new('CompositorNodeMixRGB')
           mix.name = f'LUT_Mix_{config.name}'
           mix.blend_type = 'MIX'
           mix.inputs['Fac'].default_value = config.intensity  # Use intensity from config
           mix.location = (500, 0)

           # Connect: Render -> ColorBalance -> Mix[1], Render -> Mix[2]
           # Mix[1] = graded (ColorBalance output), Mix[2] = original
           tree.links.new(render_layers.outputs['Image'], color_balance.inputs['Image'])
           tree.links.new(render_layers.outputs['Image'], mix.inputs[2])  # Original to socket 2
           tree.links.new(color_balance.outputs['Image'], mix.inputs[1])   # Graded to socket 1
           tree.links.new(mix.outputs['Image'], composite.inputs['Image'])

           return True

       except Exception as e:
           print(f"Error applying LUT: {e}")
           return False
   ```

2. **remove_lut_nodes(lut_name: Optional[str] = None) -> bool**
   - Remove LUT-related compositor nodes
   - If lut_name provided, remove only nodes matching that name
   - If None, remove all LUT_ and LUT_Mix_ nodes
   - Return True on success

3. **get_active_luts() -> list[str]**
   - Return list of active LUT node names in compositor
   - Find nodes starting with 'LUT_'
   - Return empty list if none active

**Key implementation notes:**
- Blender lacks a native LUT loading compositor node
- This implementation uses ColorBalance nodes to approximate LUT-style color grading
- The MixRGB node provides intensity blending at config.intensity ratio (0.8 default)
- For actual .cube LUT parsing, the ColorBalance parameters could be derived from LUT data
- The validate_lut_file() function ensures LUT files have correct precision before use
  </action>
  <verify>
grep -c "def apply_lut" lib/cinematic/color.py && \
grep -c "def remove_lut_nodes" lib/cinematic/color.py && \
grep -c "def get_active_luts" lib/cinematic/color.py && \
grep -c "config.intensity" lib/cinematic/color.py && \
grep -c "CompositorNodeMixRGB" lib/cinematic/color.py && \
grep -c "scene.node_tree" lib/cinematic/color.py
  </verify>
  <done>
Compositor-based LUT application exists with apply_lut() using config.intensity for blend control, remove_lut_nodes(), and get_active_luts().
</done>
</task>

<task type="auto">
  <name>Task 4: Add exposure lock system to color.py</name>
  <files>lib/cinematic/color.py</files>
  <action>
Add exposure lock / auto-exposure functions to lib/cinematic/color.py per REQ-CINE-LUT.

**Implement these functions:**

1. **calculate_auto_exposure(config: ExposureLockConfig, scene_luminance: Optional[float] = None) -> float**
   - Calculate exposure adjustment to hit target_gray (18% gray = 0.18)
   - If scene_luminance provided, calculate exposure offset
   - Formula: exposure = log2(target_gray / scene_luminance)
   - Clamp exposure to protect highlights (max exposure) and shadows (min exposure)
   - Per requirements: highlight_protection=0.95, shadow_protection=0.02
   - Return 0.0 if config.disabled or no luminance data
   - Note: Direct scene luminance requires render pass - return 0.0 as placeholder with documentation

2. **apply_exposure_lock(config: ExposureLockConfig) -> bool**
   - Apply auto-exposure based on config
   - Call calculate_auto_exposure() to get exposure value
   - Set scene.view_settings.exposure
   - Return True on success, False if Blender not available

3. **set_exposure(exposure: float) -> bool**
   - Direct exposure setter
   - Set scene.view_settings.exposure
   - Return True on success

4. **set_gamma(gamma: float) -> bool**
   - Direct gamma setter
   - Set scene.view_settings.gamma (clamped to 0-5)
   - Return True on success

5. **get_exposure_range() -> Tuple[float, float]**
   - Return valid exposure range (-10.0, 10.0) per Blender limits
   - Useful for UI validation

6. **get_gamma_range() -> Tuple[float, float]**
   - Return valid gamma range (0.0, 5.0) per Blender limits

**Important notes from research:**
- Direct scene luminance sampling is not available in Blender Python API
- For now, calculate_auto_exposure() accepts optional scene_luminance parameter
- Future implementation could use render passes for luminance calculation
- Document this limitation in docstrings
  </action>
  <verify>
grep -c "def calculate_auto_exposure" lib/cinematic/color.py && \
grep -c "def apply_exposure_lock" lib/cinematic/color.py && \
grep -c "def set_exposure" lib/cinematic/color.py && \
grep -c "def set_gamma" lib/cinematic/color.py && \
grep -c "target_gray" lib/cinematic/color.py
  </verify>
  <done>
Exposure lock system functions exist: calculate_auto_exposure, apply_exposure_lock, set_exposure, set_gamma.
</done>
</task>

</tasks>

<verification>
1. Verify color.py imports all required types and preset loaders
2. Verify set_view_transform() correctly sets all view_settings properties
3. Verify validate_lut_file() parses .cube files correctly
4. Verify apply_lut() creates compositor nodes and uses config.intensity for blending
5. Verify exposure lock functions follow requirements (18% gray, protection values)
6. Verify key link to compositor via scene.node_tree exists
7. Run python -c "from lib.cinematic.color import *; print('OK')" to verify syntax
</verification>

<success_criteria>
- color.py module exists with proper imports and BLENDER_AVAILABLE guard
- set_view_transform() sets view_transform, look, exposure, gamma, display_device
- set_working_color_space() configures scene working color space
- apply_color_preset() loads and applies presets from color_management_presets.yaml
- validate_lut_file() validates .cube file format and precision
- find_lut_path() searches multiple paths for LUT files
- apply_lut() creates compositor nodes (ColorBalance, MixRGB) and uses config.intensity for blend control
- remove_lut_nodes() and get_active_luts() manage LUT nodes
- calculate_auto_exposure() implements 18% gray targeting with highlight/shadow protection
- apply_exposure_lock() applies auto-exposure to scene
- Key link to compositor node_tree is established
- All functions return bool for success/failure
</success_criteria>

<output>
After completion, create `.planning/phases/06.4-color-pipeline/06.4-02-SUMMARY.md`
</output>
