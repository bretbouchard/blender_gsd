# Phase 13.5: Crowd Plugins Integration

**Goal**: Integrate crowd simulation plugins into GSD workflow.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-07)

**Depends On**: Phase 13.0 (Rigging)

**Duration**: 2-3 days

**Approach**: Use existing plugins rather than building from scratch.

---

## Overview

Integrate crowd simulation tools for:
- Pedestrians (walking, standing, talking)
- Audiences (seated, reacting)
- Vehicles (traffic, parking)
- Creatures (flocks, herds, swarms)

**Philosophy**: Don't reinvent. Wrap existing tools in GSD workflow.

---

## Plugin Options

| Plugin | Best For | License |
|--------|----------|---------|
| **Boids (built-in)** | Flocks, herds, swarms | Free |
| **BlenderCrowd** | Pedestrians, general crowds | Commercial |
| **CrowdSim3D** | Large-scale simulations | Commercial |
| **Agent327** | Procedural crowds | Free |

---

## Architecture

```
lib/animation/
├── crowd/
│   ├── __init__.py
│   ├── boids_wrapper.py     # Built-in boids integration
│   ├── plugin_interface.py  # Generic plugin interface
│   └── crowd_config.py      # Crowd configuration

configs/animation/
└── crowd/
    ├── pedestrian.yaml      # Pedestrian presets
    ├── audience.yaml        # Audience presets
    ├── flock.yaml           # Bird/fish flock presets
    └── traffic.yaml         # Traffic flow presets

.gsd-state/
└── crowd/
    └── {crowd_id}/
        ├── config.yaml
        └── preview.mp4
```

---

## Data Model

### Crowd Configuration
```yaml
# configs/animation/crowd/pedestrian.yaml
id: pedestrian_city
name: "City Pedestrians"

agent:
  mesh: "character_base"
  rig: "human_biped"
  animations:
    - walk
    - idle
    - talk

behavior:
  walk_speed: [0.8, 1.2]     # Random range
  idle_chance: 0.1           # 10% chance to idle
  group_chance: 0.3          # 30% chance to walk in groups

spawn:
  count: 100
  area: [[-50, -50], [50, 50]]
  height: 0.0

paths:
  - type: waypoint
    points: [[-50, 0], [50, 0]]
  - type: waypoint
    points: [[0, -50], [0, 50]]

avoidance:
  radius: 0.5
  other_agents: true
  obstacles: true

variation:
  scale: [0.9, 1.1]
  colors:
    shirt: ["#336699", "#993366", "#669933"]
    pants: ["#333333", "#1a1a1a", "#4a4a4a"]
```

### Types
```python
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Optional
from enum import Enum

class CrowdType(Enum):
    PEDESTRIAN = "pedestrian"
    AUDIENCE = "audience"
    VEHICLE = "vehicle"
    CREATURE = "creature"
    CUSTOM = "custom"

class BehaviorState(Enum):
    WALK = "walk"
    IDLE = "idle"
    FLEE = "flee"
    FOLLOW = "follow"
    GROUP = "group"

@dataclass
class AgentConfig:
    mesh_path: str
    rig_type: str
    animations: List[str] = field(default_factory=list)

@dataclass
class BehaviorConfig:
    walk_speed: Tuple[float, float] = (1.0, 1.5)
    idle_chance: float = 0.1
    flee_distance: float = 10.0
    group_chance: float = 0.3

@dataclass
class SpawnConfig:
    count: int = 50
    area: Tuple[Tuple[float, float], Tuple[float, float]] = ((-10, -10), (10, 10))
    height: float = 0.0
    distribution: str = "random"  # random, grid, path

@dataclass
class AvoidanceConfig:
    radius: float = 0.5
    avoid_agents: bool = True
    avoid_obstacles: bool = True
    avoidance_strength: float = 1.0

@dataclass
class VariationConfig:
    scale_range: Tuple[float, float] = (0.9, 1.1)
    color_variations: Dict[str, List[str]] = field(default_factory=dict)
    random_rotation: bool = True

@dataclass
class CrowdConfig:
    id: str
    name: str
    crowd_type: CrowdType
    agent: AgentConfig
    behavior: BehaviorConfig = field(default_factory=BehaviorConfig)
    spawn: SpawnConfig = field(default_factory=SpawnConfig)
    avoidance: AvoidanceConfig = field(default_factory=AvoidanceConfig)
    variation: VariationConfig = field(default_factory=VariationConfig)
```

---

## Tasks

### Task 1: Boids Wrapper (Built-in)
**File**: `lib/animation/crowd/boids_wrapper.py`

```python
import bpy
from typing import List, Tuple, Optional
from ..types import CrowdConfig, BehaviorState

class BoidsWrapper:
    """Wrapper for Blender's built-in boids system."""

    @staticmethod
    def create_boids_system(
        name: str,
        particle_count: int = 100,
        render_type: str = 'OBJECT'
    ) -> bpy.types.ParticleSystem:
        """Create a boids particle system."""
        # Create or use existing emitter
        emitter = bpy.context.active_object
        if not emitter:
            bpy.ops.mesh.primitive_plane_add(size=10)
            emitter = bpy.context.active_object

        # Add particle system
        ps = emitter.modifiers.new(name=name, type='PARTICLE_SYSTEM')
        settings = ps.particle_system.settings

        # Configure as boids
        settings.physics_type = 'BOIDS'
        settings.count = particle_count
        settings.render_type = render_type

        # Boid settings
        boids = settings.boids
        boids.use_flight = False
        boids.use_land = True
        boids.use_climb = False

        # Land rules
        states = boids.states
        state = states[0]

        # Add walking behavior
        rule = state.rules.add()
        rule.type = 'FOLLOW_LEADER'
        rule.use_predict = True

        rule = state.rules.add()
        rule.type = 'AVOID_COLLISION'
        rule.use_predict = True

        return ps

    @staticmethod
    def set_agent_object(particle_system: bpy.types.ParticleSystem, obj: bpy.types.Object) -> None:
        """Set the object to render for each boid."""
        settings = particle_system.settings
        settings.render_type = 'OBJECT'
        settings.object = obj

    @staticmethod
    def set_behavior_rules(
        particle_system: bpy.types.ParticleSystem,
        rules: List[Tuple[str, float]]
    ) -> None:
        """Set boid behavior rules with weights."""
        settings = particle_system.settings
        state = settings.boids.states[0]

        # Clear existing rules
        while state.rules:
            state.rules.remove(0)

        # Add new rules
        for rule_type, weight in rules:
            rule = state.rules.add()
            rule.type = rule_type

        # Set weights
        for i, (rule_type, weight) in enumerate(rules):
            state.rules[i].use_enable = True

    @staticmethod
    def add_flock_behavior(particle_system: bpy.types.ParticleSystem) -> None:
        """Add standard flocking behavior."""
        BoidsWrapper.set_behavior_rules(particle_system, [
            ('SEPARATE', 1.0),
            ('ALIGN', 0.5),
            ('COHESION', 0.3),
            ('AVOID_COLLISION', 1.0),
        ])

    @staticmethod
    def add_follow_path_behavior(
        particle_system: bpy.types.ParticleSystem,
        curve: bpy.types.Curve
    ) -> None:
        """Add follow path behavior."""
        settings = particle_system.settings
        state = settings.boids.states[0]

        rule = state.rules.add()
        rule.type = 'FOLLOW_CURVE'
        rule.object = curve


def create_flock(
    name: str,
    agent_object: bpy.types.Object,
    count: int = 50
) -> bpy.types.ParticleSystem:
    """Create a flock of agents using boids."""
    ps = BoidsWrapper.create_boids_system(name, count, 'OBJECT')
    BoidsWrapper.set_agent_object(ps, agent_object)
    BoidsWrapper.add_flock_behavior(ps)
    return ps
```

**Acceptance**: Boids wrapper works

---

### Task 2: Plugin Interface
**File**: `lib/animation/crowd/plugin_interface.py`

```python
import bpy
from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Any
from pathlib import Path
import yaml

class CrowdPluginInterface(ABC):
    """Abstract interface for crowd plugins."""

    @abstractmethod
    def is_available(self) -> bool:
        """Check if plugin is installed and available."""
        pass

    @abstractmethod
    def create_crowd(self, config: Dict) -> Any:
        """Create a crowd from configuration."""
        pass

    @abstractmethod
    def update_behavior(self, crowd_id: str, behavior: Dict) -> None:
        """Update crowd behavior."""
        pass

    @abstractmethod
    def export_to_gsd(self, crowd_id: str, output_path: Path) -> None:
        """Export crowd data to GSD format."""
        pass


class BoidsPlugin(CrowdPluginInterface):
    """Boids plugin using Blender's built-in system."""

    def is_available(self) -> bool:
        return True  # Always available

    def create_crowd(self, config: Dict) -> Any:
        from .boids_wrapper import BoidsWrapper

        spawn = config.get('spawn', {})
        behavior = config.get('behavior', {})

        ps = BoidsWrapper.create_boids_system(
            config['name'],
            spawn.get('count', 50)
        )

        # Apply behavior rules
        rules = []
        if behavior.get('flocking'):
            rules.extend([
                ('SEPARATE', 1.0),
                ('ALIGN', 0.5),
                ('COHESION', 0.3),
            ])
        if behavior.get('avoid_obstacles'):
            rules.append(('AVOID_COLLISION', 1.0))

        if rules:
            BoidsWrapper.set_behavior_rules(ps, rules)

        return ps

    def update_behavior(self, crowd_id: str, behavior: Dict) -> None:
        # Find particle system by name
        for obj in bpy.data.objects:
            for mod in obj.modifiers:
                if mod.type == 'PARTICLE_SYSTEM' and mod.name == crowd_id:
                    # Update behavior
                    pass

    def export_to_gsd(self, crowd_id: str, output_path: Path) -> None:
        # Export configuration
        pass


class BlenderCrowdPlugin(CrowdPluginInterface):
    """BlenderCrowd plugin integration."""

    def is_available(self) -> bool:
        # Check if BlenderCrowd addon is installed
        return 'blender_crowd' in bpy.context.preferences.addons

    def create_crowd(self, config: Dict) -> Any:
        if not self.is_available():
            raise RuntimeError("BlenderCrowd plugin not installed")

        # Import and use BlenderCrowd API
        # This would depend on the actual plugin API
        pass

    def update_behavior(self, crowd_id: str, behavior: Dict) -> None:
        pass

    def export_to_gsd(self, crowd_id: str, output_path: Path) -> None:
        pass


# Plugin registry
PLUGINS = {
    'boids': BoidsPlugin(),
    'blender_crowd': BlenderCrowdPlugin(),
}

def get_plugin(name: str) -> CrowdPluginInterface:
    """Get a crowd plugin by name."""
    if name in PLUGINS:
        return PLUGINS[name]

    # Return boids as default
    return PLUGINS['boids']

def get_available_plugins() -> List[str]:
    """Get list of available plugins."""
    return [name for name, plugin in PLUGINS.items() if plugin.is_available()]
```

**Acceptance**: Plugin interface works

---

### Task 3: Crowd Configuration
**File**: `lib/animation/crowd/crowd_config.py`

```python
import yaml
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import asdict

from ..types import (
    CrowdConfig, CrowdType, AgentConfig, BehaviorConfig,
    SpawnConfig, AvoidanceConfig, VariationConfig
)

CROWD_CONFIG_ROOT = Path(__file__).parent.parent.parent.parent / "configs" / "animation" / "crowd"

class CrowdConfigManager:
    """Manage crowd configurations."""

    @staticmethod
    def load(config_id: str) -> CrowdConfig:
        """Load a crowd configuration from YAML."""
        path = CROWD_CONFIG_ROOT / f"{config_id}.yaml"

        if not path.exists():
            raise FileNotFoundError(f"Crowd config not found: {config_id}")

        with open(path) as f:
            data = yaml.safe_load(f)

        return CrowdConfigManager._parse_config(data)

    @staticmethod
    def _parse_config(data: dict) -> CrowdConfig:
        """Parse YAML data into CrowdConfig."""
        agent = AgentConfig(
            mesh_path=data.get('agent', {}).get('mesh', ''),
            rig_type=data.get('agent', {}).get('rig', 'human_biped'),
            animations=data.get('agent', {}).get('animations', [])
        )

        behavior_data = data.get('behavior', {})
        behavior = BehaviorConfig(
            walk_speed=tuple(behavior_data.get('walk_speed', [1.0, 1.5])),
            idle_chance=behavior_data.get('idle_chance', 0.1),
            group_chance=behavior_data.get('group_chance', 0.3)
        )

        spawn_data = data.get('spawn', {})
        spawn = SpawnConfig(
            count=spawn_data.get('count', 50),
            area=tuple(tuple(p) for p in spawn_data.get('area', [[-10, -10], [10, 10]])),
            height=spawn_data.get('height', 0.0)
        )

        avoidance_data = data.get('avoidance', {})
        avoidance = AvoidanceConfig(
            radius=avoidance_data.get('radius', 0.5),
            avoid_agents=avoidance_data.get('other_agents', True),
            avoid_obstacles=avoidance_data.get('obstacles', True)
        )

        variation_data = data.get('variation', {})
        variation = VariationConfig(
            scale_range=tuple(variation_data.get('scale', [0.9, 1.1])),
            color_variations=variation_data.get('colors', {})
        )

        return CrowdConfig(
            id=data['id'],
            name=data['name'],
            crowd_type=CrowdType(data.get('type', 'pedestrian')),
            agent=agent,
            behavior=behavior,
            spawn=spawn,
            avoidance=avoidance,
            variation=variation
        )

    @staticmethod
    def save(config: CrowdConfig, path: Optional[Path] = None) -> Path:
        """Save crowd configuration to YAML."""
        save_path = path or (CROWD_CONFIG_ROOT / f"{config.id}.yaml")
        save_path.parent.mkdir(parents=True, exist_ok=True)

        data = {
            'id': config.id,
            'name': config.name,
            'type': config.crowd_type.value,
            'agent': {
                'mesh': config.agent.mesh_path,
                'rig': config.agent.rig_type,
                'animations': config.agent.animations
            },
            'behavior': {
                'walk_speed': list(config.behavior.walk_speed),
                'idle_chance': config.behavior.idle_chance,
                'group_chance': config.behavior.group_chance
            },
            'spawn': {
                'count': config.spawn.count,
                'area': [list(p) for p in config.spawn.area],
                'height': config.spawn.height
            },
            'avoidance': {
                'radius': config.avoidance.radius,
                'other_agents': config.avoidance.avoid_agents,
                'obstacles': config.avoidance.avoid_obstacles
            },
            'variation': {
                'scale': list(config.variation.scale_range),
                'colors': config.variation.color_variations
            }
        }

        with open(save_path, 'w') as f:
            yaml.dump(data, f, default_flow_style=False)

        return save_path

    @staticmethod
    def list_configs() -> List[str]:
        """List available crowd configurations."""
        if not CROWD_CONFIG_ROOT.exists():
            return []

        return [f.stem for f in CROWD_CONFIG_ROOT.glob("*.yaml")]


def load_crowd_config(config_id: str) -> CrowdConfig:
    """Convenience function to load crowd config."""
    return CrowdConfigManager.load(config_id)
```

**Acceptance**: Can load/save crowd configs

---

### Task 4: Create Preset Configs
**Files**: `configs/animation/crowd/*.yaml`

Create 4 preset files:
- `pedestrian.yaml` - City pedestrians
- `audience.yaml` - Seated audience
- `flock.yaml` - Bird/fish flock
- `traffic.yaml` - Vehicle traffic

**Acceptance**: Presets available

---

## Acceptance Criteria

### Must Have
- [ ] Boids wrapper for built-in particle system
- [ ] Plugin interface definition
- [ ] Load/save crowd configurations
- [ ] 4 preset configurations

### Nice to Have
- [ ] BlenderCrowd integration
- [ ] CrowdSim3D integration
- [ ] Bake to keyframes
- [ ] LOD system

---

## Commands

```python
# Create flock using boids
from lib.animation.crowd import create_flock
flock = create_flock("birds", bird_object, count=100)

# Load crowd config
from lib.animation.crowd import load_crowd_config
config = load_crowd_config("pedestrian_city")

# Create crowd from config
from lib.animation.crowd import get_plugin
plugin = get_plugin('boids')
crowd = plugin.create_crowd(config)
```

---

## AI Commands Reference

```
# Create crowd
"Create 100 pedestrians in the city scene"

# Create flock
"Create a flock of 50 birds"

# Load preset
"Load the audience preset for the concert scene"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Render Rick - Performance Critical

1. **Particle Count Limits**
   - No documented limits for crowd size
   - Risk: Users may create crowds that crash Blender
   - Recommendation: Add `MAX_PARTICLE_COUNT = 5000` constant with warnings

2. **Instance Optimization**
   - Boids wrapper uses object instances but doesn't optimize for variety
   - Recommendation: Add collection instance support for efficient variation

### Automation Rick - Plugin Architecture

3. **Plugin Availability Check**
   - `BlenderCrowdPlugin.is_available()` checks addons but doesn't verify version
   - Recommendation: Add minimum version requirement checking

4. **Plugin Interface Incomplete**
   - `BoidsPlugin.export_to_gsd()` is stubbed
   - Risk: Feature incomplete, no export capability
   - Recommendation: Mark as "Phase 2" or implement basic export

### Dufus Rick - Testing Recommendations

5. **Test Tasks to Add**
   - Task: Test boids with 0 particles (edge case)
   - Task: Verify behavior rules persistence across file save/load
   - Task: Test crowd config with invalid mesh paths
   - Task: Verify spawn area edge cases (negative dimensions)
   - Task: Test color variation with invalid hex values

6. **Acceptance Criteria Improvements**
   - "4 preset configurations" → "4 validated preset configurations with test scenes"
   - Add: "Crowd of 500 agents renders at 24fps minimum"
