---
phase: 08.1-follow-modes
plan: 02
type: execute
wave: 2
depends_on: ["08.1-01"]
files_modified:
  - lib/cinematic/follow_cam/follow_modes.py
autonomous: true

must_haves:
  truths:
    - "Side-scroller mode locks camera to a plane"
    - "Over-shoulder mode positions camera behind and to the side"
    - "Chase mode adjusts distance based on target speed"
    - "Orbit-follow mode rotates around subject while following"
    - "Lead mode positions camera ahead of subject"
    - "Aerial mode provides top-down view"
    - "Free roam mode allows free camera movement with collision"
    - "All modes calculate ideal position, yaw, and pitch"
  artifacts:
    - path: "lib/cinematic/follow_cam/follow_modes.py"
      provides: "All 8 follow mode implementations"
      exports: ["calculate_ideal_position", "smooth_position", "smooth_angle", "calculate_camera_rotation"]
      min_lines: 500
  key_links:
    - from: "calculate_ideal_position()"
      to: "FollowCameraConfig.follow_mode"
      via: "mode dispatch"
      pattern: "FollowMode\\."
    - from: "follow_modes.py"
      to: "types.py"
      via: "import"
      pattern: "from \\.types import"
---

<objective>
Implement all 8 follow camera mode calculations.

Purpose: Create the core follow mode logic that calculates ideal camera position, yaw, and pitch for each of the 8 follow modes based on target position, direction, velocity, and configuration.

Output: Working follow mode implementations with position/rotation calculations.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS_FOLLOW_CAMERA.md

# Dependencies
@.planning/phases/08.1-follow-modes/08.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Main Mode Dispatcher and Smoothing</name>
  <files>lib/cinematic/follow_cam/follow_modes.py</files>
  <action>
Create `lib/cinematic/follow_cam/follow_modes.py` with the main dispatcher and smoothing utilities:

1. **calculate_ideal_position()** - Main dispatcher function:
   - Takes: target_position, target_forward, target_velocity, config, current_yaw, delta_time
   - Returns: Tuple[Vector, yaw, pitch]
   - Routes to mode-specific calculation based on config.follow_mode
   - Dispatches to: _calc_side_scroller, _calc_over_shoulder, _calc_chase, _calc_chase_side, _calc_orbit_follow, _calc_lead, _calc_aerial, _calc_free_roam

2. **Smoothing functions**:
   - smooth_position(current, target, smoothing, delta_time) - Exponential decay smoothing for position
   - smooth_angle(current, target, smoothing, delta_time) - Angle-aware smoothing that handles 350->10 degree transitions

3. **Utility functions**:
   - calculate_camera_rotation(camera_pos, target_pos) - Returns (yaw, pitch, roll) to look at target
   - get_target_forward_direction(target_velocity, default_forward) - Get forward direction from velocity

4. **Blender API guard**:
   - Wrap mathutils imports in try/except
   - Provide fallback Vector, Matrix, Euler classes for testing outside Blender
   - HAS_BLENDER flag for conditional behavior
  </action>
  <verify>
    python3 -c "from lib.cinematic.follow_cam.follow_modes import calculate_ideal_position, smooth_position; print('OK')"
  </verify>
  <done>
calculate_ideal_position() function dispatches to all 8 modes, smoothing functions handle edge cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Side-Scroller and Over-Shoulder Modes</name>
  <files>lib/cinematic/follow_cam/follow_modes.py</files>
  <action>
Implement two primary follow modes in `follow_modes.py`:

**_calc_side_scroller(target_pos, config, delta_time)**:
- Apply LockedPlane constraint (XZ, XY, or YZ)
- XZ plane: Lock Y-axis (traditional side-scrolling), look perpendicular to locked axis
- XY plane: Lock Z-axis (top-down platformer), look straight down (pitch -90)
- YZ plane: Lock X-axis (front-facing platformer), look perpendicular
- Use config.locked_plane and config.locked_axis_value
- Return (position, yaw, pitch)

**_calc_over_shoulder(target_pos, target_fwd, config, current_yaw, delta_time)**:
- Calculate right vector from forward x up cross product
- Position = target_pos - forward*distance + up*height + right*shoulder_offset
- Negative shoulder_offset = left shoulder
- Calculate look direction to target
- Return (position, yaw, pitch)

**_apply_axis_lock(position, locked_plane, locked_value)**:
- Helper to apply axis locking to any position
- Set locked axis to fixed value based on plane
  </action>
  <verify>
    python3 -c "
from lib.cinematic.follow_cam.follow_modes import _calc_side_scroller, _calc_over_shoulder
from lib.cinematic.follow_cam.types import FollowCameraConfig, LockedPlane
config = FollowCameraConfig()
pos, yaw, pitch = _calc_over_shoulder(type('V', (), {'copy': lambda s: type('V', (), {'x': 0, 'y': 0, 'z': 1.5})()})(), type('V', (), {'normalized': lambda s: type('V', (), {'x': 0, 'y': 1, 'z': 0})()})(), config, 0, 1/60)
print(f'Over-shoulder: pos={pos}, yaw={yaw}, pitch={pitch}')
"
  </verify>
  <done>
Side-scroller mode respects locked plane, over-shoulder calculates correct offset position
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Chase Modes (Chase + Chase-Side)</name>
  <files>lib/cinematic/follow_cam/follow_modes.py</files>
  <action>
Implement chase camera modes in `follow_modes.py`:

**_calc_chase(target_pos, target_fwd, target_vel, config, current_yaw, delta_time)**:
- Calculate speed from target_vel.length()
- Apply speed-based distance: effective_distance = ideal_distance + min(speed * speed_distance_factor, max_speed_distance)
- Clamp to min_distance/max_distance
- Position = target_pos - forward*effective_distance + up*height
- Calculate yaw/pitch to look at target

**_calc_chase_side(target_pos, target_fwd, target_vel, config, current_yaw, delta_time)**:
- Similar to chase but positioned to the side
- Calculate right vector for side offset
- Use shoulder_offset as side distance (positive or negative)
- Position = target_pos + right*shoulder_offset - forward*distance*0.5 + up*height
- Partially behind, partially to the side
- Good for racing game side views

Both modes use config.speed_distance_factor and config.max_speed_distance for speed response.
  </action>
  <verify>
    python3 -c "from lib.cinematic.follow_cam.follow_modes import _calc_chase, _calc_chase_side; print('Chase modes OK')"
  </verify>
  <done>
Chase mode increases distance with speed, chase-side positions camera at side angle
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement Advanced Modes (Orbit-Follow, Lead, Aerial, Free-Roam)</name>
  <files>lib/cinematic/follow_cam/follow_modes.py</files>
  <action>
Implement remaining 4 follow modes in `follow_modes.py`:

**_calc_orbit_follow(target_pos, config, current_yaw, delta_time)**:
- Update orbit angle: orbit_angle = current_yaw + orbit_speed * delta_time
- Calculate position on circle: x = sin(angle)*distance, y = cos(angle)*distance
- Position at ideal_height above target
- Creates continuous orbiting motion

**_calc_lead(target_pos, target_fwd, config, current_yaw, delta_time)**:
- Position ahead of target: forward_offset = target_fwd * lead_distance
- Camera faces backward to look at target
- Good for showing where subject is going
- Use config.lead_distance for how far ahead

**_calc_aerial(target_pos, config, delta_time)**:
- Position directly above target at ideal_height
- Look nearly straight down (pitch -89 to avoid gimbal lock)
- Top-down bird's eye view
- No rotation needed (yaw = 0)

**_calc_free_roam(target_pos, config, current_yaw, delta_time)**:
- Use current_yaw for orbit-style positioning
- Calculate position on circle at current yaw angle
- Note: Actual collision handling done by collision module
- This calculates ideal position; collision adjusts it
- Provides freedom of movement while maintaining subject framing
  </action>
  <verify>
    python3 -c "from lib.cinematic.follow_cam.follow_modes import _calc_orbit_follow, _calc_lead, _calc_aerial, _calc_free_roam; print('All advanced modes OK')"
  </verify>
  <done>
Orbit-follow rotates around subject, lead positions ahead, aerial looks down, free-roam allows flexible positioning
  </done>
</task>

</tasks>

<verification>
1. All 8 modes have implementation functions (_calc_*)
2. calculate_ideal_position() dispatches to correct mode
3. Each mode returns Tuple[Vector, float, float] for position, yaw, pitch
4. Smoothing functions handle edge cases (angle wrapping, zero smoothing)
5. Module works outside Blender (fallback Vector class)
</verification>

<success_criteria>
- calculate_ideal_position() handles all 8 FollowMode values
- Each mode produces valid position/rotation output
- Code runs without Blender (for unit testing)
- Smoothing prevents jarring camera movements
</success_criteria>

<output>
After completion, create `.planning/phases/08.1-follow-modes/08.1-02-SUMMARY.md`
</output>
