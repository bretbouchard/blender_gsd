# Phase 6.2: Lighting System - Research

**Researched:** 2026-02-18
**Domain:** Blender Python API (bpy) Lighting System
**Confidence:** HIGH

## Summary

This phase implements a comprehensive lighting system for the cinematic module, building on the existing camera system (Phase 6.1). The system supports four light types (Area, Spot, Point, Sun), HDRI environment lighting via world shader nodes, light linking for selective illumination (Blender 4.0+), gel/color filter system, and 8 preset lighting rigs.

Research was conducted using official Blender Python API documentation from docs.blender.org, verified against the existing codebase patterns in `lib/cinematic/camera.py` and `lib/cinematic/rigs.py`. The existing `LightConfig` dataclass and `LightType` enum provide foundation but require extension for full feature coverage.

**Primary recommendation:** Follow the established pattern from `camera.py` with guarded bpy imports, extend `LightConfig` dataclass with light-type-specific fields, implement HDRI via world shader node tree manipulation, and use `ObjectLightLinking` for selective illumination on Blender 4.0+.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library/Module | Version | Purpose | Why Standard |
|----------------|---------|---------|--------------|
| bpy.types.Light | Blender 4.0+ | Base light class | Official Blender API |
| bpy.types.AreaLight | Blender 4.0+ | Area light properties | Only way to configure area lights |
| bpy.types.SpotLight | Blender 4.0+ | Spot light properties | Official Blender API |
| bpy.types.PointLight | Blender 4.0+ | Point light properties | Official Blender API |
| bpy.types.SunLight | Blender 4.0+ | Sun light properties | Official Blender API |
| bpy.types.ObjectLightLinking | Blender 4.0+ | Light linking | Blender 4.0+ feature for selective illumination |
| bpy.types.ShaderNodeTexEnvironment | Blender 4.0+ | HDRI environment textures | Standard for HDRI in world shader |
| PyYAML | 6.0+ | Preset configuration | Already used in codebase |

### Supporting
| Library/Module | Purpose | When to Use |
|----------------|---------|-------------|
| bpy.types.World | HDRI environment container | When setting up HDRI lighting |
| bpy.types.ShaderNodeBackground | Background shader node | HDRI intensity/exposure control |
| bpy.types.ShaderNodeMapping | HDRI rotation/position | When HDRI needs rotation |
| bpy.types.ShaderNodeTexCoord | Texture coordinates | HDRI mapping |

### Existing Codebase (Reuse)
| Module | Location | What to Reuse |
|--------|----------|---------------|
| LightConfig dataclass | `lib/cinematic/types.py` | Base light config (extend for light-type-specific) |
| LightType enum | `lib/cinematic/enums.py` | Light type constants |
| preset_loader | `lib/cinematic/preset_loader.py` | YAML preset loading pattern |
| Transform3D | `lib/cinematic/types.py` | Position/rotation/scale |
| Guarded bpy import | `lib/cinematic/camera.py` | BLENDER_AVAILABLE pattern |

**Installation:**
No additional installation required. All dependencies are part of Blender's Python environment. PyYAML already in use.

## Architecture Patterns

### Recommended Module Structure
```
lib/cinematic/
  lighting.py           # Main lighting module (create_light, setup_light_linking)
  hdri.py               # HDRI environment system (setup_hdri, load_hdri_preset)
  gel.py                # Gel/color filter system (apply_gel, gel_rgb_conversion)
  types.py              # Extended dataclasses (extend LightConfig)

configs/cinematic/lighting/
  rig_presets.yaml      # 8 preset lighting rigs (EXISTS)
  gel_presets.yaml      # Gel/color filter presets (EXISTS)
  hdri_presets.yaml     # HDRI environment presets (EXISTS)
```

### Pattern 1: Guarded bpy Import (CRITICAL)
**What:** All bpy access must be wrapped in try/except with BLENDER_AVAILABLE flag
**When to use:** Every module that accesses bpy
**Example:**
```python
# Source: lib/cinematic/camera.py pattern
try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False

def create_light(config: LightConfig) -> Optional[Any]:
    if not BLENDER_AVAILABLE:
        return None
    # ... bpy operations
```

### Pattern 2: Light Creation Function
**What:** Single factory function that creates any light type based on config
**When to use:** When creating lights from presets or user input
**Example:**
```python
# Source: Based on camera.py create_camera pattern + Blender API docs
def create_light(
    config: LightConfig,
    collection: Optional[Any] = None,
    set_active: bool = False
) -> Optional[Any]:
    """
    Create a light object from LightConfig.

    Handles all four light types: area, spot, point, sun.
    """
    if not BLENDER_AVAILABLE:
        return None

    try:
        scene = bpy.context.scene

        # Create light data based on type
        light_data = bpy.data.lights.new(name=config.name, type=config.light_type.upper())

        # Apply common properties
        light_data.color = config.color
        light_data.energy = config.intensity

        # Type-specific properties
        if config.light_type == "area":
            light_data.shape = config.shape  # SQUARE, RECTANGLE, DISK, ELLIPSE
            light_data.size = config.size
            light_data.spread = config.spread  # 0 to pi
        elif config.light_type == "spot":
            light_data.spot_size = config.spot_size  # angle in radians
            light_data.spot_blend = config.spot_blend  # 0-1 softness

        # Create object and link
        light_obj = bpy.data.objects.new(config.name, light_data)
        # Apply transform...
        collection.objects.link(light_obj)

        return light_obj
    except Exception:
        return None
```

### Pattern 3: HDRI Setup via World Nodes
**What:** HDRI requires setting up world shader node tree with environment texture
**When to use:** When loading HDRI environment lighting
**Example:**
```python
# Source: Blender API standard pattern
def setup_hdri(hdri_path: str, exposure: float = 0.0, rotation: float = 0.0) -> bool:
    if not BLENDER_AVAILABLE:
        return False

    try:
        scene = bpy.context.scene

        # Get or create world
        if not scene.world:
            scene.world = bpy.data.worlds.new("World")

        world = scene.world
        world.use_nodes = True
        tree = world.node_tree

        # Clear existing nodes
        for node in tree.nodes:
            tree.nodes.remove(node)

        # Create nodes
        coord = tree.nodes.new('ShaderNodeTexCoord')
        mapping = tree.nodes.new('ShaderNodeMapping')
        env_tex = tree.nodes.new('ShaderNodeTexEnvironment')
        background = tree.nodes.new('ShaderNodeBackground')
        output = tree.nodes.new('ShaderNodeOutputWorld')

        # Load HDRI image
        env_tex.image = bpy.data.images.load(hdri_path)

        # Set exposure
        background.inputs['Strength'].default_value = 1.0 + exposure

        # Set rotation via mapping node
        mapping.inputs['Rotation'].default_value[2] = rotation

        # Link nodes
        tree.links.new(coord.outputs['Generated'], mapping.inputs['Vector'])
        tree.links.new(mapping.outputs['Vector'], env_tex.inputs['Vector'])
        tree.links.new(env_tex.outputs['Color'], background.inputs['Color'])
        tree.links.new(background.outputs['Background'], output.inputs['Surface'])

        return True
    except Exception:
        return False
```

### Pattern 4: Light Linking (Blender 4.0+)
**What:** Use ObjectLightLinking for selective light illumination
**When to use:** When lights should only affect specific objects
**Example:**
```python
# Source: bpy.types.ObjectLightLinking docs
def setup_light_linking(
    light_name: str,
    receiver_objects: List[str],
    blocker_objects: Optional[List[str]] = None
) -> bool:
    if not BLENDER_AVAILABLE:
        return False

    try:
        light_obj = bpy.data.objects[light_name]

        # Create receiver collection
        receiver_col = bpy.data.collections.new(f"{light_name}_receivers")
        for obj_name in receiver_objects:
            if obj_name in bpy.data.objects:
                receiver_col.objects.link(bpy.data.objects[obj_name])

        # Set light linking
        light_obj.light_linking.receiver_collection = receiver_col

        # Optionally set blockers
        if blocker_objects:
            blocker_col = bpy.data.collections.new(f"{light_name}_blockers")
            for obj_name in blocker_objects:
                if obj_name in bpy.data.objects:
                    blocker_col.objects.link(bpy.data.objects[obj_name])
            light_obj.light_linking.blocker_collection = blocker_col

        return True
    except Exception:
        return False
```

### Pattern 5: Kelvin Temperature to RGB Conversion
**What:** Convert color temperature (Kelvin) to RGB values for light color
**When to use:** When user specifies temperature instead of color, or for gel presets
**Example:**
```python
# Source: Standard algorithm, Tanner Helland implementation
def kelvin_to_rgb(kelvin: float) -> Tuple[float, float, float]:
    """
    Convert color temperature in Kelvin to RGB.

    Valid range: 1000K to 40000K (common photographic: 2000K-10000K)

    Common values:
    - Candle: 1900K
    - Tungsten: 3200K
    - Daylight: 5500K-6500K
    - Overcast: 7000K
    - Blue sky: 10000K+
    """
    kelvin = max(1000, min(40000, kelvin))
    temp = kelvin / 100.0

    # Red
    if temp <= 66:
        red = 255
    else:
        red = 329.698727446 * ((temp - 60) ** -0.1332047592)
        red = max(0, min(255, red))

    # Green
    if temp <= 66:
        green = 99.4708025861 * math.log(temp) - 161.1195681661
    else:
        green = 288.1221695283 * ((temp - 60) ** -0.0755148492)
    green = max(0, min(255, green))

    # Blue
    if temp >= 66:
        blue = 255
    elif temp <= 19:
        blue = 0
    else:
        blue = 138.5177312231 * math.log(temp - 10) - 305.0447927307
        blue = max(0, min(255, blue))

    return (red / 255.0, green / 255.0, blue / 255.0)
```

### Anti-Patterns to Avoid
- **Direct color assignment without validation:** Always validate color tuples are 0-1 range, not 0-255
- **HDRI without world node tree:** Must set use_nodes=True and create proper node connections
- **Light linking without version check:** ObjectLightLinking only available in Blender 4.0+
- **Missing BLENDER_AVAILABLE guard:** Code will crash when tested outside Blender

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Kelvin to RGB conversion | Custom algorithm | Blender's `use_temperature` + `temperature` property | Blender 4.0+ has built-in temperature mode |
| HDRI loading | Custom image loader | `bpy.data.images.load()` + ShaderNodeTexEnvironment | Standard Blender workflow |
| Light linking | Custom shadow system | `ObjectLightLinking` with collections | Blender 4.0+ native feature |
| Light presets | Hardcoded dictionaries | YAML presets + `preset_loader.py` | Already established pattern |
| Gel RGB values | Hardcoded color tuples | `gel_presets.yaml` with CTB/CTO values | Industry-standard gel values |

**Key insight:** Blender 4.0+ has native color temperature support via `light.use_temperature = True` and `light.temperature = 6500`. Use this instead of manual Kelvin conversion when available.

## Common Pitfalls

### Pitfall 1: Blender Version Compatibility
**What goes wrong:** Light linking code crashes on Blender 3.x
**Why it happens:** ObjectLightLinking is Blender 4.0+ only
**How to avoid:** Check `bpy.app.version >= (4, 0, 0)` before using light linking
**Warning signs:** AttributeError on `light_linking` attribute

### Pitfall 2: Energy vs Intensity Confusion
**What goes wrong:** Lights appear too bright or too dim
**Why it happens:** Blender uses "energy" in Watts, not arbitrary "intensity" values
**How to avoid:** Use physically plausible energy values (100W-1000W for studio lights)
**Warning signs:** Rendered image pure white or black

### Pitfall 3: HDRI Image Not Found
**What goes wrong:** `bpy.data.images.load()` raises error for missing file
**Why it happens:** HDRI files not downloaded or path incorrect
**How to avoid:** Implement multi-path search and file existence check before loading
**Warning signs:** FileNotFoundError or image loading fails silently

### Pitfall 4: Spot Light Angle Units
**What goes wrong:** Spot cone is wrong size
**Why it happens:** `spot_size` is in radians (0.017 to 3.14), not degrees
**How to avoid:** Convert degrees to radians: `math.radians(degrees)`
**Warning signs:** Spot cone way too narrow or wide

### Pitfall 5: Area Light Shape Enum
**What goes wrong:** Invalid shape value causes error
**Why it happens:** Shape must be uppercase string ('SQUARE', not 'square')
**How to avoid:** Use enum values or uppercase strings from LightShape enum
**Warning signs:** TypeError or invalid enum value

### Pitfall 6: Collection Linking Issues
**What goes wrong:** Light not visible in render
**Why it happens:** Light object not linked to scene collection
**How to avoid:** Always link created objects to a collection (scene or custom)
**Warning signs:** Light exists in bpy.data.objects but not visible

## Code Examples

Verified patterns from official Blender API documentation:

### Create Area Light
```python
# Source: bpy.types.AreaLight docs
def create_area_light(config: LightConfig) -> Optional[Any]:
    if not BLENDER_AVAILABLE:
        return None

    try:
        # Create light data
        light_data = bpy.data.lights.new(name=config.name, type='AREA')

        # Area-specific properties
        light_data.shape = 'RECTANGLE'  # SQUARE, RECTANGLE, DISK, ELLIPSE
        light_data.size = 1.0           # Width (for all shapes)
        light_data.size_y = 2.0         # Height (for RECTANGLE, ELLIPSE)
        light_data.spread = math.pi / 3 # 0 to pi radians

        # Common properties
        light_data.energy = 1000.0      # Watts
        light_data.color = (1.0, 1.0, 1.0)
        light_data.use_shadow = True
        light_data.shadow_soft_size = 0.1

        # Create object
        light_obj = bpy.data.objects.new(config.name, light_data)
        bpy.context.scene.collection.objects.link(light_obj)

        return light_obj
    except Exception:
        return None
```

### Create Spot Light
```python
# Source: bpy.types.SpotLight docs
def create_spot_light(config: LightConfig) -> Optional[Any]:
    if not BLENDER_AVAILABLE:
        return None

    try:
        light_data = bpy.data.lights.new(name=config.name, type='SPOT')

        # Spot-specific properties
        light_data.spot_size = math.radians(45)  # Angle in radians (0.017 to pi)
        light_data.spot_blend = 0.5              # Softness 0-1
        light_data.use_square = False            # Circular or square cone
        light_data.show_cone = True              # Show cone in viewport

        # Common properties
        light_data.energy = 500.0
        light_data.color = (1.0, 0.95, 0.9)  # Slightly warm
        light_data.shadow_soft_size = 0.05

        light_obj = bpy.data.objects.new(config.name, light_data)
        bpy.context.scene.collection.objects.link(light_obj)

        return light_obj
    except Exception:
        return None
```

### Setup Light Linking
```python
# Source: bpy.types.ObjectLightLinking docs
def configure_light_linking(
    light_obj,
    include_objects: List[Any],
    exclude_objects: Optional[List[Any]] = None
) -> bool:
    """
    Configure light to only illuminate specific objects.

    Blender 4.0+ feature.
    """
    if not BLENDER_AVAILABLE:
        return False

    # Version check
    if bpy.app.version < (4, 0, 0):
        print("Light linking requires Blender 4.0+")
        return False

    try:
        # Create receiver collection
        receiver_col = bpy.data.collections.new(f"{light_obj.name}_receivers")
        for obj in include_objects:
            if obj not in receiver_col.objects:
                receiver_col.objects.link(obj)

        light_obj.light_linking.receiver_collection = receiver_col

        # Optional blocker collection
        if exclude_objects:
            blocker_col = bpy.data.collections.new(f"{light_obj.name}_blockers")
            for obj in exclude_objects:
                if obj not in blocker_col.objects:
                    blocker_col.objects.link(obj)
            light_obj.light_linking.blocker_collection = blocker_col

        return True
    except Exception:
        return False
```

### Apply Gel/Color Filter
```python
# Source: Based on gel_presets.yaml structure
def apply_gel(light_obj, gel_preset: Dict[str, Any]) -> bool:
    """
    Apply gel/color filter to light.

    Gel presets define:
    - color: RGB tuple (0-1 range)
    - temperature: Kelvin (optional, alternative to color)
    - diffusion: softness factor (optional)
    """
    if not BLENDER_AVAILABLE:
        return False

    try:
        light_data = light_obj.data

        # Use temperature if specified (Blender 4.0+)
        if 'temperature' in gel_preset:
            light_data.use_temperature = True
            light_data.temperature = gel_preset['temperature']
        elif 'color' in gel_preset:
            light_data.color = tuple(gel_preset['color'])

        # Apply diffusion if specified
        if 'diffusion' in gel_preset:
            light_data.shadow_soft_size = gel_preset['diffusion']

        return True
    except Exception:
        return False
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual Kelvin-RGB conversion | `use_temperature` + `temperature` property | Blender 4.0 | Native color temperature support |
| Light groups (workaround) | ObjectLightLinking | Blender 4.0 | Selective illumination built-in |
| Fixed light shapes | Parametric shapes with spread | Blender 4.0+ | More control over light falloff |
| BI renderer light params | EEVEE Next / Cycles unified | Blender 4.0+ | Consistent lighting across engines |

**Deprecated/outdated:**
- **Light groups addon:** Replaced by native ObjectLightLinking in Blender 4.0+
- **BI renderer light properties:** Use Cycles/EEVEE properties instead

## Existing Preset Files

The following preset files already exist and should be used:

### Lighting Rigs (`configs/cinematic/lighting/rig_presets.yaml`)
- `three_point_soft` - Classic soft key/fill/back
- `three_point_hard` - Dramatic hard lighting
- `product_hero` - Product showcase lighting
- `product_dramatic` - Dramatic product lighting
- `studio_high_key` - Bright, even studio
- `studio_low_key` - Moody, contrast studio
- `console_overhead` - Overhead console lighting
- `mixer_angle` - Angled mixer lighting

### Gel Presets (`configs/cinematic/lighting/gel_presets.yaml`)
- CTB (Color Temperature Blue): full, half, quarter
- CTO (Color Temperature Orange): full, half, quarter
- Diffusion: light, medium, heavy
- Creative colors: red, blue, amber, magenta, green, cyan
- Combined: cto_diffusion, ctb_diffusion

### HDRI Presets (`configs/cinematic/lighting/hdri_presets.yaml`)
- Studio: studio_bright, studio_soft
- Environment: overcast_day, golden_hour, night_city
- Abstract: cyberpunk_neon
- Product: product_white, product_gray, product_black

## Open Questions

Things that couldn't be fully resolved:

1. **HDRI Auto-Download from Polyhaven**
   - What we know: Requirements mention auto-download from Polyhaven
   - What's unclear: API authentication, caching strategy, offline fallback
   - Recommendation: Implement as separate utility module with local cache and fallback to bundled HDRI

2. **EEVEE Next Specific Properties**
   - What we know: EEVEE Next is default engine in Blender 5.x
   - What's unclear: Any EEVEE-specific light properties vs Cycles
   - Recommendation: Use standard light properties that work across both engines; test on both

3. **Shadow Catcher Integration**
   - What we know: Requirements mention shadow catcher for backdrop
   - What's unclear: Interaction with light linking system
   - Recommendation: Test shadow catcher objects with light linking; may need special handling

## Sources

### Primary (HIGH confidence)
- https://docs.blender.org/api/current/bpy.types.Light.html - Base light properties
- https://docs.blender.org/api/current/bpy.types.AreaLight.html - Area light shape, size, spread
- https://docs.blender.org/api/current/bpy.types.SpotLight.html - Spot size, blend, cone
- https://docs.blender.org/api/current/bpy.types.ObjectLightLinking.html - Light linking API
- https://docs.blender.org/api/current/bpy.types.PointLight.html - Point light properties
- https://docs.blender.org/api/current/bpy.types.SunLight.html - Sun light properties

### Codebase References (HIGH confidence)
- `lib/cinematic/camera.py` - Guarded bpy import pattern
- `lib/cinematic/types.py` - Dataclass pattern with to_dict/from_dict
- `lib/cinematic/preset_loader.py` - YAML preset loading
- `lib/cinematic/rigs.py` - Rig implementation pattern
- `configs/cinematic/lighting/rig_presets.yaml` - Existing rig presets
- `configs/cinematic/lighting/gel_presets.yaml` - Existing gel presets
- `configs/cinematic/lighting/hdri_presets.yaml` - Existing HDRI presets

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Verified from official Blender API docs
- Architecture: HIGH - Based on existing codebase patterns
- Pitfalls: HIGH - Well-documented Blender quirks
- Code examples: HIGH - Directly from official API documentation
- HDRI system: MEDIUM - Standard node pattern but untested with EEVEE Next
- Light linking: HIGH - Blender 4.0+ docs are clear
- Gel system: MEDIUM - Industry standard values, needs validation

**Research date:** 2026-02-18
**Valid until:** 2026-06-18 (4 months - Blender API is stable but check for 4.x updates)
