---
phase: 06.2-lighting-system
plan: 02
type: execute
wave: 2
depends_on: ["06.2-01"]
files_modified:
  - lib/cinematic/lighting.py
autonomous: true
must_haves:
  truths:
    - "User can create area lights with shape, size, and spread"
    - "User can create spot lights with cone angle and edge softness"
    - "User can create point lights and sun lights"
    - "User can configure light linking for selective illumination"
    - "User can apply lighting rig presets"
    - "Light linking works on Blender 4.0+"
  artifacts:
    - path: "lib/cinematic/lighting.py"
      provides: "Light creation and management functions"
      exports: ["create_light", "create_area_light", "create_spot_light", "setup_light_linking", "apply_lighting_rig"]
      min_lines: 300
  key_links:
    - from: "lib/cinematic/lighting.py"
      to: "lib/cinematic/types.py"
      via: "LightConfig, Transform3D import"
      pattern: "from .types import LightConfig"
    - from: "lib/cinematic/lighting.py"
      to: "bpy.types.Light"
      via: "Blender API"
      pattern: "bpy.data.lights.new"
---

<objective>
Create the core lighting module with light creation functions.

Purpose: Implement the main lighting.py module that creates and manages all 4 light types (area, spot, point, sun), handles light linking for selective illumination (Blender 4.0+), and applies lighting rig presets.

Output: lib/cinematic/lighting.py with create_light, create_area_light, create_spot_light, setup_light_linking, and apply_lighting_rig functions.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.2-lighting-system/06.2-RESEARCH.md

# Reference patterns from camera system
@lib/cinematic/camera.py
@lib/cinematic/types.py
@lib/cinematic/preset_loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lighting module foundation</name>
  <files>lib/cinematic/lighting.py</files>
  <action>
Create lib/cinematic/lighting.py with the foundation structure:

1. Module docstring explaining the lighting system
2. Guarded bpy import (same pattern as camera.py):
   ```python
   try:
       import bpy
       BLENDER_AVAILABLE = True
   except ImportError:
       bpy = None
       BLENDER_AVAILABLE = False
   ```

3. Imports:
   ```python
   from __future__ import annotations
   from pathlib import Path
   from typing import Dict, Any, Optional, List, Tuple
   import math

   from .types import LightConfig, Transform3D, LightRigConfig
   from .preset_loader import get_lighting_rig_preset
   ```

4. Constants:
   ```python
   # Valid area light shapes (uppercase for Blender)
   AREA_SHAPES = ["SQUARE", "RECTANGLE", "DISK", "ELLIPSE"]

   # Blender 4.0+ version for light linking
   BLENDER_40_MIN = (4, 0, 0)
   ```

5. Helper function _validate_area_shape(shape: str) -> bool:
   - Check shape is in AREA_SHAPES
   - Return True if valid, raise ValueError if not
</action>
  <verify>python3 -c "from lib.cinematic.lighting import BLENDER_AVAILABLE, AREA_SHAPES; print(BLENDER_AVAILABLE, AREA_SHAPES)"</verify>
  <done>lighting.py created with guarded bpy import, constants, and helper function</done>
</task>

<task type="auto">
  <name>Task 2: Implement create_light function</name>
  <files>lib/cinematic/lighting.py</files>
  <action>
Add the main create_light function to lighting.py:

```python
def create_light(
    config: LightConfig,
    collection: Optional[Any] = None,
    link_to_scene: bool = True
) -> Optional[Any]:
    """
    Create a light object from LightConfig.

    Handles all four light types: area, spot, point, sun.

    Args:
        config: LightConfig with all settings
        collection: Optional collection to link to
        link_to_scene: If True and no collection, link to scene collection

    Returns:
        Created light object, or None if Blender not available
    """
```

Implementation:
1. Guard: if not BLENDER_AVAILABLE, return None
2. Try/except wrapper
3. Create light data based on config.light_type:
   - Use config.light_type.upper() for Blender type
   - Set common properties: color, energy, shadow_soft_size, use_shadow
4. Type-specific configuration:
   - Area: shape, size, size_y, spread
   - Spot: spot_size, spot_blend
5. Apply color temperature if use_temperature=True (Blender 4.0+):
   - Check bpy.app.version >= BLENDER_40_MIN
   - Set light.use_temperature and light.temperature
6. Create object and apply transform
7. Link to collection

Follow the pattern from camera.py create_camera() exactly.
</action>
  <verify>python3 -c "from lib.cinematic.lighting import create_light; from lib.cinematic.types import LightConfig; print(create_light.__doc__[:50])"</verify>
  <done>create_light function creates any light type from LightConfig</done>
</task>

<task type="auto">
  <name>Task 3: Implement specialized light creators</name>
  <files>lib/cinematic/lighting.py</files>
  <action>
Add convenience functions for specific light types:

1. create_area_light(name, position, size, shape, intensity, **kwargs):
   - Creates LightConfig with light_type="area"
   - Sets shape, size, spread from params
   - Calls create_light internally
   - Returns light object

2. create_spot_light(name, position, spot_size, spot_blend, intensity, **kwargs):
   - Creates LightConfig with light_type="spot"
   - Sets spot_size (convert degrees to radians: math.radians), spot_blend
   - Calls create_light internally
   - Returns light object

Each should have clear docstring with usage example.
</action>
  <verify>python3 -c "from lib.cinematic.lighting import create_area_light, create_spot_light; print(create_area_light.__doc__[:30] if create_area_light.__doc__ else 'no doc')" 2>&1 | head -1</verify>
  <done>create_area_light and create_spot_light convenience functions exist</done>
</task>

<task type="auto">
  <name>Task 4: Implement light linking</name>
  <files>lib/cinematic/lighting.py</files>
  <action>
Add light linking function for selective illumination (Blender 4.0+):

```python
def setup_light_linking(
    light_name: str,
    receiver_objects: List[str],
    blocker_objects: Optional[List[str]] = None
) -> bool:
    """
    Configure light to only illuminate specific objects.

    Blender 4.0+ feature for selective illumination.

    Args:
        light_name: Name of the light object
        receiver_objects: Object names that receive this light
        blocker_objects: Object names that block this light (optional)

    Returns:
        True if successful, False if failed or Blender < 4.0
    """
```

Implementation:
1. Guard: if not BLENDER_AVAILABLE, return False
2. Version check: if bpy.app.version < BLENDER_40_MIN, return False
3. Try/except wrapper
4. Get light object from bpy.data.objects
5. Create receiver collection, link objects
6. Set light_obj.light_linking.receiver_collection
7. If blocker_objects provided, create blocker collection and set

This enables use cases like "key light on subject only" or "rim light separation".
</action>
  <verify>python3 -c "from lib.cinematic.lighting import setup_light_linking; print(setup_light_linking.__doc__[:40] if setup_light_linking.__doc__ else 'no doc')" 2>&1 | head -1</verify>
  <done>setup_light_linking function exists and handles Blender 4.0+ version check</done>
</task>

<task type="auto">
  <name>Task 5: Implement lighting rig application</name>
  <files>lib/cinematic/lighting.py</files>
  <action>
Add function to apply complete lighting rig presets:

```python
def apply_lighting_rig(
    preset_name: str,
    target_position: Tuple[float, float, float] = (0, 0, 0),
    intensity_scale: float = 1.0,
    collection: Optional[Any] = None
) -> Dict[str, Any]:
    """
    Apply a lighting rig preset from YAML configuration.

    Loads preset from configs/cinematic/lighting/rig_presets.yaml and
    creates all lights defined in the rig.

    Args:
        preset_name: Name of the rig preset (e.g., "three_point_soft")
        target_position: Center point for angle_distance positioning
        intensity_scale: Multiplier for all light intensities
        collection: Collection to link lights to

    Returns:
        Dictionary with created light names and configuration
    """
```

Implementation:
1. Load preset using get_lighting_rig_preset(preset_name)
2. Handle extends field (preset inheritance)
3. For each light in preset:
   - Convert angle_distance positioning to world coordinates
   - Create LightConfig from preset data
   - Call create_light
   - Store created light name
4. Return dict with lights and config

Support all 8 presets: three_point_soft, three_point_hard, product_hero, product_dramatic, studio_high_key, studio_low_key, console_overhead, mixer_angle.
</action>
  <verify>python3 -c "from lib.cinematic.lighting import apply_lighting_rig; print(apply_lighting_rig.__doc__[:40] if apply_lighting_rig.__doc__ else 'no doc')" 2>&1 | head -1</verify>
  <done>apply_lighting_rig function loads and creates lights from preset YAML</done>
</task>

</tasks>

<verification>
1. Module imports: python3 -c "from lib.cinematic.lighting import create_light, create_area_light, create_spot_light, setup_light_linking, apply_lighting_rig"
2. BLENDER_AVAILABLE flag: python3 -c "from lib.cinematic.lighting import BLENDER_AVAILABLE; print(type(BLENDER_AVAILABLE))"
3. Area shapes constant: python3 -c "from lib.cinematic.lighting import AREA_SHAPES; print('RECTANGLE' in AREA_SHAPES)"
4. Function docstrings present
</verification>

<success_criteria>
- create_light function handles all 4 light types
- create_area_light convenience function exists
- create_spot_light convenience function exists
- setup_light_linking handles Blender 4.0+ version check
- apply_lighting_rig loads presets and creates lights
- All functions follow guarded bpy import pattern
- All functions return None/False gracefully outside Blender
</success_criteria>

<output>
After completion, create `.planning/phases/06.2-lighting-system/06.2-02-SUMMARY.md`
</output>
