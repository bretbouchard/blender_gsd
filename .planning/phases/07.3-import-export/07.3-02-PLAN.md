---
phase: 07.3-import-export
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - lib/cinematic/tracking/import_export.py
autonomous: true

must_haves:
  truths:
    - "C3D motion capture files import with marker position data"
    - "3DEqualizer export helper generates valid Python script"
    - "SynthEyes export helper generates valid Python script"
    - "TrackingExporter can export FBX camera data"
  artifacts:
    - path: "lib/cinematic/tracking/import_export.py"
      provides: "C3DParser, TDEExportHelper, SynthEyesExportHelper, FBX export"
      contains: "class C3DParser"
      contains: "class TDEExportHelper"
      contains: "class SynthEyesExportHelper"
  key_links:
    - from: "C3DParser"
      to: "struct module"
      via: "Binary parsing"
      pattern: "struct.unpack"
    - from: "TrackingExporter"
      to: "bpy.ops.export_scene.fbx"
      via: "FBX export"
      pattern: "export_scene.fbx"
---

<objective>
Add C3D motion capture import and vendor-specific export helpers (3DEqualizer, SynthEyes, FBX) to the tracking import/export module.

Purpose: Support professional motion capture marker data (C3D) and provide export integration scripts for industry-standard match-move software (3DEqualizer, SynthEyes) plus FBX export capability.

Output: C3DParser, TDEExportHelper, SynthEyesExportHelper classes and FBX export method added to import_export.py.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.3-import-export/07.3-RESEARCH.md
@lib/cinematic/tracking/import_export.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement C3DParser class</name>
  <files>lib/cinematic/tracking/import_export.py</files>
  <action>
Add C3DParser class to lib/cinematic/tracking/import_export.py for binary C3D motion capture marker data.

Implementation requirements:
1. Create `C3DParser` class with `parse()` static method
2. `parse(filepath: str) -> ImportedCamera`
3. Implement `_read_header()` static method:
   - Read first 256 bytes for header block
   - Extract marker_count, frame_count, first_frame, last_frame
   - Return Dict[str, Any] with header data
4. Implement `_read_parameters()` static method:
   - Read parameter section at header['param_start'] * 256
   - Extract scale factor and units (default 1.0, 'mm')
5. Implement `_read_points()` static method:
   - Read 3D point data starting at byte 768
   - Each marker: x, y, z (float), residual (float) = 16 bytes
   - Return List[List[Dict]] - frames of markers with x/y/z/residual
6. In `parse()`:
   - Use first marker position as camera position per frame
   - Apply scale factor from parameters
   - Set camera.frame_start and frame_end from header
7. Add ".c3d" extension to TrackingImporter.PARSERS dictionary

Use `struct` module for binary parsing (Intel byte order, little-endian).
</action>
  <verify>grep -q "class C3DParser" lib/cinematic/tracking/import_export.py && grep -q '".c3d": C3DParser' lib/cinematic/tracking/import_export.py</verify>
  <done>C3DParser class exists with binary parsing for marker data, registered in PARSERS dict</done>
</task>

<task type="auto">
  <name>Task 2: Implement TDEExportHelper class</name>
  <files>lib/cinematic/tracking/import_export.py</files>
  <action>
Add TDEExportHelper class for 3DEqualizer integration.

Implementation requirements:
1. Create `TDEExportHelper` class with `generate_blender_script()` static method
2. `generate_blender_script(camera: ImportedCamera, point_cloud: Optional[List[Tuple[float, float, float]]] = None) -> str`
3. Generate Python script that:
   - Creates camera object in Blender with name "3de_camera"
   - Sets location and rotation_euler keyframes for all frames in camera.positions
   - Converts rotation degrees to radians using math.radians()
   - Optionally creates point cloud mesh from point_cloud parameter
4. Script should be executable in Blender via text editor or command line
5. Include docstring explaining 3DEqualizer workflow

The generated script creates a camera with keyframe animation matching the ImportedCamera data.
</action>
  <verify>grep -q "class TDEExportHelper" lib/cinematic/tracking/import_export.py && grep -q "generate_blender_script" lib/cinematic/tracking/import_export.py</verify>
  <done>TDEExportHelper class generates valid Python script for 3DEqualizer-to-Blender camera transfer</done>
</task>

<task type="auto">
  <name>Task 3: Implement SynthEyesExportHelper class</name>
  <files>lib/cinematic/tracking/import_export.py</files>
  <action>
Add SynthEyesExportHelper class for SynthEyes integration.

Implementation requirements:
1. Create `SynthEyesExportHelper` class with `generate_blender_script()` static method
2. `generate_blender_script(camera: ImportedCamera, focal_length: float = 50.0) -> str`
3. Generate Python script that:
   - Creates camera with name "syntheyes_camera"
   - Sets location and rotation keyframes
   - Configures focal_length on camera.data.lens
   - Optionally adds lens distortion info as custom properties
4. Include helper method `get_recommended_export_settings()` returning Dict with:
   - FBX export settings for SynthEyes
   - Coordinate system recommendations
   - Frame rate matching guidance
5. Include docstring explaining SynthEyes workflow

Similar pattern to TDEExportHelper but with SynthEyes-specific naming and focal length support.
</action>
  <verify>grep -q "class SynthEyesExportHelper" lib/cinematic/tracking/import_export.py && grep -q "get_recommended_export_settings" lib/cinematic/tracking/import_export.py</verify>
  <done>SynthEyesExportHelper class generates Python script for SynthEyes-to-Blender camera transfer</done>
</task>

<task type="auto">
  <name>Task 4: Add FBX export to TrackingExporter</name>
  <files>lib/cinematic/tracking/import_export.py</files>
  <action>
Add export_fbx method to TrackingExporter class.

Implementation requirements:
1. Add `export_fbx()` method to TrackingExporter class
2. `export_fbx(solve: Solve, filepath: str, coordinate_system: str = "maya") -> bool`
3. If HAS_BLENDER:
   - Create temporary camera object from solve data
   - Animate camera with keyframes from solve.results
   - Call `bpy.ops.export_scene.fbx(filepath=filepath, use_selection=True)`
   - Delete temporary camera
   - Return True on success
4. If not HAS_BLENDER:
   - Return False (FBX export requires Blender)
5. Apply coordinate conversion using existing `_position_to_target()` and `_rotation_to_target()` methods

This enables round-trip workflow: import FBX -> solve -> export FBX.
</action>
  <verify>grep -q "def export_fbx" lib/cinematic/tracking/import_export.py</verify>
  <done>TrackingExporter has export_fbx method for FBX camera export</done>
</task>

</tasks>

<verification>
- C3DParser parses binary C3D files to ImportedCamera
- TDEExportHelper generates executable Python script
- SynthEyesExportHelper generates executable Python script
- TrackingExporter.export_fbx() creates FBX from solve data
- All classes follow existing patterns and docstring conventions
</verification>

<success_criteria>
- [x] C3DParser class added with binary parsing
- [x] TDEExportHelper class added with script generation
- [x] SynthEyesExportHelper class added with script generation
- [x] FBX export method added to TrackingExporter
- [x] All registered in appropriate dictionaries or callable
</success_criteria>

<output>
After completion, create `.planning/phases/07.3-import-export/07.3-02-SUMMARY.md`
</output>
