# Phase 18.3-01: Target Types & Base Classes

**Phase**: 18.3 - Target Presets
**Requirement**: REQ-PROJ-04
**Priority**: P1
**Est. Effort**: 1 day
**Depends on**: Phase 18.2 (Content Mapping Workflow)

## Goal

Create base classes and types for projection target presets.

## Tasks

### 1. Create Target Types (`lib/cinematic/projection/physical/targets/types.py`)

```python
from dataclasses import dataclass, field
from typing import List, Tuple, Optional, Dict
from enum import Enum
from mathutils import Vector

class TargetType(Enum):
    """Type of projection target."""
    PLANAR = "planar"              # Single flat surface
    MULTI_SURFACE = "multi_surface"  # Multiple connected surfaces
    CURVED = "curved"              # Curved surface (cylinder, dome)
    IRREGULAR = "irregular"        # Complex geometry

class SurfaceMaterial(Enum):
    """Surface material type for brightness/color compensation."""
    WHITE_PAINT = "white_paint"    # Standard white (albedo ~0.85)
    GRAY_PAINT = "gray_paint"      # Gray (albedo ~0.5)
    DARK_PAINT = "dark_paint"      # Dark (albedo ~0.2)
    PROJECTOR_SCREEN = "screen"    # Specialized screen (albedo ~0.95)
    FABRIC = "fabric"              # Fabric surface
    METAL = "metal"                # Metallic surface

@dataclass
class ProjectionSurface:
    """Single projection surface within a target."""
    name: str
    surface_type: TargetType

    # Geometry
    bounding_box: Tuple[Tuple[float, float, float], Tuple[float, float, float]]
    surface_normal: Vector = field(default_factory=lambda: Vector((0, 0, 1)))
    area_m2: float = 1.0

    # Material properties
    material: SurfaceMaterial = SurfaceMaterial.WHITE_PAINT
    albedo: float = 0.85
    glossiness: float = 0.1

    # Calibration
    calibration_points: List[Tuple[float, float, float]] = field(default_factory=list)
    is_calibrated: bool = False
    calibration_error_mm: float = 0.0

@dataclass
class ProjectionTarget:
    """Complete projection target configuration."""
    name: str
    description: str
    target_type: TargetType

    # Surfaces
    surfaces: List[ProjectionSurface] = field(default_factory=list)

    # Overall dimensions
    width_m: float = 1.0
    height_m: float = 1.0
    depth_m: float = 0.0  # 0 for planar

    # Recommended calibration type
    recommended_calibration: str = "three_point"

    # Preset measurements (for common targets)
    preset_measurements: Dict[str, float] = field(default_factory=dict)

    def get_total_area(self) -> float:
        """Get total projection area in square meters."""
        return sum(s.area_m2 for s in self.surfaces)

    def get_primary_surface(self) -> Optional[ProjectionSurface]:
        """Get the primary (largest) surface."""
        if not self.surfaces:
            return None
        return max(self.surfaces, key=lambda s: s.area_m2)

@dataclass
class TargetGeometryResult:
    """Result of target geometry generation."""
    object: bpy.types.Object
    surfaces: Dict[str, bpy.types.Object]  # surface_name -> object
    uv_layers: Dict[str, bpy.types.MeshUVLoop]
```

### 2. Create Base Target Class (`lib/cinematic/projection/physical/targets/base.py`)

```python
from abc import ABC, abstractmethod
from typing import Dict, Optional, List
import bpy
from mathutils import Vector

from .types import ProjectionTarget, TargetGeometryResult, ProjectionSurface

class TargetBuilder(ABC):
    """Abstract base class for projection target builders."""

    def __init__(self, config: ProjectionTarget):
        self.config = config

    @abstractmethod
    def create_geometry(self) -> TargetGeometryResult:
        """Create Blender geometry for this target."""
        pass

    @abstractmethod
    def get_calibration_points(self) -> List[Tuple[float, float, float]]:
        """Get default calibration points for this target."""
        pass

    @abstractmethod
    def get_recommended_projector_position(
        self,
        throw_ratio: float
    ) -> Tuple[Vector, Vector]:
        """
        Get recommended projector position and rotation.

        Args:
            throw_ratio: Projector throw ratio

        Returns:
            (position, rotation_euler) tuple
        """
        pass

    def apply_material(self, surface_obj: bpy.types.Object, surface: ProjectionSurface):
        """Apply material to surface based on surface properties."""
        # Create simple diffuse material matching surface properties
        mat = bpy.data.materials.new(name=f"{surface.name}_material")
        mat.use_nodes = True

        # Set diffuse color based on albedo
        bsdf = mat.node_tree.nodes['Principled BSDF']
        bsdf.inputs['Base Color'].default_value = (
            surface.albedo, surface.albedo, surface.albedo, 1.0
        )
        bsdf.inputs['Roughness'].default_value = 1.0 - surface.glossiness

        # Apply to object
        if surface_obj.data.materials:
            surface_obj.data.materials[0] = mat
        else:
            surface_obj.data.materials.append(mat)

    def validate_dimensions(self) -> List[str]:
        """Validate target dimensions are reasonable."""
        errors = []

        if self.config.width_m <= 0:
            errors.append(f"Invalid width: {self.config.width_m}")
        if self.config.height_m <= 0:
            errors.append(f"Invalid height: {self.config.height_m}")

        return errors


class PlanarTargetBuilder(TargetBuilder):
    """Builder for planar projection targets."""

    def create_geometry(self) -> TargetGeometryResult:
        """Create a simple planar mesh."""
        # Create mesh
        mesh = bpy.data.meshes.new(f"{self.config.name}_mesh")
        obj = bpy.data.objects.new(self.config.name, mesh)

        # Create vertices for rectangle
        w, h = self.config.width_m / 2, self.config.height_m / 2
        verts = [
            (-w, 0, -h),  # Bottom-left
            (w, 0, -h),   # Bottom-right
            (w, 0, h),    # Top-right
            (-w, 0, h),   # Top-left
        ]
        faces = [(0, 1, 2, 3)]

        mesh.from_pydata(verts, [], faces)

        # Create UV layer
        uv_layer = mesh.uv_layers.new(name="ProjectorUV")
        uv_data = uv_layer.data
        uv_data[0].uv = (0, 0)  # Bottom-left
        uv_data[1].uv = (1, 0)  # Bottom-right
        uv_data[2].uv = (1, 1)  # Top-right
        uv_data[3].uv = (0, 1)  # Top-left

        # Link to collection
        bpy.context.collection.objects.link(obj)

        # Apply material to primary surface
        if self.config.surfaces:
            self.apply_material(obj, self.config.surfaces[0])

        return TargetGeometryResult(
            object=obj,
            surfaces={"main": obj},
            uv_layers={"ProjectorUV": uv_layer}
        )

    def get_calibration_points(self) -> List[Tuple[float, float, float]]:
        """Get 3 calibration points for planar surface."""
        w, h = self.config.width_m / 2, self.config.height_m / 2
        return [
            (-w, 0, -h),  # Bottom-left
            (w, 0, -h),   # Bottom-right
            (-w, 0, h),   # Top-left
        ]

    def get_recommended_projector_position(
        self,
        throw_ratio: float
    ) -> Tuple[Vector, Vector]:
        """Calculate projector position for optimal coverage."""
        # Distance = throw_ratio * image_width
        distance = throw_ratio * self.config.width_m

        # Position: in front of center, at correct distance
        position = Vector((0, -distance, self.config.height_m / 2))

        # Rotation: pointing at center
        rotation = Vector((math.pi / 2, 0, 0))  # Point forward

        return position, rotation


class MultiSurfaceTargetBuilder(TargetBuilder):
    """Builder for multi-surface projection targets."""

    def create_geometry(self) -> TargetGeometryResult:
        """Create multiple connected surfaces."""
        surfaces_dict = {}

        # Create parent empty
        parent = bpy.data.objects.new(f"{self.config.name}_Group", None)
        parent.empty_display_type = 'PLAIN_AXES'
        bpy.context.collection.objects.link(parent)

        for surface in self.config.surfaces:
            # Create individual surface geometry
            surf_obj = self._create_surface_object(surface)
            surf_obj.parent = parent
            surfaces_dict[surface.name] = surf_obj

        return TargetGeometryResult(
            object=parent,
            surfaces=surfaces_dict,
            uv_layers={}  # UV layers on individual surfaces
        )

    def _create_surface_object(self, surface: ProjectionSurface) -> bpy.types.Object:
        """Create a single surface object."""
        # Implementation depends on surface type
        pass

    def get_calibration_points(self) -> List[Tuple[float, float, float]]:
        """Get 4+ calibration points for multi-surface."""
        # Collect points from all surfaces
        points = []
        for surface in self.config.surfaces:
            points.extend(surface.calibration_points)
        return points[:4]  # Return first 4 for DLT

    def get_recommended_projector_position(
        self,
        throw_ratio: float
    ) -> Tuple[Vector, Vector]:
        """Calculate position to cover all surfaces."""
        # Find bounding box of all surfaces
        # Position to cover entire area
        pass
```

### 3. Create Target YAML Configuration (`configs/cinematic/projection/targets/`)

**reading_room.yaml**:
```yaml
name: reading_room
description: "Reading room with cabinets and desks"
target_type: multi_surface

dimensions:
  width_m: 2.5
  height_m: 2.0
  depth_m: 0.6

surfaces:
  - name: upper_cabinet
    surface_type: planar
    position: [0, 0, 1.2]
    dimensions:
      width_m: 2.5
      height_m: 0.8
    material: white_paint
    albedo: 0.85

  - name: lower_cabinet
    surface_type: planar
    position: [0, 0, 0]
    dimensions:
      width_m: 2.5
      height_m: 0.6
    material: white_paint
    albedo: 0.85

  - name: desk_surface
    surface_type: planar
    position: [0, 0.4, 0.6]
    dimensions:
      width_m: 2.0
      height_m: 0.5
    material: wood
    albedo: 0.6

recommended_calibration: four_point_dlt

preset_measurements:
  cabinet_depth: 0.3
  desk_height: 0.75
```

**garage_door.yaml**:
```yaml
name: garage_door
description: "Standard garage door (7ft x 16ft)"
target_type: planar

dimensions:
  width_m: 4.88   # 16ft
  height_m: 2.13  # 7ft
  depth_m: 0

surfaces:
  - name: door_panel
    surface_type: planar
    position: [0, 0, 1.065]  # Centered vertically
    dimensions:
      width_m: 4.88
      height_m: 2.13
    material: white_paint
    albedo: 0.85

  - name: frame
    surface_type: planar
    position: [0, 0, 1.065]
    dimensions:
      width_m: 5.0
      height_m: 2.25
    material: white_paint
    albedo: 0.90

recommended_calibration: three_point

preset_measurements:
  frame_width: 0.05
  panel_gap: 0.02
  handle_height: 1.0
```

**building_facade.yaml**:
```yaml
name: building_facade
description: "Multi-story building facade for large-scale projection"
target_type: multi_surface

dimensions:
  width_m: 20.0
  height_m: 15.0
  depth_m: 0.5

surfaces:
  - name: main_facade
    surface_type: planar
    position: [0, 0, 7.5]
    dimensions:
      width_m: 20.0
      height_m: 15.0
    material: gray_paint
    albedo: 0.5

  - name: window_row_1
    surface_type: planar
    position: [0, 0.1, 10.0]
    dimensions:
      width_m: 18.0
      height_m: 2.0
    material: glass
    albedo: 0.3

recommended_calibration: four_point_dlt

preset_measurements:
  window_width: 1.5
  window_height: 2.0
  window_spacing: 2.5
  floor_height: 3.5
```

## Deliverables

```
lib/cinematic/projection/physical/targets/
├── __init__.py
├── types.py               # TargetType, ProjectionSurface, ProjectionTarget
└── base.py                # TargetBuilder, PlanarTargetBuilder, MultiSurfaceTargetBuilder

configs/cinematic/projection/targets/
├── reading_room.yaml
├── garage_door.yaml
└── building_facade.yaml
```

## Tests

- `test_target_types.py`: Type definition tests
- `test_base_builders.py`: Builder class tests
- YAML loading tests

## Acceptance Criteria

- [ ] ProjectionTarget, ProjectionSurface types defined
- [ ] TargetBuilder abstract class created
- [ ] PlanarTargetBuilder generates correct geometry
- [ ] YAML configuration files created for 3 targets
- [ ] 15+ unit tests passing
