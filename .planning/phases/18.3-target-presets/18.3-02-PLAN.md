# Phase 18.3-02: Target Geometry Import & Preview System

**Phase**: 18.3 - Target Presets
**Requirement**: REQ-PROJ-04
**Priority**: P1
**Est. Effort**: 1 day
**Depends on**: 18.3-01 (Target Types & Builders)

## Goal

Create target geometry import from real-world measurements and preview system for target visualization.

## Tasks

### 1. Create Measurement Import System (`lib/cinematic/projection/physical/targets/import.py`)

```python
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple
import bpy
from mathutils import Vector

@dataclass
class MeasurementInput:
    """Real-world measurement input for target creation."""
    name: str
    measurement_type: str  # 'point', 'distance', 'area', 'volume'

    # For points (3D position)
    position: Optional[Tuple[float, float, float]] = None

    # For distances
    start_point: Optional[Tuple[float, float, float]] = None
    end_point: Optional[Tuple[float, float, float]] = None
    distance_m: Optional[float] = None

    # For areas
    corners: Optional[List[Tuple[float, float, float]]] = None
    area_m2: Optional[float] = None

    # Metadata
    notes: str = ""

@dataclass
class MeasurementSet:
    """Collection of measurements defining a target."""
    target_name: str
    measurements: List[MeasurementInput]

    # Computed values
    computed_positions: Dict[str, Vector] = field(default_factory=dict)
    computed_dimensions: Dict[str, Tuple[float, float, float]] = field(default_factory=dict)


class TargetImporter:
    """Import target geometry from real-world measurements."""

    def __init__(self):
        self.measurements: List[MeasurementInput] = []

    def add_point_measurement(
        self,
        name: str,
        position: Tuple[float, float, float],
        notes: str = ""
    ) -> 'TargetImporter':
        """Add a 3D point measurement."""
        self.measurements.append(MeasurementInput(
            name=name,
            measurement_type='point',
            position=position,
            notes=notes
        ))
        return self

    def add_distance_measurement(
        self,
        name: str,
        start: Tuple[float, float, float],
        end: Tuple[float, float, float],
        notes: str = ""
    ) -> 'TargetImporter':
        """Add a distance measurement."""
        self.measurements.append(MeasurementInput(
            name=name,
            measurement_type='distance',
            start_point=start,
            end_point=end,
            notes=notes
        ))
        return self

    def add_area_measurement(
        self,
        name: str,
        corners: List[Tuple[float, float, float]],
        notes: str = ""
    ) -> 'TargetImporter':
        """Add an area measurement from corner points."""
        self.measurements.append(MeasurementInput(
            name=name,
            measurement_type='area',
            corners=corners,
            notes=notes
        ))
        return self

    def compute_target(self) -> ProjectionTarget:
        """Compute ProjectionTarget from measurements."""
        # Process measurements
        points = {}
        dimensions = {}

        for m in self.measurements:
            if m.measurement_type == 'point':
                points[m.name] = Vector(m.position)

            elif m.measurement_type == 'distance':
                start = Vector(m.start_point)
                end = Vector(m.end_point)
                dimensions[m.name] = (end - start).length

            elif m.measurement_type == 'area':
                # Compute bounding box from corners
                corners = [Vector(c) for c in m.corners]
                min_corner = Vector((
                    min(c.x for c in corners),
                    min(c.y for c in corners),
                    min(c.z for c in corners)
                ))
                max_corner = Vector((
                    max(c.x for c in corners),
                    max(c.y for c in corners),
                    max(c.z for c in corners)
                ))
                dimensions[m.name] = (max_corner - min_corner).to_tuple()

        # Build target from computed values
        # ...

    def import_from_yaml(self, yaml_path: str) -> ProjectionTarget:
        """Import target from YAML measurements file."""
        import yaml

        with open(yaml_path) as f:
            data = yaml.safe_load(f)

        target_name = data.get('target_name', 'imported_target')

        for measurement in data.get('measurements', []):
            m_type = measurement.get('type')

            if m_type == 'point':
                self.add_point_measurement(
                    name=measurement['name'],
                    position=tuple(measurement['position']),
                    notes=measurement.get('notes', '')
                )
            elif m_type == 'distance':
                self.add_distance_measurement(
                    name=measurement['name'],
                    start=tuple(measurement['start']),
                    end=tuple(measurement['end']),
                    notes=measurement.get('notes', '')
                )
            elif m_type == 'area':
                self.add_area_measurement(
                    name=measurement['name'],
                    corners=[tuple(c) for c in measurement['corners']],
                    notes=measurement.get('notes', '')
                )

        return self.compute_target()
```

### 2. Create Target Preview System (`lib/cinematic/projection/physical/targets/preview.py`)

```python
from dataclasses import dataclass
from typing import Optional, List
import bpy
from mathutils import Vector, Color

@dataclass
class PreviewConfig:
    """Configuration for target preview visualization."""
    show_wireframe: bool = True
    show_surface_normal: bool = True
    show_calibration_points: bool = True
    show_bounding_box: bool = True
    show_frustum: bool = True

    # Colors
    wireframe_color: Color = field(default_factory=lambda: Color((1, 1, 0)))  # Yellow
    normal_color: Color = field(default_factory=lambda: Color((0, 1, 0)))      # Green
    point_color: Color = field(default_factory=lambda: Color((1, 0, 0)))       # Red
    bbox_color: Color = field(default_factory=lambda: Color((0, 0, 1)))        # Blue
    frustum_color: Color = field(default_factory=lambda: Color((1, 1, 1, 0.3)))  # White, transparent

    # Sizes
    point_size: float = 0.05
    normal_length: float = 0.5
    line_width: float = 2.0


class TargetPreview:
    """Create preview visualization for projection targets."""

    def __init__(self, config: PreviewConfig = PreviewConfig()):
        self.config = config
        self.preview_objects: List[bpy.types.Object] = []

    def create_preview(
        self,
        target: ProjectionTarget,
        projector: Optional[bpy.types.Object] = None
    ) -> List[bpy.types.Object]:
        """
        Create preview visualization for target.

        Returns list of preview objects created.
        """
        self.clear_preview()

        # Create wireframe overlay
        if self.config.show_wireframe:
            self.preview_objects.extend(self._create_wireframe(target))

        # Create surface normal indicators
        if self.config.show_surface_normal:
            self.preview_objects.extend(self._create_normal_indicators(target))

        # Create calibration point markers
        if self.config.show_calibration_points:
            self.preview_objects.extend(self._create_point_markers(target))

        # Create bounding box
        if self.config.show_bounding_box:
            self.preview_objects.extend(self._create_bounding_box(target))

        # Create projector frustum
        if self.config.show_frustum and projector:
            self.preview_objects.extend(self._create_frustum(projector, target))

        return self.preview_objects

    def _create_wireframe(self, target: ProjectionTarget) -> List[bpy.types.Object]:
        """Create wireframe overlay for target surfaces."""
        objects = []

        for surface in target.surfaces:
            # Create wireframe mesh
            # ...

        return objects

    def _create_normal_indicators(self, target: ProjectionTarget) -> List[bpy.types.Object]:
        """Create arrows showing surface normals."""
        objects = []

        for surface in target.surfaces:
            # Create arrow object at surface center
            # Pointing in surface normal direction
            # ...

        return objects

    def _create_point_markers(self, target: ProjectionTarget) -> List[bpy.types.Object]:
        """Create sphere markers for calibration points."""
        objects = []

        for surface in target.surfaces:
            for point in surface.calibration_points:
                # Create sphere at point location
                bpy.ops.mesh.primitive_uv_sphere_add(
                    radius=self.config.point_size,
                    location=point
                )
                sphere = bpy.context.active_object
                sphere.name = f"CalPoint_{surface.name}"

                # Set material color
                mat = bpy.data.materials.new(name=f"PointMarker_{surface.name}")
                mat.diffuse_color = (*self.config.point_color, 1.0)
                sphere.data.materials.append(mat)

                objects.append(sphere)

        return objects

    def _create_bounding_box(self, target: ProjectionTarget) -> List[bpy.types.Object]:
        """Create bounding box visualization."""
        # Create cube at bounding box dimensions
        # ...

    def _create_frustum(
        self,
        projector: bpy.types.Object,
        target: ProjectionTarget
    ) -> List[bpy.types.Object]:
        """Create projector frustum visualization."""
        # Create cone/pyramid showing projector FOV
        # ...

    def clear_preview(self):
        """Remove all preview objects."""
        for obj in self.preview_objects:
            bpy.data.objects.remove(obj, do_unlink=True)
        self.preview_objects.clear()

    def toggle_visibility(self, visible: bool):
        """Toggle visibility of preview objects."""
        for obj in self.preview_objects:
            obj.hide_viewport = not visible
            obj.hide_render = not visible


def preview_target(
    target: ProjectionTarget,
    projector: Optional[bpy.types.Object] = None,
    config: Optional[PreviewConfig] = None
) -> TargetPreview:
    """
    Convenience function to create target preview.

    Example:
        >>> preview = preview_target(
        ...     target=my_reading_room,
        ...     projector=projector_camera,
        ...     config=PreviewConfig(show_frustum=True)
        ... )
        >>> # Preview objects now visible in viewport
        >>> preview.toggle_visibility(False)  # Hide
        >>> preview.clear_preview()  # Remove
    """
    preview = TargetPreview(config or PreviewConfig())
    preview.create_preview(target, projector)
    return preview
```

### 3. Create Target Package Exports (`lib/cinematic/projection/physical/targets/__init__.py`)

```python
"""
Projection target presets and geometry import.

Provides target configurations for common projection scenarios
and utilities for importing real-world measurements.
"""

from .types import (
    TargetType,
    SurfaceMaterial,
    ProjectionSurface,
    ProjectionTarget,
    TargetGeometryResult,
)

from .base import (
    TargetBuilder,
    PlanarTargetBuilder,
    MultiSurfaceTargetBuilder,
    build_target_from_config,
)

from .import import (
    MeasurementInput,
    MeasurementSet,
    TargetImporter,
)

from .preview import (
    PreviewConfig,
    TargetPreview,
    preview_target,
)

from .presets import (
    load_target_preset,
    list_target_presets,
    create_reading_room_target,
    create_garage_door_target,
    create_building_facade_target,
)

__all__ = [
    # Types
    'TargetType',
    'SurfaceMaterial',
    'ProjectionSurface',
    'ProjectionTarget',
    'TargetGeometryResult',

    # Builders
    'TargetBuilder',
    'PlanarTargetBuilder',
    'MultiSurfaceTargetBuilder',
    'build_target_from_config',

    # Import
    'MeasurementInput',
    'MeasurementSet',
    'TargetImporter',

    # Preview
    'PreviewConfig',
    'TargetPreview',
    'preview_target',

    # Presets
    'load_target_preset',
    'list_target_presets',
    'create_reading_room_target',
    'create_garage_door_target',
    'create_building_facade_target',
]
```

## Deliverables

```
lib/cinematic/projection/physical/targets/
├── __init__.py
├── types.py
├── base.py
├── import.py        # Measurement import system
├── preview.py       # Target preview visualization
└── presets.py       # Preset loading utilities

configs/cinematic/projection/targets/
├── reading_room.yaml
├── garage_door.yaml
└── building_facade.yaml
```

## Tests

- `test_target_import.py`: Measurement import tests
- `test_target_preview.py`: Preview visualization tests
- `test_target_presets.py`: Preset loading tests

## Acceptance Criteria

- [ ] TargetImporter creates targets from measurements
- [ ] YAML measurement import works
- [ ] TargetPreview creates visualization objects
- [ ] Preview shows wireframe, normals, calibration points
- [ ] 3 target presets load correctly
- [ ] 20+ unit tests passing for Phase 18.3
