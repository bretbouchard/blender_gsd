# Phase 13.0: Rigging Foundation

**Goal**: Create and manage skeletal hierarchies for any animatable entity.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-01)

**Duration**: 5-7 days

---

## Overview

Build a rigging system that supports:
- Human bipeds (standard characters)
- Face rigs (expressions, lip sync)
- Quadrupeds (animals)
- Vehicles (mechanical articulation)
- Robots (custom mechanical/organic)
- Props (simple animated objects)

**Philosophy**: Rigs are data. Generate rigs from templates, not manual construction.

---

## Architecture

```
lib/animation/
├── __init__.py
├── types.py              # RigConfig, BoneConfig, WeightConfig
├── rig_builder.py        # Build rigs from config
├── bone_utils.py         # Bone operations
├── weight_painter.py     # Auto weight painting
├── presets/
│   ├── human_biped.py    # Standard human rig
│   ├── face_standard.py  # Face rig template
│   ├── quadruped.py      # 4-legged animal
│   ├── vehicle_basic.py  # Simple vehicle rig
│   └── robot_modular.py  # Robot rig builder

configs/animation/
├── rigs/
│   ├── human_biped.yaml
│   ├── face_standard.yaml
│   ├── quadruped.yaml
│   ├── vehicle_basic.yaml
│   └── robot_modular.yaml
└── bone_naming.yaml      # Naming conventions

.gsd-state/
└── rigs/
    └── {rig_id}/         # Generated rigs
        ├── config.yaml
        └── preview.png
```

---

## Data Model

### Rig Configuration
```yaml
# configs/animation/rigs/human_biped.yaml
id: human_biped
name: "Standard Human Biped"
version: "1.0"
description: "Basic human skeleton for character animation"

bones:
  # Root
  - id: root
    parent: null
    head: [0, 0, 0]
    tail: [0, 0, 0.2]
    layers: [1]

  # Spine chain
  - id: spine
    parent: root
    head: [0, 0, 0.2]
    tail: [0, 0, 0.4]
  - id: spine_01
    parent: spine
    head: [0, 0, 0.4]
    tail: [0, 0, 0.6]
  - id: spine_02
    parent: spine_01
    head: [0, 0, 0.6]
    tail: [0, 0, 0.8]
  - id: spine_03
    parent: spine_02
    head: [0, 0, 0.8]
    tail: [0, 0, 1.0]

  # Head
  - id: neck
    parent: spine_03
    head: [0, 0, 1.0]
    tail: [0, -0.05, 1.1]
  - id: head
    parent: neck
    head: [0, -0.05, 1.1]
    tail: [0, -0.1, 1.3]

  # Left arm
  - id: shoulder_L
    parent: spine_03
    head: [0, 0, 1.0]
    tail: [0.15, 0, 1.0]
    mirror: shoulder_R
  - id: upper_arm_L
    parent: shoulder_L
    head: [0.15, 0, 1.0]
    tail: [0.45, 0, 1.0]
    mirror: upper_arm_R
  - id: lower_arm_L
    parent: upper_arm_L
    head: [0.45, 0, 1.0]
    tail: [0.75, 0, 1.0]
    mirror: lower_arm_R
  - id: hand_L
    parent: lower_arm_L
    head: [0.75, 0, 1.0]
    tail: [0.85, 0, 1.0]
    mirror: hand_R

  # Left leg
  - id: pelvis
    parent: root
    head: [0, 0, 0.2]
    tail: [0, 0, 0.2]
  - id: thigh_L
    parent: pelvis
    head: [0.1, 0, 0.2]
    tail: [0.1, 0, -0.25]
    mirror: thigh_R
  - id: shin_L
    parent: thigh_L
    head: [0.1, 0, -0.25]
    tail: [0.1, 0, -0.7]
    mirror: shin_R
  - id: foot_L
    parent: shin_L
    head: [0.1, 0, -0.7]
    tail: [0.15, 0.2, -0.7]
    mirror: foot_R
  - id: toe_L
    parent: foot_L
    head: [0.15, 0.2, -0.7]
    tail: [0.15, 0.35, -0.7]
    mirror: toe_R

# Constraints
constraints:
  - bone: spine_01
    type: copy_rotation
    target: spine
    influence: 0.5

# Bone groups for organization
groups:
  - name: spine
    bones: [spine, spine_01, spine_02, spine_03]
  - name: left_arm
    bones: [shoulder_L, upper_arm_L, lower_arm_L, hand_L]
  - name: right_arm
    bones: [shoulder_R, upper_arm_R, lower_arm_R, hand_R]
  - name: left_leg
    bones: [thigh_L, shin_L, foot_L, toe_L]
  - name: right_leg
    bones: [thigh_R, shin_R, foot_R, toe_R]

# IK chains (references for Phase 13.1)
ik_chains:
  - name: left_arm_ik
    chain: [upper_arm_L, lower_arm_L, hand_L]
  - name: right_arm_ik
    chain: [upper_arm_R, lower_arm_R, hand_R]
  - name: left_leg_ik
    chain: [thigh_L, shin_L, foot_L]
  - name: right_leg_ik
    chain: [thigh_R, shin_R, foot_R]
```

### Types
```python
# lib/animation/types.py

@dataclass
class BoneConfig:
    id: str
    parent: Optional[str]
    head: Tuple[float, float, float]
    tail: Tuple[float, float, float]
    roll: float = 0.0
    layers: List[int] = field(default_factory=lambda: [0])
    mirror: Optional[str] = None
    constraints: List[Dict] = field(default_factory=list)
    use_connect: bool = False
    use_inherit_rotation: bool = True
    use_local_location: bool = True

@dataclass
class RigConfig:
    id: str
    name: str
    version: str
    description: str = ""
    bones: List[BoneConfig] = field(default_factory=list)
    constraints: List[Dict] = field(default_factory=list)
    groups: List[Dict] = field(default_factory=list)
    ik_chains: List[Dict] = field(default_factory=list)

@dataclass
class RigInstance:
    id: str
    config_id: str
    armature: bpy.types.Object
    bones: Dict[str, bpy.types.Bone]
    created_at: str
    source_mesh: Optional[str] = None
```

---

## Tasks

### Task 1: Type Definitions
**File**: `lib/animation/types.py`

```python
from dataclasses import dataclass, field
from typing import Optional, List, Tuple, Dict, Any
from enum import Enum

class RigType(Enum):
    HUMAN_BIPED = "human_biped"
    FACE_STANDARD = "face_standard"
    QUADRUPED = "quadruped"
    VEHICLE_BASIC = "vehicle_basic"
    ROBOT_MODULAR = "robot_modular"
    PROP_SIMPLE = "prop_simple"
    CUSTOM = "custom"

class BoneGroup(Enum):
    SPINE = "spine"
    HEAD = "head"
    LEFT_ARM = "left_arm"
    RIGHT_ARM = "right_arm"
    LEFT_LEG = "left_leg"
    RIGHT_LEG = "right_leg"
    LEFT_HAND = "left_hand"
    RIGHT_HAND = "right_hand"
    FACE = "face"
    TAIL = "tail"
    WINGS = "wings"
    CUSTOM = "custom"

@dataclass
class BoneConfig:
    id: str
    parent: Optional[str]
    head: Tuple[float, float, float]
    tail: Tuple[float, float, float]
    roll: float = 0.0
    layers: List[int] = field(default_factory=lambda: [0])
    mirror: Optional[str] = None
    use_connect: bool = False
    use_inherit_rotation: bool = True
    use_local_location: bool = True
    use_deform: bool = True

@dataclass
class BoneConstraint:
    bone: str
    type: str  # COPY_ROTATION, IK, TRACK_TO, etc.
    target: Optional[str] = None
    subtarget: Optional[str] = None
    influence: float = 1.0
    properties: Dict[str, Any] = field(default_factory=dict)

@dataclass
class BoneGroup:
    name: str
    bones: List[str]
    color: str = "DEFAULT"

@dataclass
class IKChain:
    name: str
    chain: List[str]
    target: Optional[str] = None
    pole_target: Optional[str] = None
    pole_angle: float = 0.0
    iterations: int = 500
    chain_count: int = 2
    use_tail: bool = False

@dataclass
class RigConfig:
    id: str
    name: str
    version: str = "1.0"
    rig_type: RigType = RigType.CUSTOM
    description: str = ""
    bones: List[BoneConfig] = field(default_factory=list)
    constraints: List[BoneConstraint] = field(default_factory=list)
    groups: List[BoneGroup] = field(default_factory=list)
    ik_chains: List[IKChain] = field(default_factory=list)
    custom_properties: Dict[str, Any] = field(default_factory=dict)

@dataclass
class WeightConfig:
    bone: str
    vertex_group: str
    auto_calculate: bool = True
    weight_threshold: float = 0.01

@dataclass
class RigInstance:
    id: str
    config_id: str
    armature_name: str
    mesh_names: List[str] = field(default_factory=list)
    created_at: str = ""
    scale: float = 1.0
    metadata: Dict[str, Any] = field(default_factory=dict)
```

**Acceptance**: Types compile, all fields documented

---

### Task 2: Rig Builder
**File**: `lib/animation/rig_builder.py`

```python
import bpy
from typing import Optional, List, Dict
from .types import RigConfig, BoneConfig, RigInstance
import uuid
from datetime import datetime

class RigBuilder:
    """Build Blender armatures from RigConfig."""

    def __init__(self, config: RigConfig):
        self.config = config
        self.armature: Optional[bpy.types.Object] = None
        self.bones: Dict[str, bpy.types.Bone] = {}

    def build(self, name: Optional[str] = None) -> bpy.types.Object:
        """Build the armature from config."""
        armature_name = name or f"rig_{self.config.id}"

        # Create armature
        armature_data = bpy.data.armatures.new(armature_name)
        self.armature = bpy.data.objects.new(armature_name, armature_data)

        # Link to scene
        bpy.context.collection.objects.link(self.armature)
        bpy.context.view_layer.objects.active = self.armature

        # Enter edit mode to add bones
        bpy.ops.object.mode_set(mode='EDIT')

        try:
            # Build bones
            for bone_config in self.config.bones:
                self._add_bone(bone_config)

            # Apply constraints (in pose mode)
            bpy.ops.object.mode_set(mode='POSE')
            for constraint in self.config.constraints:
                self._add_constraint(constraint)

            # Create bone groups
            for group in self.config.groups:
                self._create_bone_group(group)

        finally:
            bpy.ops.object.mode_set(mode='OBJECT')

        return self.armature

    def _add_bone(self, config: BoneConfig) -> bpy.types.EditBone:
        """Add a single bone to the armature."""
        bone = self.armature.data.edit_bones.new(config.id)

        # Set head and tail
        bone.head = config.head
        bone.tail = config.tail
        bone.roll = config.roll

        # Set parent
        if config.parent and config.parent in self.bones:
            bone.parent = self.bones[config.parent]
            if config.use_connect:
                bone.use_connect = True

        # Set layers
        bone.layers = [i in config.layers for i in range(32)]

        # Store reference
        self.bones[config.id] = bone

        return bone

    def _add_constraint(self, constraint) -> None:
        """Add constraint to a bone."""
        if constraint.bone not in self.armature.pose.bones:
            return

        pose_bone = self.armature.pose.bones[constraint.bone]
        con = pose_bone.constraints.new(constraint.type)

        if constraint.target:
            con.target = self.armature
        if constraint.subtarget:
            con.subtarget = constraint.subtarget
        con.influence = constraint.influence

    def _create_bone_group(self, group) -> None:
        """Create a bone group for organization."""
        bg = self.armature.pose.bone_groups.new(name=group.name)

        for bone_name in group.bones:
            if bone_name in self.armature.pose.bones:
                self.armature.pose.bones[bone_name].bone_group = bg

    def create_mirror_bones(self) -> None:
        """Create mirrored bones for _L/_R naming convention."""
        bpy.ops.object.mode_set(mode='EDIT')

        for bone_config in self.config.bones:
            if bone_config.mirror:
                # Find the original bone
                original = self.bones.get(bone_config.id)
                if original:
                    # Create mirrored copy
                    mirror_name = bone_config.mirror
                    mirror_bone = self.armature.data.edit_bones.new(mirror_name)

                    # Mirror the head and tail positions (X axis)
                    mirror_bone.head = (-original.head[0], original.head[1], original.head[2])
                    mirror_bone.tail = (-original.tail[0], original.tail[1], original.tail[2])
                    mirror_bone.roll = -original.roll

                    # Mirror parent relationship
                    if original.parent:
                        parent_name = original.parent.name
                        if parent_name.endswith('_L'):
                            mirror_parent = parent_name.replace('_L', '_R')
                        elif parent_name.endswith('_R'):
                            mirror_parent = parent_name.replace('_R', '_L')
                        else:
                            mirror_parent = parent_name

                        if mirror_parent in self.bones:
                            mirror_bone.parent = self.bones[mirror_parent]

                    self.bones[mirror_name] = mirror_bone


def build_rig_from_config(config: RigConfig, name: Optional[str] = None) -> bpy.types.Object:
    """Convenience function to build a rig from config."""
    builder = RigBuilder(config)
    return builder.build(name)


def build_rig_from_preset(preset_id: str, name: Optional[str] = None) -> bpy.types.Object:
    """Build a rig from a preset configuration."""
    from .preset_loader import load_rig_preset
    config = load_rig_preset(preset_id)
    return build_rig_from_config(config, name)
```

**Acceptance**: Can build armature from YAML config

---

### Task 3: Preset Loader
**File**: `lib/animation/preset_loader.py`

```python
import yaml
from pathlib import Path
from typing import Dict, Optional
from .types import RigConfig, BoneConfig, BoneConstraint, BoneGroup, IKChain, RigType

RIG_CONFIG_ROOT = Path(__file__).parent.parent.parent / "configs" / "animation" / "rigs"

_rig_cache: Dict[str, RigConfig] = {}

def load_rig_preset(preset_id: str, use_cache: bool = True) -> RigConfig:
    """Load a rig preset from YAML file."""
    if use_cache and preset_id in _rig_cache:
        return _rig_cache[preset_id]

    preset_path = RIG_CONFIG_ROOT / f"{preset_id}.yaml"

    if not preset_path.exists():
        raise FileNotFoundError(f"Rig preset not found: {preset_id}")

    with open(preset_path, 'r') as f:
        data = yaml.safe_load(f)

    config = _parse_rig_config(data)

    if use_cache:
        _rig_cache[preset_id] = config

    return config

def _parse_rig_config(data: dict) -> RigConfig:
    """Parse YAML data into RigConfig."""
    bones = [_parse_bone(b) for b in data.get('bones', [])]
    constraints = [_parse_constraint(c) for c in data.get('constraints', [])]
    groups = [_parse_group(g) for g in data.get('groups', [])]
    ik_chains = [_parse_ik_chain(c) for c in data.get('ik_chains', [])]

    return RigConfig(
        id=data['id'],
        name=data['name'],
        version=data.get('version', '1.0'),
        rig_type=RigType(data.get('rig_type', 'custom')),
        description=data.get('description', ''),
        bones=bones,
        constraints=constraints,
        groups=groups,
        ik_chains=ik_chains,
        custom_properties=data.get('custom_properties', {})
    )

def _parse_bone(data: dict) -> BoneConfig:
    """Parse bone configuration."""
    return BoneConfig(
        id=data['id'],
        parent=data.get('parent'),
        head=tuple(data['head']),
        tail=tuple(data['tail']),
        roll=data.get('roll', 0.0),
        layers=data.get('layers', [0]),
        mirror=data.get('mirror'),
        use_connect=data.get('use_connect', False),
        use_inherit_rotation=data.get('use_inherit_rotation', True),
        use_local_location=data.get('use_local_location', True),
        use_deform=data.get('use_deform', True)
    )

def _parse_constraint(data: dict) -> BoneConstraint:
    """Parse constraint configuration."""
    return BoneConstraint(
        bone=data['bone'],
        type=data['type'],
        target=data.get('target'),
        subtarget=data.get('subtarget'),
        influence=data.get('influence', 1.0),
        properties=data.get('properties', {})
    )

def _parse_group(data: dict) -> BoneGroup:
    """Parse bone group configuration."""
    return BoneGroup(
        name=data['name'],
        bones=data['bones'],
        color=data.get('color', 'DEFAULT')
    )

def _parse_ik_chain(data: dict) -> IKChain:
    """Parse IK chain configuration."""
    return IKChain(
        name=data['name'],
        chain=data['chain'],
        target=data.get('target'),
        pole_target=data.get('pole_target'),
        pole_angle=data.get('pole_angle', 0.0),
        iterations=data.get('iterations', 500),
        chain_count=data.get('chain_count', 2)
    )

def list_available_presets() -> list:
    """List all available rig presets."""
    if not RIG_CONFIG_ROOT.exists():
        return []

    return [f.stem for f in RIG_CONFIG_ROOT.glob("*.yaml")]

def save_rig_config(config: RigConfig, path: Optional[Path] = None) -> Path:
    """Save a rig configuration to YAML."""
    save_path = path or (RIG_CONFIG_ROOT / f"{config.id}.yaml")

    data = {
        'id': config.id,
        'name': config.name,
        'version': config.version,
        'rig_type': config.rig_type.value,
        'description': config.description,
        'bones': [
            {
                'id': b.id,
                'parent': b.parent,
                'head': list(b.head),
                'tail': list(b.tail),
                'roll': b.roll,
                'layers': b.layers,
                'mirror': b.mirror,
                'use_connect': b.use_connect
            }
            for b in config.bones
        ],
        'groups': [
            {'name': g.name, 'bones': g.bones, 'color': g.color}
            for g in config.groups
        ],
        'ik_chains': [
            {
                'name': c.name,
                'chain': c.chain,
                'target': c.target,
                'pole_target': c.pole_target
            }
            for c in config.ik_chains
        ]
    }

    with open(save_path, 'w') as f:
        yaml.dump(data, f, default_flow_style=False)

    return save_path
```

**Acceptance**: Can load rig presets from YAML

---

### Task 4: Bone Utilities
**File**: `lib/animation/bone_utils.py`

```python
import bpy
from typing import List, Optional, Tuple
from mathutils import Vector, Matrix

def get_bone_chain(armature: bpy.types.Object, start_bone: str, end_bone: str) -> List[str]:
    """Get all bones in a chain from start to end."""
    chain = []
    current = armature.data.bones.get(end_bone)

    while current:
        chain.insert(0, current.name)
        if current.name == start_bone:
            return chain
        current = current.parent

    return chain

def mirror_bone_name(name: str) -> str:
    """Mirror a bone name (L <-> R)."""
    if name.endswith('_L'):
        return name[:-2] + '_R'
    elif name.endswith('_R'):
        return name[:-2] + '_L'
    elif '.L' in name:
        return name.replace('.L', '.R')
    elif '.R' in name:
        return name.replace('.R', '.L')
    return name

def get_bone_length(bone: bpy.types.Bone) -> float:
    """Get the length of a bone."""
    return (Vector(bone.tail) - Vector(bone.head)).length

def get_bone_direction(bone: bpy.types.Bone) -> Vector:
    """Get the normalized direction vector of a bone."""
    direction = Vector(bone.tail) - Vector(bone.head)
    direction.normalize()
    return direction

def align_bone_to_vector(bone: bpy.types.EditBone, vector: Vector, roll: float = 0.0) -> None:
    """Align a bone to a direction vector."""
    current_dir = Vector(bone.tail) - Vector(bone.head)
    current_dir.normalize()

    rotation = current_dir.rotation_difference(vector)
    bone.transform(rotation.to_matrix().to_4x4())

def scale_bone(bone: bpy.types.EditBone, scale: float) -> None:
    """Scale a bone from its head."""
    direction = Vector(bone.tail) - Vector(bone.head)
    bone.tail = Vector(bone.head) + direction * scale

def duplicate_bone_chain(armature: bpy.types.Object, chain: List[str], suffix: str = "_copy") -> List[str]:
    """Duplicate a chain of bones with a suffix."""
    bpy.ops.object.mode_set(mode='EDIT')

    new_names = []
    for bone_name in chain:
        if bone_name in armature.data.edit_bones:
            original = armature.data.edit_bones[bone_name]
            new_bone = armature.data.edit_bones.new(f"{bone_name}{suffix}")
            new_bone.head = original.head
            new_bone.tail = original.tail
            new_bone.roll = original.roll
            new_names.append(new_bone.name)

    return new_names

def connect_bone_chain(armature: bpy.types.Object, chain: List[str]) -> None:
    """Connect bones in a chain (child head = parent tail)."""
    bpy.ops.object.mode_set(mode='EDIT')

    for i, bone_name in enumerate(chain[1:], 1):
        if bone_name in armature.data.edit_bones:
            bone = armature.data.edit_bones[bone_name]
            parent_name = chain[i - 1]
            if parent_name in armature.data.edit_bones:
                parent = armature.data.edit_bones[parent_name]
                bone.parent = parent
                bone.head = parent.tail
                bone.use_connect = True

def clear_bone_constraints(armature: bpy.types.Object, bone_name: str) -> None:
    """Remove all constraints from a bone."""
    if bone_name in armature.pose.bones:
        pose_bone = armature.pose.bones[bone_name]
        for con in pose_bone.constraints:
            pose_bone.constraints.remove(con)

def copy_bone_constraints(source_armature: bpy.types.Object, source_bone: str,
                          target_armature: bpy.types.Object, target_bone: str) -> None:
    """Copy constraints from one bone to another."""
    if source_bone not in source_armature.pose.bones:
        return
    if target_bone not in target_armature.pose.bones:
        return

    source_pb = source_armature.pose.bones[source_bone]
    target_pb = target_armature.pose.bones[target_bone]

    for con in source_pb.constraints:
        new_con = target_pb.constraints.new(con.type)
        for prop in dir(con):
            if not prop.startswith('_') and prop not in ['type', 'is_valid', 'bl_rna']:
                try:
                    setattr(new_con, prop, getattr(con, prop))
                except:
                    pass
```

**Acceptance**: Utility functions work on armatures

---

### Task 5: Weight Painter
**File**: `lib/animation/weight_painter.py`

```python
import bpy
from typing import List, Dict, Optional
from mathutils import Vector, Matrix
from math import sqrt

class AutoWeightPainter:
    """Automatic weight painting based on bone proximity."""

    def __init__(self, armature: bpy.types.Object, mesh: bpy.types.Object):
        self.armature = armature
        self.mesh = mesh
        self.bone_matrices: Dict[str, Matrix] = {}

    def calculate_weights(self, method: str = "heat") -> Dict[str, List[float]]:
        """Calculate vertex weights for all bones."""
        # Build bone world matrices
        self._build_bone_matrices()

        # Get mesh vertices in world space
        vertices = self._get_world_vertices()

        weights = {}
        for bone in self.armature.data.bones:
            if bone.use_deform:
                weights[bone.name] = self._calculate_bone_weights(bone.name, vertices, method)

        return weights

    def _build_bone_matrices(self) -> None:
        """Build world-space matrices for each bone."""
        for bone in self.armature.data.bones:
            self.bone_matrices[bone.name] = self.armature.matrix_world @ bone.matrix_local

    def _get_world_vertices(self) -> List[Vector]:
        """Get mesh vertices in world space."""
        mesh_matrix = self.mesh.matrix_world
        return [mesh_matrix @ v.co for v in self.mesh.data.vertices]

    def _calculate_bone_weights(self, bone_name: str, vertices: List[Vector], method: str) -> List[float]:
        """Calculate weights for a single bone."""
        bone = self.armature.data.bones[bone_name]
        bone_head = self.armature.matrix_world @ bone.head_local
        bone_tail = self.armature.matrix_world @ bone.tail_local

        weights = []
        for vertex in vertices:
            if method == "distance":
                weight = self._distance_weight(vertex, bone_head, bone_tail)
            elif method == "heat":
                weight = self._heat_weight(vertex, bone_head, bone_tail)
            else:
                weight = 0.0
            weights.append(weight)

        return weights

    def _distance_weight(self, vertex: Vector, bone_head: Vector, bone_tail: Vector) -> float:
        """Calculate weight based on distance to bone."""
        # Distance from vertex to bone line segment
        dist = self._point_to_segment_distance(vertex, bone_head, bone_tail)
        # Inverse distance weighting
        return 1.0 / (1.0 + dist)

    def _heat_weight(self, vertex: Vector, bone_head: Vector, bone_tail: Vector) -> float:
        """Calculate weight using heat diffusion approximation."""
        dist = self._point_to_segment_distance(vertex, bone_head, bone_tail)
        # Exponential falloff
        return max(0.0, 1.0 - dist * 2.0)

    def _point_to_segment_distance(self, point: Vector, seg_start: Vector, seg_end: Vector) -> float:
        """Calculate distance from point to line segment."""
        line = seg_end - seg_start
        line_length = line.length

        if line_length == 0:
            return (point - seg_start).length

        line_normalized = line.normalized()
        point_vec = point - seg_start

        # Project point onto line
        projection = point_vec.dot(line_normalized)
        projection = max(0, min(line_length, projection))

        closest = seg_start + line_normalized * projection
        return (point - closest).length

    def apply_weights(self, weights: Dict[str, List[float]], normalize: bool = True) -> None:
        """Apply calculated weights to the mesh."""
        # Ensure vertex groups exist
        for bone_name in weights.keys():
            if bone_name not in self.mesh.vertex_groups:
                self.mesh.vertex_groups.new(name=bone_name)

        # Apply weights
        for bone_name, bone_weights in weights.items():
            vg = self.mesh.vertex_groups[bone_name]
            for i, weight in enumerate(bone_weights):
                if weight > 0.001:
                    vg.add([i], weight, 'REPLACE')

        # Normalize if requested
        if normalize:
            self._normalize_weights()

    def _normalize_weights(self) -> None:
        """Normalize weights so they sum to 1 for each vertex."""
        bpy.context.view_layer.objects.active = self.mesh
        bpy.ops.object.mode_set(mode='WEIGHT_PAINT')
        bpy.ops.object.vertex_group_normalize_all(lock_active=False)
        bpy.ops.object.mode_set(mode='OBJECT')


def auto_weight_mesh(armature: bpy.types.Object, mesh: bpy.types.Object, method: str = "heat") -> None:
    """Automatically weight paint a mesh to an armature."""
    painter = AutoWeightPainter(armature, mesh)
    weights = painter.calculate_weights(method)
    painter.apply_weights(weights)


def parent_mesh_to_armature(armature: bpy.types.Object, mesh: bpy.types.Object,
                            with_weights: bool = True) -> None:
    """Parent a mesh to an armature with automatic weights."""
    mesh.select_set(True)
    armature.select_set(True)
    bpy.context.view_layer.objects.active = armature

    if with_weights:
        bpy.ops.object.parent_set(type='ARMATURE_AUTO')
    else:
        bpy.ops.object.parent_set(type='ARMATURE')
```

**Acceptance**: Can auto-weight paint meshes

---

### Task 6: Create Preset Files
**Files**: `configs/animation/rigs/*.yaml`

Create the 5 rig preset files:
- `human_biped.yaml` - Standard human skeleton
- `face_standard.yaml` - Face rig for expressions
- `quadruped.yaml` - 4-legged animal
- `vehicle_basic.yaml` - Simple vehicle rig
- `robot_modular.yaml` - Robot configuration

**Acceptance**: All presets loadable

---

### Task 7: Module Init and Exports
**File**: `lib/animation/__init__.py`

```python
"""
Animation System for Blender GSD

Provides rigging, IK/FK, posing, blocking, and animation tools.

Usage:
    from lib.animation import (
        RigConfig, RigBuilder, build_rig_from_preset,
        auto_weight_mesh, list_available_presets
    )

    # Build a rig from preset
    armature = build_rig_from_preset("human_biped")

    # Auto-weight a mesh
    auto_weight_mesh(armature, my_mesh)
"""

from .types import (
    RigType, BoneGroup,
    BoneConfig, BoneConstraint, BoneGroup as BoneGroupConfig,
    IKChain, RigConfig, WeightConfig, RigInstance
)

from .rig_builder import (
    RigBuilder, build_rig_from_config, build_rig_from_preset
)

from .bone_utils import (
    get_bone_chain, mirror_bone_name, get_bone_length,
    get_bone_direction, align_bone_to_vector, scale_bone,
    duplicate_bone_chain, connect_bone_chain,
    clear_bone_constraints, copy_bone_constraints
)

from .weight_painter import (
    AutoWeightPainter, auto_weight_mesh, parent_mesh_to_armature
)

from .preset_loader import (
    load_rig_preset, list_available_presets, save_rig_config
)

__all__ = [
    # Types
    'RigType', 'BoneGroup',
    'BoneConfig', 'BoneConstraint', 'BoneGroupConfig',
    'IKChain', 'RigConfig', 'WeightConfig', 'RigInstance',

    # Rig Builder
    'RigBuilder', 'build_rig_from_config', 'build_rig_from_preset',

    # Bone Utilities
    'get_bone_chain', 'mirror_bone_name', 'get_bone_length',
    'get_bone_direction', 'align_bone_to_vector', 'scale_bone',
    'duplicate_bone_chain', 'connect_bone_chain',
    'clear_bone_constraints', 'copy_bone_constraints',

    # Weight Painting
    'AutoWeightPainter', 'auto_weight_mesh', 'parent_mesh_to_armature',

    # Preset Loader
    'load_rig_preset', 'list_available_presets', 'save_rig_config',
]
```

**Acceptance**: Module imports cleanly

---

## Acceptance Criteria

### Must Have
- [ ] RigConfig, BoneConfig types defined
- [ ] RigBuilder builds armatures from config
- [ ] Preset loader loads YAML configs
- [ ] 5 preset rigs available (human, face, quad, vehicle, robot)
- [ ] Auto weight painting works
- [ ] Bone utility functions work

### Nice to Have
- [ ] Mirror bones automatically created
- [ ] Bone constraint templates
- [ ] Rig preview generation
- [ ] Rig export to FBX/BVH

---

## Dependencies

None - this is the foundation phase.

---

## Commands

```python
# Build a rig from preset
from lib.animation import build_rig_from_preset
armature = build_rig_from_preset("human_biped", name="Hero_Rig")

# List available presets
from lib.animation import list_available_presets
print(list_available_presets())
# ['human_biped', 'face_standard', 'quadruped', 'vehicle_basic', 'robot_modular']

# Auto-weight a mesh
from lib.animation import auto_weight_mesh
auto_weight_mesh(armature, my_character_mesh)
```

---

## AI Commands Reference

```
# Create a rig
"Create a human biped rig named 'Hero_Rig'"

# Apply rig to mesh
"Rig the character mesh with human_biped preset"

# Create custom rig
"Create a 4-bone spine rig for this snake mesh"

# Mirror bones
"Mirror the left arm bones to create right arm"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Geometry Rick Recommendations

1. **Geometry Nodes Compatibility**
   - Consider how rigging interacts with procedural mesh generation
   - Document when to use armature vs. geometry nodes for deformation
   - Weight painting may need adjustment for GN-generated meshes

2. **Bone Hierarchy Best Practices**
   - Add validation for orphan bones (no parent connection)
   - Ensure spine chain properly connected for animation curves
   - Consider bone roll values for proper twist deformation

3. **Weight Painting Considerations**
   - `auto_weight_mesh()` uses Blender's built-in heat diffusion
   - For complex meshes, may need manual cleanup
   - Add option for envelope-based weighting as alternative

### Pipeline Rick Recommendations

4. **Phase Dependencies**
   - Document that Phase 13.1 (IK/FK) requires Phase 13.0 complete
   - Face Animation (13.4) can run in parallel with IK/FK (13.1)
   - Animation Layers (13.7) should come after all rig work

5. **Config Structure Consistency**
   - `configs/animation/rigs/*.yaml` structure matches other GSD configs
   - Add `configs/animation/schemas/` for JSON Schema validation

### Dufus Rick Testing Recommendations

6. **Add Test Tasks**
   - Task: Test `build_rig_from_preset()` for all 5 presets
   - Task: Verify mirror bones created correctly (L/R symmetry)
   - Task: Test weight painting on sample mesh
   - Task: Validate YAML config parsing

7. **Acceptance Criteria Improvements**
   - "Auto weight painting works" → "Weight painting assigns weights to all deform bones"
   - Add minimum test mesh for validation

### Render Rick Recommendations

8. **Performance Considerations**
   - Document bone count recommendations (<200 for real-time)
   - Weight painting method "heat" vs "distance" tradeoffs
   - Consider LOD rigs for distant characters
