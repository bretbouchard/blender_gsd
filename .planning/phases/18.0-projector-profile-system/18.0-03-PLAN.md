---
wave: 3
depends_on: [18.0-01, 18.0-02]
files_modified:
  - lib/cinematic/projection/physical/projector/__init__.py
  - lib/cinematic/projection/physical/__init__.py
  - lib/cinematic/projection/physical/stages/__init__.py
autonomous: true
---

# Plan 18.0-03: Package Exports & Integration

## Goal
Create package exports for the projector module and integrate with the existing cinematic projection system.

## Context
- **Depends on**: Plans 18.0-01 (types), 18.0-02 (database)
- **Pipeline Rick**: Use 5-stage pipeline structure with `stages/` directory
- **Integration**: Extend existing `lib/cinematic/projection/`

## Tasks

<task id="1" verify="Package exports work">
Create `lib/cinematic/projection/physical/projector/__init__.py`:

```python
"""Physical projector mapping module.

This module provides projector hardware profiles, calibration utilities,
and camera factory functions for physical projection mapping.

Key Formula (Geometry Rick verified):
    focal_length = sensor_width * throw_ratio

NOT: focal_length = (throw_ratio * sensor_width) / 2

Usage:
    from lib.cinematic.projection.physical.projector import (
        ProjectorProfile,
        get_profile,
        create_projector_camera,
    )

    # Get a projector profile
    profile = get_profile("Epson_Home_Cinema_2150")

    # Create Blender camera from profile
    camera = create_projector_camera(profile)
"""

# Profile types
from .profiles import (
    ProjectorProfile,
    ProjectorType,
    AspectRatio,
    LensShift,
    KeystoneCorrection,
)

# Profile database
from .profile_database import (
    PROJECTOR_PROFILES,
    get_profile,
    list_profiles,
    get_profiles_by_throw_ratio,
    get_profiles_by_resolution,
    get_short_throw_profiles,
    get_4k_profiles,
    load_profile_from_yaml,
)

# Calibration utilities
from .calibration import (
    throw_ratio_to_focal_length,
    focal_length_to_throw_ratio,
    calculate_throw_distance,
    calculate_image_width,
    create_projector_camera,
    configure_render_for_projector,
    restore_render_settings,
)

__all__ = [
    # Types
    'ProjectorProfile',
    'ProjectorType',
    'AspectRatio',
    'LensShift',
    'KeystoneCorrection',

    # Database
    'PROJECTOR_PROFILES',
    'get_profile',
    'list_profiles',
    'get_profiles_by_throw_ratio',
    'get_profiles_by_resolution',
    'get_short_throw_profiles',
    'get_4k_profiles',
    'load_profile_from_yaml',

    # Calibration
    'throw_ratio_to_focal_length',
    'focal_length_to_throw_ratio',
    'calculate_throw_distance',
    'calculate_image_width',
    'create_projector_camera',
    'configure_render_for_projector',
    'restore_render_settings',
]

__version__ = '0.1.0'
```
</task>

<task id="2" verify="Physical projection package exports">
Create `lib/cinematic/projection/physical/__init__.py`:

```python
"""Physical projector mapping system.

This package provides tools for mapping content to physical projectors
in real-world environments.

Components:
- projector: Hardware profiles and calibration utilities
- stages: Pipeline stage functions (Phase 18.1+)
- targets: Projection surface configurations (Phase 18.3+)
- shaders: Camera projection shader nodes (Phase 18.2+)

Workflow:
1. Select projector profile from database
2. Create Blender camera from profile
3. Calibrate to real-world surface (Phase 18.1)
4. Map content to surface (Phase 18.2)
5. Render at projector native resolution

Example:
    from lib.cinematic.projection.physical import (
        get_profile,
        create_projector_camera,
    )

    # Setup projector
    profile = get_profile("Epson_Home_Cinema_2150")
    camera = create_projector_camera(profile)

    # Position camera to match real-world projector location
    camera.location = (2.5, 0, 1.8)
    camera.rotation_euler = (math.radians(-15), 0, 0)
"""

from .projector import (
    # Re-export all projector module items
    ProjectorProfile,
    ProjectorType,
    AspectRatio,
    LensShift,
    KeystoneCorrection,
    PROJECTOR_PROFILES,
    get_profile,
    list_profiles,
    get_profiles_by_throw_ratio,
    get_profiles_by_resolution,
    get_short_throw_profiles,
    get_4k_profiles,
    load_profile_from_yaml,
    throw_ratio_to_focal_length,
    focal_length_to_throw_ratio,
    calculate_throw_distance,
    calculate_image_width,
    create_projector_camera,
    configure_render_for_projector,
    restore_render_settings,
)

__all__ = [
    # Types
    'ProjectorProfile',
    'ProjectorType',
    'AspectRatio',
    'LensShift',
    'KeystoneCorrection',

    # Database
    'PROJECTOR_PROFILES',
    'get_profile',
    'list_profiles',
    'get_profiles_by_throw_ratio',
    'get_profiles_by_resolution',
    'get_short_throw_profiles',
    'get_4k_profiles',
    'load_profile_from_yaml',

    # Calibration
    'throw_ratio_to_focal_length',
    'focal_length_to_throw_ratio',
    'calculate_throw_distance',
    'calculate_image_width',
    'create_projector_camera',
    'configure_render_for_projector',
    'restore_render_settings',
]

__version__ = '0.1.0'
```
</task>

<task id="3" verify="Stages directory exists with placeholder">
Create `lib/cinematic/projection/physical/stages/__init__.py`:

```python
"""Pipeline stage functions for physical projector mapping.

This module implements the 5-stage GSD pipeline for projection mapping:

Stage 0 (Normalize): Profile validation, seed hashing for determinism
Stage 1 (Primary): Base frustum setup, projector camera creation
Stage 2 (Secondary): Calibration/alignment, keystone correction
Stage 3 (Detail): Content mapping, UV projection
Stage 4 (Output): Render configuration, export

Pipeline Rick: "Each stage should be a pure function that takes
state and context, returns new state. Deterministic execution
is critical for reproducible calibration."

Note: Stage implementations are added in Phase 18.1 (calibration)
and Phase 18.2 (content mapping). This module provides the stage
interface and utilities.
"""

from dataclasses import dataclass
from typing import Dict, Any, Optional


@dataclass
class StageContext:
    """Context passed to all stage functions."""
    parameters: Dict[str, Any]
    profile_name: str
    target_id: Optional[str] = None
    seed: Optional[int] = None


@dataclass
class StageState:
    """State accumulated through pipeline stages."""
    stage: int
    profile: Any  # ProjectorProfile
    camera: Any   # bpy.types.Object (camera)
    target_checksum: Optional[str] = None
    calibration_points: Optional[list] = None
    errors: list = None

    def __post_init__(self):
        if self.errors is None:
            self.errors = []


# Stage function signature
StageFunction = callable  # (state: StageState, context: StageContext) -> StageState


def stage_normalize(state: StageState, context: StageContext) -> StageState:
    """Stage 0: Normalize parameters and validate profile.

    This stage:
    - Loads projector profile
    - Computes deterministic seed from inputs
    - Validates all required parameters

    Args:
        state: Current pipeline state
        context: Stage context with parameters

    Returns:
        Updated state with profile loaded
    """
    from ..projector import get_profile
    import hashlib

    # Load profile
    profile = get_profile(context.profile_name)

    # Compute deterministic seed (Pipeline Rick requirement)
    if context.seed is None:
        seed_input = (
            context.profile_name,
            str(context.parameters.get('position', [])),
            context.target_id or '',
        )
        seed = int(hashlib.md5('|'.join(seed_input).encode()).hexdigest()[:8], 16)
        context.seed = seed

    return StageState(
        stage=0,
        profile=profile,
        camera=None,
        target_checksum=context.parameters.get('target_checksum'),
    )


def stage_primary(state: StageState, context: StageContext) -> StageState:
    """Stage 1: Create base projector camera.

    This stage:
    - Creates Blender camera from profile
    - Sets render resolution to projector native
    - Positions camera if position provided

    Args:
        state: Current pipeline state (must have profile)
        context: Stage context with parameters

    Returns:
        Updated state with camera created
    """
    from ..projector import create_projector_camera

    if state.profile is None:
        raise ValueError("Profile required - run stage_normalize first")

    # Create camera from profile
    camera = create_projector_camera(state.profile)

    # Position if provided
    position = context.parameters.get('position')
    if position:
        camera.location = position

    rotation = context.parameters.get('rotation')
    if rotation:
        import math
        camera.rotation_euler = [math.radians(r) for r in rotation]

    return StageState(
        stage=1,
        profile=state.profile,
        camera=camera,
        target_checksum=state.target_checksum,
    )


# Stages 2-4 implemented in Phase 18.1 and 18.2
# stage_secondary = ...  # Phase 18.1: Calibration
# stage_detail = ...     # Phase 18.2: Content mapping
# stage_output = ...     # Phase 18.2: Render/export


__all__ = [
    'StageContext',
    'StageState',
    'stage_normalize',
    'stage_primary',
]
```
</task>

<task id="4" verify="Integration test passes">
Create `tests/integration/projection/test_projector_integration.py`:

```python
"""Integration tests for projector profile system.

These tests verify the complete workflow from profile selection
to camera creation.
"""
import pytest
import math


class TestProjectorWorkflow:
    """Integration tests for complete projector workflow."""

    def test_profile_to_camera_workflow(self):
        """Test complete workflow: profile -> camera."""
        from lib.cinematic.projection.physical import (
            get_profile,
            create_projector_camera,
            configure_render_for_projector,
            restore_render_settings,
        )

        # Get profile
        profile = get_profile("Epson_Home_Cinema_2150")
        assert profile.name == "Epson_Home_Cinema_2150"

        # Verify focal length calculation
        focal = profile.get_blender_focal_length()
        expected = 36.0 * 1.32  # sensor_width * throw_ratio
        assert abs(focal - expected) < 0.01

    def test_short_throw_workflow(self):
        """Test short-throw projector workflow."""
        from lib.cinematic.projection.physical import (
            get_short_throw_profiles,
        )

        # Get short-throw projectors
        profiles = get_short_throw_profiles(0.8)
        assert len(profiles) >= 1

        # Verify all are short-throw
        for profile in profiles:
            assert profile.throw_ratio <= 0.8

    def test_4k_workflow(self):
        """Test 4K projector workflow."""
        from lib.cinematic.projection.physical import (
            get_4k_profiles,
        )

        # Get 4K projectors
        profiles = get_4k_profiles()
        assert len(profiles) >= 1

        # Verify all are 4K
        for profile in profiles:
            width, height = profile.native_resolution
            assert width >= 3840
            assert height >= 2160

    def test_lens_shift_workflow(self):
        """Test lens shift configuration."""
        from lib.cinematic.projection.physical import get_profile

        # Get projector with lens shift
        profile = get_profile("Epson_Home_Cinema_3800")

        # Verify lens shift
        assert profile.lens_shift.vertical > 0
        assert profile.lens_shift.horizontal > 0

        # Verify Blender shift conversion
        shift_x = profile.get_blender_shift_x()
        shift_y = profile.get_blender_shift_y()
        assert shift_x == profile.lens_shift.horizontal
        assert shift_y == profile.lens_shift.vertical


class TestStagePipeline:
    """Tests for stage-based pipeline."""

    def test_stage_normalize(self):
        """Test normalize stage."""
        from lib.cinematic.projection.physical.stages import (
            stage_normalize,
            StageContext,
            StageState,
        )

        context = StageContext(
            parameters={'position': [2.5, 0, 1.8]},
            profile_name="Epson_Home_Cinema_2150",
        )

        state = StageState(stage=-1, profile=None, camera=None)
        result = stage_normalize(state, context)

        assert result.stage == 0
        assert result.profile is not None
        assert result.profile.name == "Epson_Home_Cinema_2150"

    def test_stage_primary(self):
        """Test primary stage (camera creation)."""
        from lib.cinematic.projection.physical.stages import (
            stage_normalize,
            stage_primary,
            StageContext,
            StageState,
        )

        context = StageContext(
            parameters={'position': [2.5, 0, 1.8]},
            profile_name="Epson_Home_Cinema_2150",
        )

        # Run normalize first
        state = StageState(stage=-1, profile=None, camera=None)
        state = stage_normalize(state, context)

        # Run primary
        result = stage_primary(state, context)

        assert result.stage == 1
        # Camera creation requires bpy, so we just verify stage advances


class TestDeterminism:
    """Tests for deterministic execution (Pipeline Rick requirement)."""

    def test_same_inputs_same_seed(self):
        """Test that same inputs produce same seed."""
        from lib.cinematic.projection.physical.stages import (
            stage_normalize,
            StageContext,
            StageState,
        )
        import hashlib

        context = StageContext(
            parameters={'position': [2.5, 0, 1.8]},
            profile_name="Epson_Home_Cinema_2150",
            target_id="reading_room",
        )

        # Run twice with same inputs
        state1 = StageState(stage=-1, profile=None, camera=None)
        result1 = stage_normalize(state1, context)

        state2 = StageState(stage=-1, profile=None, camera=None)
        result2 = stage_normalize(state2, context)

        # Seeds should be identical
        assert context.seed is not None
        # Both calls should produce same seed
        seed1 = int(hashlib.md5('|'.join((
            "Epson_Home_Cinema_2150",
            "[2.5, 0, 1.8]",
            "reading_room",
        )).encode()).hexdigest()[:8], 16)

        assert context.seed == seed1

    def test_different_inputs_different_seed(self):
        """Test that different inputs produce different seeds."""
        from lib.cinematic.projection.physical.stages import (
            stage_normalize,
            StageContext,
            StageState,
        )

        context1 = StageContext(
            parameters={'position': [2.5, 0, 1.8]},
            profile_name="Epson_Home_Cinema_2150",
            target_id="reading_room",
        )

        context2 = StageContext(
            parameters={'position': [3.0, 0, 1.8]},
            profile_name="Epson_Home_Cinema_2150",
            target_id="garage_door",
        )

        state1 = StageState(stage=-1, profile=None, camera=None)
        stage_normalize(state1, context1)
        seed1 = context1.seed

        state2 = StageState(stage=-1, profile=None, camera=None)
        stage_normalize(state2, context2)
        seed2 = context2.seed

        assert seed1 != seed2
```
</task>
</tasks>

## Verification Criteria

- [ ] `lib/cinematic/projection/physical/projector/__init__.py` with all exports
- [ ] `lib/cinematic/projection/physical/__init__.py` with re-exports
- [ ] `lib/cinematic/projection/physical/stages/__init__.py` with stage interface
- [ ] `stage_normalize` function works
- [ ] `stage_primary` function works
- [ ] Integration tests pass

## must_haves

- All types exported from `lib.cinematic.projection.physical`
- Stage pipeline interface defined
- Deterministic seed generation (Pipeline Rick requirement)
- Integration tests for complete workflow
- Version 0.1.0
