---
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/projection/physical/projector/profiles.py
  - lib/cinematic/projection/physical/projector/calibration.py
  - tests/unit/projection/test_profiles.py
autonomous: true
---

# Plan 18.0-01: ProjectorProfile Types

## Goal
Create the foundational data types for physical projector mapping: ProjectorProfile dataclass with optical characteristics and throw ratio to focal length conversion.

## Context
- **Design Document**: `.planning/projection-mapping-design.md`
- **Geometry Rick Correction**: Throw ratio formula is `focal_length = sensor_width * throw_ratio` (NOT divided by 2)
- **Pipeline Rick**: Nest under `lib/cinematic/projection/physical/`

## Tasks

<task id="1" verify="Directory exists">
Create module directory structure:
```
lib/cinematic/projection/physical/
├── __init__.py
├── projector/
│   ├── __init__.py
│   ├── profiles.py
│   └── calibration.py
└── stages/
    └── __init__.py
```
</task>

<task id="2" verify="ProjectorProfile dataclass with all fields">
Create `lib/cinematic/projection/physical/projector/profiles.py`:

```python
"""Projector hardware profile types for physical projection mapping."""
from dataclasses import dataclass, field
from typing import Tuple, Optional, List
from enum import Enum


class ProjectorType(Enum):
    """Projector technology type."""
    DLP = "dlp"
    LCD = "lcd"
    LCOS = "lcos"
    LASER = "laser"


class AspectRatio(Enum):
    """Common projector aspect ratios."""
    RATIO_16_9 = (16, 9)
    RATIO_4_3 = (4, 3)
    RATIO_16_10 = (16, 10)
    RATIO_17_9 = (17, 9)
    RATIO_21_9 = (21, 9)

    @property
    def value(self) -> float:
        return self.value[0] / self.value[1]


@dataclass
class LensShift:
    """Lens shift capabilities."""
    vertical: float = 0.0    # ±percentage (e.g., 0.15 = ±15%)
    horizontal: float = 0.0  # ±percentage (e.g., 0.05 = ±5%)
    vertical_range: Tuple[float, float] = (0.0, 0.0)   # (min, max) shift
    horizontal_range: Tuple[float, float] = (0.0, 0.0)  # (min, max) shift


@dataclass
class KeystoneCorrection:
    """Keystone correction capabilities."""
    horizontal: float = 0.0  # Degrees
    vertical: float = 0.0    # Degrees
    automatic: bool = False   # Has auto-keystone feature
    corner_correction: bool = False  # 4-corner correction support


@dataclass
class ProjectorProfile:
    """Physical projector hardware specifications.

    This dataclass stores all the optical and output characteristics
    of a physical projector for use in Blender projection mapping.

    Key Formula (Geometry Rick verified):
        focal_length = sensor_width * throw_ratio

    NOT: focal_length = (throw_ratio * sensor_width) / 2
    """
    # Identity
    name: str                           # "Epson_Home_Cinema_2150"
    manufacturer: str                   # "Epson"
    model: str = ""                     # "Home Cinema 2150"
    projector_type: ProjectorType = ProjectorType.DLP

    # Output specifications
    native_resolution: Tuple[int, int] = (1920, 1080)
    aspect_ratio: AspectRatio = AspectRatio.RATIO_16_9
    max_refresh_rate: int = 60  # Hz

    # Optical characteristics
    throw_ratio: float = 1.32              # distance / width (horizontal)
    throw_ratio_range: Tuple[float, float] = (1.32, 1.32)  # (min, max) for zoom lenses
    has_zoom: bool = False                 # True if throw_ratio_range differs

    # Lens shift (Geometry Rick: critical for proper projection alignment)
    lens_shift: LensShift = field(default_factory=LensShift)

    # Keystone correction
    keystone: KeystoneCorrection = field(default_factory=KeystoneCorrection)

    # Brightness and contrast
    brightness_lumens: int = 2500
    contrast_ratio: int = 70000
    color_gamut: str = "Rec.709"  # Rec.709, DCI-P3, Rec.2020

    # Sensor specifications (for Blender camera conversion)
    sensor_width: float = 36.0   # mm (full frame equivalent)
    sensor_height: float = 20.25  # mm (16:9 aspect)

    # Calibration metadata
    calibration_date: Optional[str] = None
    calibration_notes: str = ""

    def get_blender_focal_length(self, aspect: str = 'horizontal') -> float:
        """Convert throw ratio to Blender focal length.

        CORRECTED FORMULA (Geometry Rick):
            focal_length = sensor_width * throw_ratio

        Args:
            aspect: 'horizontal', 'vertical', or 'diagonal'

        Returns:
            Focal length in mm for Blender camera
        """
        from .calibration import throw_ratio_to_focal_length
        return throw_ratio_to_focal_length(
            self.throw_ratio,
            self.sensor_width,
            self.sensor_height,
            aspect
        )

    def get_blender_shift_x(self) -> float:
        """Get Blender camera shift X from lens shift.

        Blender shift is normalized (-0.5 to 0.5).
        Lens shift is percentage (0.15 = 15%).
        """
        return self.lens_shift.horizontal

    def get_blender_shift_y(self) -> float:
        """Get Blender camera shift Y from lens shift.

        Blender shift is normalized (-0.5 to 0.5).
        Lens shift is percentage (0.15 = 15%).
        """
        return self.lens_shift.vertical
```
</task>

<task id="3" verify="throw_ratio_to_focal_length function with correct formula">
Create `lib/cinematic/projection/physical/projector/calibration.py`:

```python
"""Calibration utilities for physical projector mapping.

This module provides the throw ratio to focal length conversion
and camera factory functions.

Key Formula (Geometry Rick verified):
    focal_length = sensor_width * throw_ratio
"""
import math
from typing import Optional, Tuple
import bpy
from mathutils import Vector

from .profiles import ProjectorProfile, ProjectorType


def throw_ratio_to_focal_length(
    throw_ratio: float,
    sensor_width: float,
    sensor_height: float,
    aspect: str = 'horizontal'
) -> float:
    """Convert throw ratio to Blender focal length.

    CORRECTED FORMULA (Geometry Rick identified original was wrong):
        focal_length = sensor_width * throw_ratio

    The original formula had an incorrect division by 2.

    Args:
        throw_ratio: Projector throw ratio (distance / image_width)
        sensor_width: Sensor width in mm
        sensor_height: Sensor height in mm
        aspect: 'horizontal', 'vertical', or 'diagonal'

    Returns:
        Focal length in mm for Blender camera

    Raises:
        ValueError: If throw_ratio <= 0 or aspect invalid
    """
    if throw_ratio <= 0:
        raise ValueError(f"Throw ratio must be positive, got {throw_ratio}")

    if aspect == 'horizontal':
        return sensor_width * throw_ratio
    elif aspect == 'vertical':
        return sensor_height * throw_ratio * (sensor_width / sensor_height)
    elif aspect == 'diagonal':
        diagonal = math.sqrt(sensor_width**2 + sensor_height**2)
        return diagonal * throw_ratio
    else:
        raise ValueError(f"Invalid aspect: {aspect}. Use 'horizontal', 'vertical', or 'diagonal'")


def focal_length_to_throw_ratio(
    focal_length: float,
    sensor_width: float
) -> float:
    """Convert Blender focal length back to throw ratio.

    Inverse of throw_ratio_to_focal_length.

    Args:
        focal_length: Focal length in mm
        sensor_width: Sensor width in mm

    Returns:
        Throw ratio (distance / width)
    """
    if focal_length <= 0:
        raise ValueError(f"Focal length must be positive, got {focal_length}")

    return focal_length / sensor_width


def calculate_throw_distance(
    throw_ratio: float,
    image_width: float
) -> float:
    """Calculate throw distance for desired image width.

    Args:
        throw_ratio: Projector throw ratio
        image_width: Desired image width in meters

    Returns:
        Required throw distance in meters
    """
    return throw_ratio * image_width


def calculate_image_width(
    throw_ratio: float,
    throw_distance: float
) -> float:
    """Calculate image width at given throw distance.

    Args:
        throw_ratio: Projector throw ratio
        throw_distance: Distance from projector to surface in meters

    Returns:
        Image width in meters
    """
    return throw_distance / throw_ratio


def create_projector_camera(
    profile: ProjectorProfile,
    name: Optional[str] = None,
    collection: Optional[bpy.types.Collection] = None
) -> bpy.types.Object:
    """Create a Blender camera from a projector profile.

    This creates a camera that matches the optical characteristics
    of the physical projector for accurate preview and rendering.

    Args:
        profile: ProjectorProfile with optical characteristics
        name: Camera name (defaults to profile.name + "_camera")
        collection: Collection to link camera to (defaults to scene collection)

    Returns:
        Blender camera object
    """
    camera_name = name or f"{profile.name}_camera"

    # Create camera data
    cam_data = bpy.data.cameras.new(camera_name)
    cam_data.type = 'PERSP'

    # Set focal length from throw ratio
    cam_data.lens = profile.get_blender_focal_length()

    # Set sensor size
    cam_data.sensor_width = profile.sensor_width
    cam_data.sensor_height = profile.sensor_height
    cam_data.sensor_fit = 'HORIZONTAL'

    # Set lens shift
    cam_data.shift_x = profile.get_blender_shift_x()
    cam_data.shift_y = profile.get_blender_shift_y()

    # Create camera object
    cam_obj = bpy.data.objects.new(camera_name, cam_data)

    # Link to collection
    if collection is None:
        collection = bpy.context.scene.collection
    collection.objects.link(cam_obj)

    # Store profile reference as custom property
    cam_obj['projector_profile'] = profile.name
    cam_obj['throw_ratio'] = profile.throw_ratio

    return cam_obj


def configure_render_for_projector(
    profile: ProjectorProfile,
    scene: Optional[bpy.types.Scene] = None
) -> dict:
    """Configure render settings for projector output.

    Args:
        profile: ProjectorProfile with resolution
        scene: Scene to configure (defaults to active scene)

    Returns:
        Dict with original settings for restoration
    """
    if scene is None:
        scene = bpy.context.scene

    # Store original settings
    original = {
        'resolution_x': scene.render.resolution_x,
        'resolution_y': scene.render.resolution_y,
        'resolution_percentage': scene.render.resolution_percentage,
        'pixel_aspect_x': scene.render.pixel_aspect_x,
        'pixel_aspect_y': scene.render.pixel_aspect_y,
    }

    # Set to projector native resolution
    scene.render.resolution_x = profile.native_resolution[0]
    scene.render.resolution_y = profile.native_resolution[1]
    scene.render.resolution_percentage = 100
    scene.render.pixel_aspect_x = 1.0
    scene.render.pixel_aspect_y = 1.0

    return original


def restore_render_settings(
    original: dict,
    scene: Optional[bpy.types.Scene] = None
) -> None:
    """Restore render settings from saved state.

    Args:
        original: Dict from configure_render_for_projector
        scene: Scene to restore (defaults to active scene)
    """
    if scene is None:
        scene = bpy.context.scene

    scene.render.resolution_x = original['resolution_x']
    scene.render.resolution_y = original['resolution_y']
    scene.render.resolution_percentage = original['resolution_percentage']
    scene.render.pixel_aspect_x = original['pixel_aspect_x']
    scene.render.pixel_aspect_y = original['pixel_aspect_y']
```
</task>

<task id="4" verify="Unit tests pass">
Create `tests/unit/projection/test_profiles.py`:

```python
"""Unit tests for projector profile types."""
import pytest
import math

# Import from the module (will work once created)
from lib.cinematic.projection.physical.projector.profiles import (
    ProjectorProfile,
    ProjectorType,
    AspectRatio,
    LensShift,
    KeystoneCorrection,
)
from lib.cinematic.projection.physical.projector.calibration import (
    throw_ratio_to_focal_length,
    focal_length_to_throw_ratio,
    calculate_throw_distance,
    calculate_image_width,
)


class TestThrowRatioConversion:
    """Tests for throw ratio to focal length conversion."""

    def test_horizontal_throw_ratio(self):
        """Test horizontal throw ratio conversion."""
        # Standard 36mm sensor, 1.32 throw ratio
        focal = throw_ratio_to_focal_length(1.32, 36.0, 20.25, 'horizontal')
        assert math.isclose(focal, 47.52, rel_tol=0.001)

    def test_vertical_throw_ratio(self):
        """Test vertical throw ratio conversion."""
        focal = throw_ratio_to_focal_length(1.32, 36.0, 20.25, 'vertical')
        # vertical = sensor_height * throw_ratio * (sensor_width / sensor_height)
        # = 20.25 * 1.32 * (36 / 20.25) = 47.52
        assert math.isclose(focal, 47.52, rel_tol=0.001)

    def test_diagonal_throw_ratio(self):
        """Test diagonal throw ratio conversion."""
        focal = throw_ratio_to_focal_length(1.32, 36.0, 20.25, 'diagonal')
        diagonal = math.sqrt(36.0**2 + 20.25**2)
        expected = diagonal * 1.32
        assert math.isclose(focal, expected, rel_tol=0.001)

    def test_short_throw_projector(self):
        """Test short throw projector (0.5 throw ratio)."""
        focal = throw_ratio_to_focal_length(0.5, 36.0, 20.25, 'horizontal')
        assert math.isclose(focal, 18.0, rel_tol=0.001)

    def test_long_throw_projector(self):
        """Test long throw projector (2.0 throw ratio)."""
        focal = throw_ratio_to_focal_length(2.0, 36.0, 20.25, 'horizontal')
        assert math.isclose(focal, 72.0, rel_tol=0.001)

    def test_invalid_throw_ratio(self):
        """Test that invalid throw ratio raises error."""
        with pytest.raises(ValueError):
            throw_ratio_to_focal_length(0, 36.0, 20.25)

        with pytest.raises(ValueError):
            throw_ratio_to_focal_length(-1.0, 36.0, 20.25)

    def test_invalid_aspect(self):
        """Test that invalid aspect raises error."""
        with pytest.raises(ValueError):
            throw_ratio_to_focal_length(1.32, 36.0, 20.25, 'invalid')

    def test_inverse_conversion(self):
        """Test that focal_length_to_throw_ratio is inverse."""
        original_ratio = 1.32
        focal = throw_ratio_to_focal_length(original_ratio, 36.0, 20.25, 'horizontal')
        back_to_ratio = focal_length_to_throw_ratio(focal, 36.0)
        assert math.isclose(back_to_ratio, original_ratio, rel_tol=0.001)


class TestThrowDistance:
    """Tests for throw distance calculations."""

    def test_throw_distance_calculation(self):
        """Test throw distance from throw ratio."""
        distance = calculate_throw_distance(1.32, 2.0)  # 2m wide image
        assert math.isclose(distance, 2.64, rel_tol=0.001)

    def test_image_width_calculation(self):
        """Test image width from throw distance."""
        width = calculate_image_width(1.32, 2.64)  # 2.64m distance
        assert math.isclose(width, 2.0, rel_tol=0.001)

    def test_round_trip(self):
        """Test distance and width are inverses."""
        throw_ratio = 1.5
        image_width = 3.0
        distance = calculate_throw_distance(throw_ratio, image_width)
        back_to_width = calculate_image_width(throw_ratio, distance)
        assert math.isclose(back_to_width, image_width, rel_tol=0.001)


class TestProjectorProfile:
    """Tests for ProjectorProfile dataclass."""

    def test_default_profile(self):
        """Test default profile creation."""
        profile = ProjectorProfile(
            name="test_projector",
            manufacturer="Test"
        )
        assert profile.name == "test_projector"
        assert profile.throw_ratio == 1.32
        assert profile.native_resolution == (1920, 1080)

    def test_get_blender_focal_length(self):
        """Test profile focal length calculation."""
        profile = ProjectorProfile(
            name="test",
            manufacturer="Test",
            throw_ratio=1.5,
            sensor_width=36.0,
            sensor_height=20.25
        )
        focal = profile.get_blender_focal_length()
        assert math.isclose(focal, 54.0, rel_tol=0.001)  # 36 * 1.5

    def test_lens_shift_defaults(self):
        """Test default lens shift is zero."""
        profile = ProjectorProfile(
            name="test",
            manufacturer="Test"
        )
        assert profile.lens_shift.horizontal == 0.0
        assert profile.lens_shift.vertical == 0.0

    def test_lens_shift_custom(self):
        """Test custom lens shift."""
        profile = ProjectorProfile(
            name="test",
            manufacturer="Test",
            lens_shift=LensShift(vertical=0.15, horizontal=0.05)
        )
        assert profile.lens_shift.vertical == 0.15
        assert profile.lens_shift.horizontal == 0.05

    def test_blender_shift_conversion(self):
        """Test shift conversion for Blender."""
        profile = ProjectorProfile(
            name="test",
            manufacturer="Test",
            lens_shift=LensShift(vertical=0.15, horizontal=0.05)
        )
        assert profile.get_blender_shift_x() == 0.05
        assert profile.get_blender_shift_y() == 0.15


class TestLensShift:
    """Tests for LensShift dataclass."""

    def test_default_lens_shift(self):
        """Test default lens shift."""
        shift = LensShift()
        assert shift.vertical == 0.0
        assert shift.horizontal == 0.0

    def test_range_defaults(self):
        """Test range defaults to single value."""
        shift = LensShift(vertical=0.15)
        assert shift.vertical_range == (0.0, 0.0)

    def test_range_custom(self):
        """Test custom range."""
        shift = LensShift(
            vertical=0.10,
            vertical_range=(0.0, 0.20)
        )
        assert shift.vertical_range == (0.0, 0.20)


class TestKeystoneCorrection:
    """Tests for KeystoneCorrection dataclass."""

    def test_default_keystone(self):
        """Test default keystone."""
        keystone = KeystoneCorrection()
        assert keystone.horizontal == 0.0
        assert keystone.vertical == 0.0
        assert keystone.automatic == False

    def test_custom_keystone(self):
        """Test custom keystone settings."""
        keystone = KeystoneCorrection(
            horizontal=15.0,
            vertical=10.0,
            automatic=True
        )
        assert keystone.horizontal == 15.0
        assert keystone.vertical == 10.0
        assert keystone.automatic == True
```
</task>

## Verification Criteria

- [ ] Directory structure created at `lib/cinematic/projection/physical/`
- [ ] `ProjectorProfile` dataclass with all fields from design
- [ ] `LensShift` and `KeystoneCorrection` dataclasses
- [ ] `throw_ratio_to_focal_length` with CORRECT formula (no `/2`)
- [ ] `create_projector_camera` creates Blender camera with correct settings
- [ ] Unit tests pass with >80% coverage

## must_haves

- `ProjectorProfile` dataclass with: name, manufacturer, native_resolution, throw_ratio, lens_shift, sensor_width/height
- `throw_ratio_to_focal_length` function using formula: `sensor_width * throw_ratio`
- Unit tests verifying throw ratio conversion for horizontal/vertical/diagonal
- All imports work without errors
