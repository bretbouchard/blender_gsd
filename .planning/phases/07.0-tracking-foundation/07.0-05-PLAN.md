---
phase: 07.0-tracking-foundation
plan: 05
type: execute
wave: 3
depends_on: ["07.0-01", "07.0-03", "07.0-04"]
files_modified:
  - lib/cinematic/tracking/__init__.py
  - lib/cinematic/tracking/session_manager.py
  - lib/cinematic/__init__.py
  - .gsd-state/tracking/
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tracking package exports all types and functions"
    - "Cinematic package includes tracking exports"
    - "Version is updated to 0.3.1"
    - "All modules can be imported from lib.cinematic.tracking"
    - "Tracking sessions can be saved and loaded for resume capability"
  artifacts:
    - path: "lib/cinematic/tracking/__init__.py"
      provides: "Complete tracking package exports"
      min_lines: 50
      contains: "__all__"
    - path: "lib/cinematic/__init__.py"
      provides: "Updated cinematic package with tracking"
      contains: "from .tracking import"
    - path: "lib/cinematic/tracking/session_manager.py"
      provides: "Tracking session persistence (save/load/resume)"
      min_lines: 100
      contains: "class TrackingSessionManager"
    - path: ".gsd-state/tracking/"
      provides: "State persistence directory structure"
      contains: "sessions/, solves/, footage/"
  key_links:
    - from: "lib/cinematic/tracking/__init__.py"
      to: "lib/cinematic/tracking/types.py"
      via: "imports"
      pattern: "from .types import"
    - from: "lib/cinematic/tracking/session_manager.py"
      to: "lib/cinematic/tracking/types.py"
      via: "imports TrackingSession"
      pattern: "from .types import.*TrackingSession"
---

<objective>
Update package exports and version for tracking module integration, plus implement state persistence framework.

Purpose: Expose all tracking types and functions, update version to 0.3.1, and enable session resume capability.
Output: Updated __init__.py files with complete exports, session_manager.py for persistence, and .gsd-state/tracking/ directory structure.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

# Reference existing package structure
@lib/cinematic/__init__.py
@lib/cinematic/tracking/types.py
@lib/cinematic/tracking/footage.py
@lib/cinematic/tracking/import_export.py

# Reference state persistence pattern
@lib/cinematic/state_manager.py
</context>

<tasks>

<task type="auto">
  <name>Update tracking package __init__.py</name>
  <files>lib/cinematic/tracking/__init__.py</files>
  <action>
Update the tracking package __init__.py to export all types and functions.

Current file may be minimal - expand it with:

1. Module docstring describing the tracking package
2. BLENDER_AVAILABLE flag
3. Import and export all types from types.py
4. Import and export all functions from footage.py
5. Import and export all functions from import_export.py
6. __all__ list with all exports
7. __version__ = "0.1.0"

Structure:
```python
"""
Motion Tracking Package

Provides types and utilities for motion tracking workflows:
- TrackData, SolveData, FootageMetadata, TrackingSession, SolveReport types
- Footage metadata extraction via ffprobe
- External tracking import (Nuke .chan, coordinate conversion)
- State persistence for resume capability

Quick Start:
    from lib.cinematic.tracking import (
        TrackData, SolveData, FootageMetadata, TrackingSession,
        extract_metadata, analyze_footage,
        import_nuke_chan, convert_yup_to_zup_position,
    )

    # Extract footage metadata
    metadata = extract_metadata("footage/my_shot.mp4")

    # Import Nuke tracking
    solve = import_nuke_chan("tracking/camera.chan")
"""

try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False

from .types import (
    TrackData,
    SolveData,
    SolveReport,
    FootageMetadata,
    TrackingSession,
)

from .footage import (
    extract_metadata,
    analyze_footage,
    get_frame_rate,
)

from .import_export import (
    convert_yup_to_zup_position,
    convert_yup_to_zup_rotation,
    fov_to_focal_length,
    import_nuke_chan,
    import_tracking_data,
)

__all__ = [
    # Types
    "TrackData",
    "SolveData",
    "SolveReport",
    "FootageMetadata",
    "TrackingSession",
    # Footage
    "extract_metadata",
    "analyze_footage",
    "get_frame_rate",
    # Import/Export
    "convert_yup_to_zup_position",
    "convert_yup_to_zup_rotation",
    "fov_to_focal_length",
    "import_nuke_chan",
    "import_tracking_data",
    # Constants
    "BLENDER_AVAILABLE",
]

__version__ = "0.1.0"
```
  </action>
  <verify>
python3 -c "
from lib.cinematic.tracking import (
    TrackData, SolveData, FootageMetadata, TrackingSession, SolveReport,
    extract_metadata, analyze_footage, get_frame_rate,
    convert_yup_to_zup_position, fov_to_focal_length, import_nuke_chan,
    BLENDER_AVAILABLE
)
print(f'Tracking package version: 0.1.0')
print(f'BLENDER_AVAILABLE: {BLENDER_AVAILABLE}')
print('All tracking exports accessible')
"
  </verify>
  <done>
- lib/cinematic/tracking/__init__.py exports all types and functions
- All imports work from lib.cinematic.tracking
- __all__ list is complete
  </done>
</task>

<task type="auto">
  <name>Update cinematic package __init__.py</name>
  <files>lib/cinematic/__init__.py</files>
  <action>
Update the main cinematic package __init__.py to include tracking exports.

Add to the existing file (DO NOT rewrite entire file, just add tracking section):

1. Add tracking imports after the existing Testing & Benchmarking section:
```python
# Tracking System (Phase 7.0)
from .tracking.types import (
    TrackData, SolveData, SolveReport, FootageMetadata, TrackingSession
)
from .tracking.footage import (
    extract_metadata, analyze_footage, get_frame_rate
)
from .tracking.import_export import (
    convert_yup_to_zup_position, convert_yup_to_zup_rotation,
    fov_to_focal_length, import_nuke_chan, import_tracking_data
)
```

2. Add tracking exports to __all__ list:
```python
    # Tracking System
    "TrackData",
    "SolveData",
    "SolveReport",
    "FootageMetadata",
    "TrackingSession",
    "extract_metadata",
    "analyze_footage",
    "get_frame_rate",
    "convert_yup_to_zup_position",
    "convert_yup_to_zup_rotation",
    "fov_to_focal_length",
    "import_nuke_chan",
    "import_tracking_data",
```

3. Update version from "0.3.0" to "0.3.1"

4. Update module docstring to mention tracking:
   Add "tracking: Motion tracking types and import" to the Modules list
  </action>
  <verify>
python3 -c "
from lib.cinematic import (
    TrackData, SolveData, FootageMetadata,
    extract_metadata, convert_yup_to_zup_position
)
from lib.cinematic import __version__
print(f'Cinematic package version: {__version__}')
assert __version__ == '0.3.1', f'Version should be 0.3.1, got {__version__}'
print('Tracking types accessible from lib.cinematic')
"
  </verify>
  <done>
- lib/cinematic/__init__.py includes tracking exports
- Version updated to 0.3.1
- All tracking types/functions accessible from lib.cinematic
  </done>
</task>

<task type="auto">
  <name>Implement tracking session persistence</name>
  <files>lib/cinematic/tracking/session_manager.py, .gsd-state/tracking/</files>
  <action>
Create the TrackingSessionManager class and state persistence directory structure, following patterns from lib/cinematic/state_manager.py.

1. Create the .gsd-state/tracking/ directory structure:
```
.gsd-state/tracking/
├── sessions/      # Active tracking sessions (for resume)
├── solves/        # Completed camera solves
└── footage/       # Footage metadata cache
```

Create placeholder .gitkeep files in each subdirectory.

2. Create lib/cinematic/tracking/session_manager.py:

```python
"""
Tracking Session Persistence

Provides TrackingSessionManager for save/load/resume of tracking sessions.
Follows pattern from lib/cinematic/state_manager.py.
"""

from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional, List

try:
    import yaml
except ImportError:
    yaml = None

from .types import TrackingSession, TrackData


class TrackingSessionManager:
    """
    Manager for tracking session persistence.

    Handles saving and loading TrackingSession to/from YAML files.
    Provides resume capability for interrupted tracking operations.

    Usage:
        manager = TrackingSessionManager()

        # Save session
        session = TrackingSession(session_id="shot_001", footage_path="/path/to/footage.mp4")
        manager.save(session)

        # Load session
        loaded = manager.load("shot_001")

        # List sessions
        sessions = manager.list_sessions()
    """

    def __init__(self, state_root: Optional[Path] = None):
        """
        Initialize TrackingSessionManager.

        Args:
            state_root: Root directory for state files.
                       Defaults to .gsd-state/tracking
        """
        if state_root is None:
            state_root = Path(".gsd-state/tracking")
        self.state_root = Path(state_root)
        self.sessions_dir = self.state_root / "sessions"
        self.solves_dir = self.state_root / "solves"
        self.footage_dir = self.state_root / "footage"

    def save(self, session: TrackingSession, path: Optional[Path] = None) -> None:
        """
        Save tracking session to YAML file.

        Sets timestamp before saving. Creates parent directories
        if needed. Falls back to JSON if PyYAML not available.

        Args:
            session: TrackingSession to save
            path: Optional output path. Defaults to sessions/{session_id}.yaml
        """
        if path is None:
            path = self.sessions_dir / f"{session.session_id}.yaml"

        # Ensure directory exists
        path.parent.mkdir(parents=True, exist_ok=True)

        # Convert to dict with timestamp
        data = session.to_dict()
        data["saved_at"] = datetime.utcnow().isoformat()

        # Write YAML or JSON
        if yaml:
            with open(path, "w", encoding="utf-8") as f:
                yaml.dump(data, f, default_flow_style=False, sort_keys=False)
        else:
            import json
            with open(path, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)

    def load(self, session_id: str) -> TrackingSession:
        """
        Load tracking session by ID.

        Args:
            session_id: Session identifier

        Returns:
            TrackingSession loaded from file

        Raises:
            FileNotFoundError: If session doesn't exist
        """
        path = self.sessions_dir / f"{session_id}.yaml"

        if not path.exists():
            raise FileNotFoundError(f"Session not found: {session_id}")

        with open(path, "r", encoding="utf-8") as f:
            data_raw = f.read()

        if path.suffix.lower() in [".yaml", ".yml"]:
            if not yaml:
                raise RuntimeError("PyYAML not available. Install PyYAML.")
            data = yaml.safe_load(data_raw)
        else:
            import json
            data = json.loads(data_raw)

        return TrackingSession.from_dict(data)

    def load_from_path(self, path: Path) -> TrackingSession:
        """
        Load tracking session from specific path.

        Args:
            path: Path to session file

        Returns:
            TrackingSession loaded from file
        """
        path = Path(path)
        if not path.exists():
            raise FileNotFoundError(f"Session file not found: {path}")

        with open(path, "r", encoding="utf-8") as f:
            data_raw = f.read()

        if path.suffix.lower() in [".yaml", ".yml"]:
            if not yaml:
                raise RuntimeError("PyYAML not available. Install PyYAML.")
            data = yaml.safe_load(data_raw)
        else:
            import json
            data = json.loads(data_raw)

        return TrackingSession.from_dict(data)

    def list_sessions(self) -> List[str]:
        """
        List all available session IDs.

        Returns:
            Sorted list of session IDs
        """
        if not self.sessions_dir.exists():
            return []

        sessions = []
        for item in self.sessions_dir.iterdir():
            if item.is_file() and item.suffix.lower() in [".yaml", ".yml"]:
                sessions.append(item.stem)

        return sorted(sessions)

    def delete(self, session_id: str) -> bool:
        """
        Delete a tracking session.

        Args:
            session_id: Session identifier to delete

        Returns:
            True if deleted, False if not found
        """
        path = self.sessions_dir / f"{session_id}.yaml"
        if path.exists():
            path.unlink()
            return True
        return False

    def get_latest_session(self) -> Optional[TrackingSession]:
        """
        Get the most recently saved session.

        Returns:
            Latest TrackingSession or None if no sessions exist
        """
        sessions = self.list_sessions()
        if not sessions:
            return None

        # Load each and find latest by saved_at
        latest_session = None
        latest_time = None

        for session_id in sessions:
            try:
                session = self.load(session_id)
                # Check saved_at timestamp
                path = self.sessions_dir / f"{session_id}.yaml"
                mtime = path.stat().st_mtime
                if latest_time is None or mtime > latest_time:
                    latest_time = mtime
                    latest_session = session
            except Exception:
                continue

        return latest_session
```

3. Update lib/cinematic/tracking/__init__.py to export the session manager:
   - Add import: `from .session_manager import TrackingSessionManager`
   - Add to __all__: `"TrackingSessionManager"`
  </action>
  <verify>
python3 -c "
import os
from pathlib import Path

# Check directory structure exists
state_root = Path('.gsd-state/tracking')
assert state_root.exists(), 'tracking state root should exist'
assert (state_root / 'sessions').exists(), 'sessions dir should exist'
assert (state_root / 'solves').exists(), 'solves dir should exist'
assert (state_root / 'footage').exists(), 'footage dir should exist'

# Test session manager import and basic operations
from lib.cinematic.tracking import TrackingSessionManager, TrackingSession

manager = TrackingSessionManager()
session = TrackingSession(session_id='test_001', footage_path='/test/footage.mp4')
manager.save(session)

# Load it back
loaded = manager.load('test_001')
assert loaded.session_id == 'test_001', 'session_id should match'
assert loaded.footage_path == '/test/footage.mp4', 'footage_path should match'

# List sessions
sessions = manager.list_sessions()
assert 'test_001' in sessions, 'session should be in list'

# Cleanup
manager.delete('test_001')
print('TrackingSessionManager working correctly')
"
  </verify>
  <done>
- .gsd-state/tracking/ directory structure created with sessions/, solves/, footage/
- TrackingSessionManager class implemented following state_manager.py patterns
- Session save/load/delete operations work
- Session persistence integrated into tracking package exports
  </done>
</task>

</tasks>

<verification>
# Phase-level verification
1. All tracking types can be imported from lib.cinematic
2. All tracking functions can be imported from lib.cinematic.tracking
3. Version is 0.3.1
4. No import errors or circular dependencies
5. .gsd-state/tracking/ directory structure exists (sessions/, solves/, footage/)
6. TrackingSessionManager can save/load/delete sessions
</verification>

<success_criteria>
- lib/cinematic/tracking/__init__.py has complete exports
- lib/cinematic/__init__.py includes tracking section
- Version is 0.3.1
- All imports work from both packages
- TrackingSessionManager class available for session persistence
- State persistence directory structure in place
</success_criteria>

<output>
After completion, create `.planning/phases/07.0-tracking-foundation/07.0-05-SUMMARY.md`
</output>
