---
phase: 07.0-tracking-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/tracking/__init__.py
  - lib/cinematic/tracking/types.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tracking types can be serialized to/from dictionaries"
    - "TrackData captures marker positions per frame"
    - "SolveData contains camera animation data"
    - "FootageMetadata stores video file information"
    - "TrackingSession supports save/resume workflow"
  artifacts:
    - path: "lib/cinematic/tracking/types.py"
      provides: "Core tracking data structures"
      min_lines: 150
      exports: ["TrackData", "SolveData", "FootageMetadata", "TrackingSession", "SolveReport"]
    - path: "lib/cinematic/tracking/__init__.py"
      provides: "Package exports"
      contains: "TrackData"
  key_links:
    - from: "lib/cinematic/tracking/types.py"
      to: "lib/cinematic/types.py"
      via: "pattern: to_dict/from_dict methods"
      pattern: "def to_dict|from_dict"
---

<objective>
Create tracking module types following existing cinematic patterns.

Purpose: Establish type definitions for motion tracking system with YAML serialization support.
Output: types.py with TrackData, SolveData, FootageMetadata, TrackingSession, SolveReport dataclasses.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.0-tracking-foundation/07.0-RESEARCH.md

# Reference existing patterns
@lib/cinematic/types.py
@lib/cinematic/state_manager.py
</context>

<tasks>

<task type="auto">
  <name>Create tracking module types.py</name>
  <files>lib/cinematic/tracking/types.py</files>
  <action>
Create tracking types following the existing cinematic system patterns.

1. Create the tracking directory: lib/cinematic/tracking/

2. Create types.py with these dataclasses (each with to_dict() and from_dict() methods):

@dataclass
class TrackData:
    """Single track point data for feature tracking."""
    name: str = ""
    pattern_area: Tuple[int, int, int, int] = (0, 0, 31, 31)  # x, y, width, height
    search_area: Tuple[int, int, int, int] = (0, 0, 61, 61)
    markers: Dict[int, Tuple[float, float]] = field(default_factory=dict)  # frame -> (x, y) normalized 0-1
    enabled: bool = True
    color: Tuple[float, float, float] = (1.0, 0.0, 0.0)
    correlation: float = 1.0  # Track quality 0-1
    track_type: str = "point"  # point, plane, object

@dataclass
class SolveData:
    """Camera solve data with per-frame animation."""
    name: str = ""
    frame_range: Tuple[int, int] = (1, 100)
    focal_length: float = 50.0
    sensor_width: float = 36.0
    # Per-frame data: frame -> (tx, ty, tz, rx, ry, rz)
    camera_transforms: Dict[int, Tuple[float, float, float, float, float, float]] = field(default_factory=dict)
    coordinate_system: str = "z_up"  # z_up (Blender) or y_up (FBX/Nuke)
    solved_at: str = ""

@dataclass
class SolveReport:
    """Camera solve quality report."""
    reprojection_error_avg: float = 0.0  # Pixels
    reprojection_error_max: float = 0.0
    tracks_used: int = 0
    frames_solved: int = 0
    confidence_score: float = 0.0  # 0-1
    quality_level: str = "unknown"  # excellent, good, acceptable, poor

@dataclass
class FootageMetadata:
    """Extracted video metadata from ffprobe analysis."""
    filename: str = ""
    resolution: Tuple[int, int] = (1920, 1080)
    frame_rate: float = 24.0
    duration_frames: int = 0
    duration_seconds: float = 0.0
    codec: str = ""
    bit_depth: int = 8
    color_space: str = ""
    # Device metadata (if available from QuickTime tags)
    camera_model: str = ""
    focal_length: float = 0.0
    iso: int = 0
    # Content analysis results
    motion_blur_level: str = "unknown"  # low, medium, high
    rolling_shutter_detected: bool = False

@dataclass
class TrackingSession:
    """Tracking session state for resume capability."""
    session_id: str = ""
    footage_path: str = ""
    frame_start: int = 1
    frame_end: int = 100
    current_frame: int = 1
    tracks: List[TrackData] = field(default_factory=list)
    camera_profile: str = ""
    preset: str = "balanced"
    status: str = "in_progress"  # in_progress, complete, error
    created_at: str = ""
    updated_at: str = ""

3. Follow exact patterns from lib/cinematic/types.py:
   - Use dataclasses with field(default_factory=...) for mutable defaults
   - Implement to_dict() returning Dict[str, Any]
   - Implement from_dict(cls, data: Dict[str, Any]) classmethod
   - Convert tuples to lists in to_dict(), convert back in from_dict()
   - Handle nested dataclasses by calling their from_dict() methods

4. Add type hints and docstrings following existing style.
  </action>
  <verify>
python3 -c "
from lib.cinematic.tracking.types import TrackData, SolveData, FootageMetadata, TrackingSession, SolveReport

# Test instantiation
t = TrackData(name='test')
assert t.name == 'test'
assert t.to_dict()['name'] == 'test'
assert TrackData.from_dict({'name': 'restored'}).name == 'restored'

# Test nested serialization
session = TrackingSession(session_id='test', tracks=[TrackData(name='track1')])
data = session.to_dict()
restored = TrackingSession.from_dict(data)
assert restored.tracks[0].name == 'track1'

print('All type tests passed')
"
  </verify>
  <done>
- TrackData, SolveData, FootageMetadata, TrackingSession, SolveReport dataclasses created
- Each has to_dict() and from_dict() methods
- Nested serialization works (TrackingSession.tracks -> List[TrackData])
  </done>
</task>

<task type="auto">
  <name>Create tracking package __init__.py</name>
  <files>lib/cinematic/tracking/__init__.py</files>
  <action>
Create the tracking package __init__.py with exports and version.

Include:
1. Module docstring describing the tracking package
2. BLENDER_AVAILABLE flag (try import bpy, except ImportError)
3. Export all types from types.py
4. __all__ list with all exports
5. __version__ = "0.1.0"

Follow the pattern from lib/cinematic/__init__.py for structure.
  </action>
  <verify>
python3 -c "
from lib.cinematic.tracking import TrackData, SolveData, FootageMetadata, TrackingSession, SolveReport, BLENDER_AVAILABLE
print(f'BLENDER_AVAILABLE: {BLENDER_AVAILABLE}')
print('Tracking package imports work')
"
  </verify>
  <done>
- Package imports work
- All types are accessible from lib.cinematic.tracking
- BLENDER_AVAILABLE flag is defined
  </done>
</task>

</tasks>

<verification>
# Phase-level verification
1. All types can be instantiated with defaults
2. All types serialize/deserialize correctly via to_dict/from_dict
3. Nested types (TrackingSession containing List[TrackData]) work
4. Package imports cleanly
</verification>

<success_criteria>
- lib/cinematic/tracking/types.py exists with 5 dataclasses
- Each dataclass has to_dict() and from_dict() methods
- lib/cinematic/tracking/__init__.py exports all types
- Python import tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07.0-tracking-foundation/07.0-01-SUMMARY.md`
</output>
