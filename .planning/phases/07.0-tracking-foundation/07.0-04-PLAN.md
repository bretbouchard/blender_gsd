---
phase: 07.0-tracking-foundation
plan: 04
type: execute
wave: 2
depends_on: ["07.0-01"]
files_modified:
  - lib/cinematic/tracking/import_export.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "External tracking data can be imported from FBX and .chan formats"
    - "Coordinate conversion from Y-up to Z-up works correctly"
    - "Imported data produces SolveData with camera transforms"
    - "Nuke .chan format is correctly parsed"
  artifacts:
    - path: "lib/cinematic/tracking/import_export.py"
      provides: "External tracking import/export"
      min_lines: 150
      exports: ["import_nuke_chan", "convert_yup_to_zup_position", "import_tracking_data", "fov_to_focal_length"]
  key_links:
    - from: "lib/cinematic/tracking/import_export.py"
      to: "lib/cinematic/tracking/types.py"
      via: "SolveData type"
      pattern: "from .types import SolveData"
---

<objective>
Create import/export module for external tracking data.

Purpose: Implement coordinate conversion and format-specific importers for external tracking data.
Output: import_export.py with Nuke .chan import, coordinate conversion utilities.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.0-tracking-foundation/07.0-RESEARCH.md
@.planning/REQUIREMENTS_TRACKING.md

# Reference types from Plan 01
@lib/cinematic/tracking/types.py

# Reference config from Plan 02
@configs/cinematic/tracking/import_formats.yaml
</context>

<tasks>

<task type="auto">
  <name>Create import_export.py with coordinate conversion</name>
  <files>lib/cinematic/tracking/import_export.py</files>
  <action>
Create the import/export module following research patterns.

1. Coordinate Conversion Functions (from RESEARCH.md):

def convert_yup_to_zup_position(x: float, y: float, z: float) -> Tuple[float, float, float]:
    """
    Convert position from Y-up to Z-up coordinate system.

    Y-up (FBX/Nuke):    Z-up (Blender):
    X -> right          X -> right
    Z -> up             Z -> up
    Y -> forward        Y -> forward (negative)

    Matrix: 90-degree rotation around X-axis
    """
    return (x, z, -y)


def convert_yup_to_zup_rotation(rx: float, ry: float, rz: float) -> Tuple[float, float, float]:
    """
    Convert Euler rotation from Y-up to Z-up.
    Args are in degrees. Returns degrees.
    """
    # Simplified for common cases
    return (rx, ry - 90, rz)


def fov_to_focal_length(fov_degrees: float, sensor_width: float = 36.0) -> float:
    """
    Convert field of view to focal length.
    """
    import math
    fov_rad = math.radians(fov_degrees)
    return sensor_width / (2 * math.tan(fov_rad / 2))

2. Nuke .chan Import (from RESEARCH.md):

def import_nuke_chan(chan_path: str, frame_offset: int = 0,
                     scale_factor: float = 1.0,
                     coordinate_system: str = "y_up") -> SolveData:
    """
    Import camera data from Nuke .chan file.

    Format: frame tx ty tz rx ry rz [fov]
    """
    from pathlib import Path
    from datetime import datetime
    from .types import SolveData

    frames_data = {}
    path = Path(chan_path)

    with open(path, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            parts = line.split()
            if len(parts) < 7:
                continue

            frame = int(float(parts[0])) + frame_offset
            tx, ty, tz = float(parts[1]), float(parts[2]), float(parts[3])
            rx, ry, rz = float(parts[4]), float(parts[5]), float(parts[6])
            fov = float(parts[7]) if len(parts) > 7 else 45.0

            # Coordinate conversion (Y-up to Z-up)
            if coordinate_system == "y_up":
                tx, ty, tz = convert_yup_to_zup_position(tx, ty, tz)

            # Apply scale
            tx *= scale_factor
            ty *= scale_factor
            tz *= scale_factor

            frames_data[frame] = (tx, ty, tz, rx, ry, rz)

    # Determine frame range
    if frames_data:
        frame_nums = sorted(frames_data.keys())
        frame_range = (frame_nums[0], frame_nums[-1])
    else:
        frame_range = (1, 100)

    return SolveData(
        name=path.stem,
        frame_range=frame_range,
        camera_transforms=frames_data,
        coordinate_system="z_up",  # Converted
        solved_at=datetime.utcnow().isoformat()
    )

3. Generic import_tracking_data function:

def import_tracking_data(file_path: str, format: str = "auto", **kwargs) -> SolveData:
    """
    Import tracking data from various formats.

    Args:
        file_path: Path to tracking file
        format: Format type (nuke_chan, fbx, auto)
        **kwargs: Format-specific options

    Returns:
        SolveData with imported camera transforms
    """
    from pathlib import Path

    path = Path(file_path)

    if format == "auto":
        suffix = path.suffix.lower()
        if suffix == ".chan":
            format = "nuke_chan"
        else:
            raise ValueError(f"Unknown format for: {suffix}")

    if format == "nuke_chan":
        return import_nuke_chan(file_path, **kwargs)
    else:
        raise ValueError(f"Unsupported format: {format}")

4. Add docstrings and type hints following existing patterns.
  </action>
  <verify>
python3 -c "
from lib.cinematic.tracking.import_export import (
    convert_yup_to_zup_position,
    convert_yup_to_zup_rotation,
    fov_to_focal_length,
    import_nuke_chan,
    import_tracking_data
)

# Test coordinate conversion
pos = convert_yup_to_zup_position(1.0, 2.0, 3.0)
assert pos == (1.0, 3.0, -2.0), f'Got {pos}'

# Test FOV to focal length
focal = fov_to_focal_length(45.0, 36.0)
assert 40 < focal < 45, f'Got {focal}'

print('Import/export coordinate conversion works')
"
  </verify>
  <done>
- import_export.py exists with coordinate conversion functions
- convert_yup_to_zup_position() correctly converts coordinates
- fov_to_focal_length() converts FOV to focal length
- import_nuke_chan() parses Nuke .chan format
- import_tracking_data() provides unified interface
  </done>
</task>

</tasks>

<verification>
# Phase-level verification
1. import_export.py imports without errors
2. Coordinate conversion (Y-up to Z-up) works correctly: (x, y, z) -> (x, z, -y)
3. FOV to focal length conversion works
4. Nuke .chan parsing produces SolveData
</verification>

<success_criteria>
- lib/cinematic/tracking/import_export.py exists
- convert_yup_to_zup_position() implemented and tested
- fov_to_focal_length() implemented and tested
- import_nuke_chan() implemented
- import_tracking_data() unified interface implemented
</success_criteria>

<output>
After completion, create `.planning/phases/07.0-tracking-foundation/07.0-04-SUMMARY.md`
</output>
