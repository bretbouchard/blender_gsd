# Phase 13.4: Face Animation

**Goal**: Animate facial expressions and lip sync.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-06)

**Depends On**: Phase 13.0 (Rigging)

**Duration**: 4-5 days

---

## Overview

Build a face animation system that supports:
- Face rig template
- Shape keys for expressions
- Viseme library (lip sync)
- Expression presets
- Audio-driven lip sync

**Philosophy**: Face animation is emotion + speech. Blend shapes drive both.

---

## Architecture

```
lib/animation/
├── face_rig.py            # Face rig builder
├── shape_keys.py          # Shape key management
├── expressions.py         # Expression presets
├── visemes.py             # Lip sync visemes
├── lip_sync.py            # Audio-driven lip sync

configs/animation/
├── face/
│   ├── face_rig.yaml      # Face rig template
│   ├── expressions.yaml   # Expression presets
│   └── visemes.yaml       # Viseme definitions

.gsd-state/
└── face/
    └── lip_sync/
        └── {audio_file}/
            └── timing.yaml
```

---

## Data Model

### Face Rig
```yaml
# configs/animation/face/face_rig.yaml
id: face_standard
name: "Standard Face Rig"

bone_groups:
  eyes:
    - eye_L
    - eye_R
    - eyelid_up_L
    - eyelid_up_R
    - eyelid_lo_L
    - eyelid_lo_R
    - eyebrow_in_L
    - eyebrow_in_R
    - eyebrow_mid_L
    - eyebrow_mid_R
    - eyebrow_out_L
    - eyebrow_out_R

  mouth:
    - jaw
    - lip_up
    - lip_lo
    - lip_L
    - lip_R
    - corner_L
    - corner_R

  nose:
    - nose
    - nostril_L
    - nostril_R

  cheeks:
    - cheek_L
    - cheek_R

bones:
  - id: eye_L
    parent: head
    head: [0.033, 0.08, 1.2]
    tail: [0.033, 0.12, 1.2]

  - id: eyelid_up_L
    parent: eye_L
    head: [0.033, 0.09, 1.21]
    tail: [0.033, 0.11, 1.22]

  # ... more bones
```

### Expressions
```yaml
# configs/animation/face/expressions.yaml
expressions:
  neutral:
    name: "Neutral"
    shape_keys: {}

  happy:
    name: "Happy"
    shape_keys:
      smile: 1.0
      cheek_raise: 0.5
      eye_squint: 0.3

  sad:
    name: "Sad"
    shape_keys:
      frown: 0.8
      eyebrow_down: 0.6
      tear_line: 0.3

  angry:
    name: "Angry"
    shape_keys:
      brow_furrow: 1.0
      frown: 0.7
      nostril_flare: 0.5

  surprised:
    name: "Surprised"
    shape_keys:
      eyebrow_up: 1.0
      eye_wide: 0.8
      mouth_open: 0.6

  scared:
    name: "Scared"
    shape_keys:
      eyebrow_up: 0.8
      eye_wide: 1.0
      mouth_open: 0.4
      fear_tension: 0.5
```

### Visemes
```yaml
# configs/animation/face/visemes.yaml
visemes:
  rest:
    name: "Rest"
    shape_keys: {}

  A:
    name: "A (ah, ay)"
    shape_keys:
      jaw_open: 0.7
      lip_spread: 0.5
      tongue_up: 0.2

  E:
    name: "E (ee, eh)"
    shape_keys:
      jaw_open: 0.3
      lip_spread: 1.0
      tongue_up: 0.4

  I:
    name: "I (ih, ee)"
    shape_keys:
      jaw_open: 0.2
      lip_spread: 0.8
      tongue_up: 0.5

  O:
    name: "O (oh, oo)"
    shape_keys:
      jaw_open: 0.5
      lip_round: 1.0
      tongue_back: 0.3

  U:
    name: "U (oo)"
    shape_keys:
      jaw_open: 0.3
      lip_round: 1.0
      lip_pucker: 0.7

  M:
    name: "M, B, P"
    shape_keys:
      lip_close: 1.0

  F:
    name: "F, V"
    shape_keys:
      jaw_open: 0.1
      teeth_lower_lip: 0.8

  TH:
    name: "TH"
    shape_keys:
      jaw_open: 0.2
      tongue_between_teeth: 0.8

  L:
    name: "L"
    shape_keys:
      jaw_open: 0.3
      tongue_up: 1.0
      tongue_tip_alveolar: 0.8

  W:
    name: "W"
    shape_keys:
      lip_round: 1.0
      lip_pucker: 0.8

  CH:
    name: "CH, SH, J"
    shape_keys:
      jaw_open: 0.2
      lip_round: 0.5
      tongue_up: 0.6
```

### Types
```python
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional

@dataclass
class ShapeKeyConfig:
    name: str
    min_value: float = 0.0
    max_value: float = 1.0
    category: str = "custom"

@dataclass
class Expression:
    name: str
    shape_keys: Dict[str, float]
    category: str = "custom"
    description: str = ""

@dataclass
class Viseme:
    name: str
    phonemes: List[str]
    shape_keys: Dict[str, float]

@dataclass
class LipSyncKey:
    frame: int
    viseme: str
    intensity: float = 1.0

@dataclass
class LipSyncData:
    audio_file: str
    keys: List[LipSyncKey]
    words: List[Dict] = field(default_factory=list)
```

---

## Tasks

### Task 1: Face Rig Builder
**File**: `lib/animation/face_rig.py`

```python
import bpy
from typing import Dict, List, Optional
from pathlib import Path
import yaml

FACE_CONFIG_ROOT = Path(__file__).parent.parent.parent / "configs" / "animation" / "face"

class FaceRigBuilder:
    """Build face rigs from templates."""

    @staticmethod
    def build_face_rig(name: str = "face_rig", scale: float = 1.0) -> bpy.types.Object:
        """Build a standard face rig."""
        # Create armature
        armature_data = bpy.data.armatures.new(name)
        armature = bpy.data.objects.new(name, armature_data)
        bpy.context.collection.objects.link(armature)

        bpy.context.view_layer.objects.active = armature
        bpy.ops.object.mode_set(mode='EDIT')

        # Load config
        config = FaceRigBuilder._load_config()

        # Add bones
        for bone_config in config.get('bones', []):
            FaceRigBuilder._add_bone(armature, bone_config, scale)

        bpy.ops.object.mode_set(mode='OBJECT')

        return armature

    @staticmethod
    def _load_config() -> dict:
        """Load face rig config."""
        config_path = FACE_CONFIG_ROOT / "face_rig.yaml"
        if config_path.exists():
            with open(config_path) as f:
                return yaml.safe_load(f)
        return {'bones': []}

    @staticmethod
    def _add_bone(armature: bpy.types.Object, config: dict, scale: float) -> None:
        """Add a bone to the face rig."""
        bone = armature.data.edit_bones.new(config['id'])

        head = config.get('head', [0, 0, 0])
        tail = config.get('tail', [0, 0, 0])

        bone.head = [h * scale for h in head]
        bone.tail = [t * scale for t in tail]

        if config.get('parent') and config['parent'] in armature.data.edit_bones:
            bone.parent = armature.data.edit_bones[config['parent']]

    @staticmethod
    def attach_to_head(face_rig: bpy.types.Object, head_rig: bpy.types.Object, head_bone: str = "head") -> None:
        """Attach face rig to head bone of body rig."""
        # Parent face rig to head
        face_rig.parent = head_rig
        face_rig.parent_type = 'BONE'
        face_rig.parent_bone = head_bone


def create_face_rig(name: str = "face_rig") -> bpy.types.Object:
    """Convenience function to create face rig."""
    return FaceRigBuilder.build_face_rig(name)
```

**Acceptance**: Can build face rig

---

### Task 2: Shape Key Manager
**File**: `lib/animation/shape_keys.py`

```python
import bpy
from typing import Dict, List, Optional

class ShapeKeyManager:
    """Manage shape keys for facial animation."""

    @staticmethod
    def create_shape_key(mesh: bpy.types.Object, name: str, from_mix: bool = False) -> bpy.types.ShapeKey:
        """Create a new shape key."""
        if not mesh.data.shape_keys:
            mesh.shape_key_add(name='Basis')

        sk = mesh.shape_key_add(name=name, from_mix=from_mix)
        return sk

    @staticmethod
    def get_shape_key(mesh: bpy.types.Object, name: str) -> Optional[bpy.types.ShapeKey]:
        """Get a shape key by name."""
        if not mesh.data.shape_keys:
            return None
        return mesh.data.shape_keys.key_blocks.get(name)

    @staticmethod
    def set_shape_key_value(mesh: bpy.types.Object, name: str, value: float) -> None:
        """Set shape key value."""
        sk = ShapeKeyManager.get_shape_key(mesh, name)
        if sk:
            sk.value = max(0, min(1, value))

    @staticmethod
    def get_shape_key_value(mesh: bpy.types.Object, name: str) -> float:
        """Get shape key value."""
        sk = ShapeKeyManager.get_shape_key(mesh, name)
        return sk.value if sk else 0.0

    @staticmethod
    def apply_expression(mesh: bpy.types.Object, expression: Dict[str, float], blend: float = 1.0) -> None:
        """Apply an expression (dict of shape key values)."""
        for sk_name, value in expression.items():
            current = ShapeKeyManager.get_shape_key_value(mesh, sk_name)
            new_value = current * (1 - blend) + value * blend
            ShapeKeyManager.set_shape_key_value(mesh, sk_name, new_value)

    @staticmethod
    def reset_all(mesh: bpy.types.Object) -> None:
        """Reset all shape keys to 0."""
        if not mesh.data.shape_keys:
            return

        for sk in mesh.data.shape_keys.key_blocks:
            if sk.name != 'Basis':
                sk.value = 0.0

    @staticmethod
    def get_all_values(mesh: bpy.types.Object) -> Dict[str, float]:
        """Get all shape key values."""
        if not mesh.data.shape_keys:
            return {}

        return {sk.name: sk.value for sk in mesh.data.shape_keys.key_blocks if sk.name != 'Basis'}

    @staticmethod
    def keyframe_all(mesh: bpy.types.Object, frame: int) -> None:
        """Keyframe all shape keys at frame."""
        if not mesh.data.shape_keys:
            return

        for sk in mesh.data.shape_keys.key_blocks:
            sk.keyframe_insert(data_path="value", frame=frame)


def create_standard_face_shape_keys(mesh: bpy.types.Object) -> List[str]:
    """Create standard facial shape keys."""
    standard_keys = [
        # Eyes
        "blink_L", "blink_R", "eye_wide_L", "eye_wide_R",
        "eyebrow_up_L", "eyebrow_up_R", "eyebrow_down_L", "eyebrow_down_R",
        "brow_furrow",

        # Mouth
        "smile", "frown", "lip_up", "lip_lo",
        "corner_L", "corner_R", "jaw_open", "lip_round", "lip_pucker",
        "lip_spread", "lip_close",

        # Cheeks/Nose
        "cheek_raise_L", "cheek_raise_R",
        "nostril_flare_L", "nostril_flare_R",

        # Expressions
        "sneer", "puff_cheeks", "tongue_out"
    ]

    created = []
    for name in standard_keys:
        if not ShapeKeyManager.get_shape_key(mesh, name):
            ShapeKeyManager.create_shape_key(mesh, name)
            created.append(name)

    return created
```

**Acceptance**: Can create and manage shape keys

---

### Task 3: Expression System
**File**: `lib/animation/expressions.py`

```python
import bpy
import yaml
from pathlib import Path
from typing import Dict, List, Optional
from .shape_keys import ShapeKeyManager

EXPRESSION_CONFIG_PATH = Path(__file__).parent.parent.parent / "configs" / "animation" / "face" / "expressions.yaml"

class ExpressionManager:
    """Manage facial expressions."""

    def __init__(self):
        self.expressions: Dict[str, Dict] = {}
        self._load_expressions()

    def _load_expressions(self) -> None:
        """Load expressions from config."""
        if EXPRESSION_CONFIG_PATH.exists():
            with open(EXPRESSION_CONFIG_PATH) as f:
                data = yaml.safe_load(f)
                self.expressions = data.get('expressions', {})

    def apply(self, mesh: bpy.types.Object, expression_name: str, blend: float = 1.0) -> None:
        """Apply an expression by name."""
        if expression_name not in self.expressions:
            print(f"Expression not found: {expression_name}")
            return

        expr = self.expressions[expression_name]
        shape_keys = expr.get('shape_keys', {})

        ShapeKeyManager.apply_expression(mesh, shape_keys, blend)

    def blend_expressions(
        self,
        mesh: bpy.types.Object,
        expressions: List[tuple]  # [(name, weight), ...]
    ) -> None:
        """Blend multiple expressions."""
        # Collect blended shape key values
        blended: Dict[str, float] = {}
        total_weight = sum(w for _, w in expressions)

        for name, weight in expressions:
            if name not in self.expressions:
                continue

            normalized = weight / total_weight if total_weight > 0 else 0
            for sk_name, value in self.expressions[name].get('shape_keys', {}).items():
                if sk_name not in blended:
                    blended[sk_name] = 0
                blended[sk_name] += value * normalized

        ShapeKeyManager.apply_expression(mesh, blended)

    def get_expression_names(self) -> List[str]:
        """Get all expression names."""
        return list(self.expressions.keys())

    def save_expression(self, mesh: bpy.types.Object, name: str, category: str = "custom") -> None:
        """Save current face state as expression."""
        values = ShapeKeyManager.get_all_values(mesh)

        self.expressions[name] = {
            'name': name,
            'shape_keys': values,
            'category': category
        }

        # Save to file
        self._save_expressions()

    def _save_expressions(self) -> None:
        """Save expressions to config file."""
        EXPRESSION_CONFIG_PATH.parent.mkdir(parents=True, exist_ok=True)

        data = {'expressions': self.expressions}
        with open(EXPRESSION_CONFIG_PATH, 'w') as f:
            yaml.dump(data, f, default_flow_style=False)


def apply_expression(mesh: bpy.types.Object, name: str, blend: float = 1.0) -> None:
    """Convenience function to apply expression."""
    manager = ExpressionManager()
    manager.apply(mesh, name, blend)
```

**Acceptance**: Can apply and blend expressions

---

### Task 4: Viseme System
**File**: `lib/animation/visemes.py`

```python
import bpy
import yaml
from pathlib import Path
from typing import Dict, List, Optional
from .shape_keys import ShapeKeyManager

VISEME_CONFIG_PATH = Path(__file__).parent.parent.parent / "configs" / "animation" / "face" / "visemes.yaml"

# Phoneme to viseme mapping
PHONEME_TO_VISEME = {
    # Vowels
    'AA': 'A', 'AE': 'A', 'AH': 'A', 'AO': 'O', 'AW': 'O',
    'AY': 'A', 'EH': 'E', 'ER': 'E', 'EY': 'E', 'IH': 'I',
    'IY': 'I', 'OW': 'O', 'OY': 'O', 'UH': 'U', 'UW': 'U',

    # Consonants - Bilabial
    'P': 'M', 'B': 'M', 'M': 'M',

    # Labiodental
    'F': 'F', 'V': 'F',

    # Dental
    'TH': 'TH', 'DH': 'TH',

    # Alveolar
    'T': 'L', 'D': 'L', 'N': 'L', 'L': 'L', 'S': 'CH', 'Z': 'CH',

    # Palatal
    'SH': 'CH', 'ZH': 'CH', 'CH': 'CH', 'JH': 'CH', 'Y': 'I',

    # Velar
    'K': 'L', 'G': 'L', 'NG': 'L',

    # Glottal
    'HH': 'A', 'H': 'A',

    # Labial-velar
    'W': 'W',

    # R-colored
    'R': 'W',
}

class VisemeManager:
    """Manage visemes for lip sync."""

    def __init__(self):
        self.visemes: Dict[str, Dict] = {}
        self._load_visemes()

    def _load_visemes(self) -> None:
        """Load visemes from config."""
        if VISEME_CONFIG_PATH.exists():
            with open(VISEME_CONFIG_PATH) as f:
                data = yaml.safe_load(f)
                self.visemes = data.get('visemes', {})

    def apply_viseme(self, mesh: bpy.types.Object, viseme_name: str, intensity: float = 1.0) -> None:
        """Apply a viseme."""
        if viseme_name not in self.visemes:
            return

        viseme = self.visemes[viseme_name]
        shape_keys = viseme.get('shape_keys', {})

        # Scale by intensity
        scaled = {k: v * intensity for k, v in shape_keys.items()}
        ShapeKeyManager.apply_expression(mesh, scaled)

    def get_viseme_for_phoneme(self, phoneme: str) -> str:
        """Get viseme for a phoneme."""
        return PHONEME_TO_VISEME.get(phoneme.upper(), 'rest')

    def get_viseme_names(self) -> List[str]:
        """Get all viseme names."""
        return list(self.visemes.keys())


def apply_viseme(mesh: bpy.types.Object, name: str, intensity: float = 1.0) -> None:
    """Convenience function to apply viseme."""
    manager = VisemeManager()
    manager.apply_viseme(mesh, name, intensity)
```

**Acceptance**: Can apply visemes

---

### Task 5: Lip Sync System
**File**: `lib/animation/lip_sync.py`

```python
import bpy
import json
from pathlib import Path
from typing import List, Dict, Optional
from .visemes import VisemeManager, PHONEME_TO_VISEME
from .shape_keys import ShapeKeyManager

class LipSyncGenerator:
    """Generate lip sync from audio analysis."""

    def __init__(self, mesh: bpy.types.Object):
        self.mesh = mesh
        self.viseme_manager = VisemeManager()

    def generate_from_phonemes(
        self,
        phoneme_data: List[Dict],  # [{'phoneme': 'AA', 'start': 0.0, 'end': 0.1}, ...]
        fps: float = 24.0
    ) -> List[Dict]:
        """Generate lip sync keyframes from phoneme timing data."""
        keys = []

        for phoneme_info in phoneme_data:
            phoneme = phoneme_info['phoneme']
            start_frame = int(phoneme_info['start'] * fps)
            end_frame = int(phoneme_info['end'] * fps)

            viseme = self.viseme_manager.get_viseme_for_phoneme(phoneme)

            keys.append({
                'frame': start_frame,
                'viseme': viseme,
                'intensity': 1.0,
                'type': 'start'
            })

            # Add transition to rest at end
            keys.append({
                'frame': end_frame,
                'viseme': 'rest',
                'intensity': 0.5,
                'type': 'end'
            })

        # Sort by frame
        keys.sort(key=lambda x: x['frame'])

        return keys

    def apply_to_animation(self, lip_sync_keys: List[Dict]) -> None:
        """Apply lip sync keys to animation."""
        for key in lip_sync_keys:
            frame = key['frame']
            viseme = key['viseme']
            intensity = key.get('intensity', 1.0)

            bpy.context.scene.frame_set(frame)
            self.viseme_manager.apply_viseme(self.mesh, viseme, intensity)
            ShapeKeyManager.keyframe_all(self.mesh, frame)

    def generate_from_text(
        self,
        text: str,
        start_frame: int = 1,
        words_per_second: float = 2.5,
        fps: float = 24.0
    ) -> List[Dict]:
        """Simple text-based lip sync (no audio analysis)."""
        # Very simplified - just creates random mouth movement
        import random

        keys = []
        current_frame = start_frame
        frames_per_syllable = int(fps / (words_per_second * 2))

        visemes = self.viseme_manager.get_viseme_names()
        visemes = [v for v in visemes if v != 'rest']

        for word in text.split():
            syllable_count = max(1, len(word) // 3)

            for _ in range(syllable_count):
                viseme = random.choice(visemes)

                keys.append({
                    'frame': current_frame,
                    'viseme': viseme,
                    'intensity': random.uniform(0.6, 1.0)
                })

                # Rest between syllables
                keys.append({
                    'frame': current_frame + frames_per_syllable // 2,
                    'viseme': 'rest',
                    'intensity': 0.3
                })

                current_frame += frames_per_syllable

            # Pause between words
            current_frame += int(frames_per_syllable * 0.5)

        return keys

    def import_from_rhubarb(self, json_path: str, fps: float = 24.0) -> List[Dict]:
        """Import lip sync from Rhubarb JSON output."""
        with open(json_path) as f:
            data = json.load(f)

        keys = []
        mouth_cues = data.get('mouthCues', [])

        for cue in mouth_cues:
            frame = int(cue['start'] * fps)
            viseme = cue['value']

            keys.append({
                'frame': frame,
                'viseme': viseme,
                'intensity': 1.0
            })

        return keys


def create_lip_sync(mesh: bpy.types.Object, text: str, start_frame: int = 1) -> None:
    """Convenience function to create lip sync from text."""
    generator = LipSyncGenerator(mesh)
    keys = generator.generate_from_text(text, start_frame)
    generator.apply_to_animation(keys)
```

**Acceptance**: Can generate lip sync

---

## Acceptance Criteria

### Must Have
- [ ] Face rig template
- [ ] Shape key creation/management
- [ ] Expression presets (happy, sad, angry, etc)
- [ ] Viseme definitions
- [ ] Apply visemes to mesh

### Nice to Have
- [ ] Audio analysis integration
- [ ] Text-to-lip-sync
- [ ] Rhubarb import
- [ ] Expression blending

---

## Commands

```python
# Create face rig
from lib.animation import create_face_rig
face_rig = create_face_rig("hero_face")

# Apply expression
from lib.animation import apply_expression
apply_expression(face_mesh, "happy", blend=0.8)

# Apply viseme
from lib.animation import apply_viseme
apply_viseme(face_mesh, "A", intensity=0.7)

# Create lip sync
from lib.animation import create_lip_sync
create_lip_sync(face_mesh, "Hello world", start_frame=1)
```

---

## AI Commands Reference

```
# Create face rig
"Create a face rig for the hero character"

# Apply expression
"Make the character happy"

# Apply viseme
"Shape the mouth for 'A' sound"

# Create lip sync
"Create lip sync for 'Hello world' starting at frame 1"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Render Rick - Performance Considerations

1. **Shape Key Count Warning**
   - Standard set includes 30+ shape keys
   - Risk: Performance impact with many drivers/animated shape keys
   - Recommendation: Document optimal shape key count for real-time playback

2. **Viseme Interpolation**
   - Direct shape key application without smoothing
   - Risk: Jerky lip sync transitions
   - Recommendation: Add interpolation time parameter for smooth viseme blending

### Automation Rick - Audio Integration

3. **Lip Sync Text-Based Fallback**
   - `generate_from_text()` uses random visemes - very inaccurate
   - Risk: Users may not realize this is a placeholder
   - Recommendation: Add warning log when using text-based generation

4. **Rhubarb Import Assumptions**
   - Expects specific JSON format without version checking
   - Risk: Breaking changes in Rhubarb output format
   - Recommendation: Add format version validation

### Dufus Rick - Testing Recommendations

5. **Test Tasks to Add**
   - Task: Verify expression blending with conflicting shape keys
   - Task: Test viseme intensity at 0.0 and 1.0 boundaries
   - Task: Test lip sync with empty phoneme list
   - Task: Verify face rig attachment to non-standard head bones
   - Task: Test expression save/load cycle preserves all shape keys

6. **Edge Cases to Document**
   - Behavior when shape key referenced in expression doesn't exist
   - Maximum supported shape key count
   - Rhubarb import version compatibility
