---
phase: 07.1-core-tracking
plan: 01
type: execute
wave: 1
depends_on: ["07.0"]
files_modified:
  - lib/cinematic/tracking/context.py
  - lib/cinematic/tracking/presets.py
  - configs/cinematic/tracking/tracking_presets.yaml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tracking operators can be called with proper Blender context"
    - "Context manager ensures Clip Editor area is available"
    - "Tracking presets configure detection and tracking parameters"
    - "All presets can be loaded from YAML"
  artifacts:
    - path: "lib/cinematic/tracking/context.py"
      provides: "Context manager for tracking operators"
      min_lines: 100
      contains: "def tracking_context"
    - path: "lib/cinematic/tracking/presets.py"
      provides: "Tracking preset loader and parameter application"
      min_lines: 80
      contains: "get_tracking_preset"
    - path: "configs/cinematic/tracking/tracking_presets.yaml"
      provides: "Tracking preset configurations"
      contains: "presets:"
  key_links:
    - from: "lib/cinematic/tracking/context.py"
      to: "bpy.context"
      via: "Clip Editor area setup"
      pattern: "CLIP_EDITOR"
    - from: "lib/cinematic/tracking/presets.py"
      to: "configs/cinematic/tracking/tracking_presets.yaml"
      via: "YAML load"
      pattern: "load_preset|yaml"
---

<objective>
Create context management for Blender tracking operators and extend preset support.

Purpose: Enable reliable execution of bpy.ops.clip.* operators through proper context setup, and provide tracking preset configurations for feature detection and tracking.
Output: context.py with tracking_context manager, presets.py with tracking preset loader, updated tracking_presets.yaml with detection parameters.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.1-core-tracking/07.1-RESEARCH.md

# Reference existing tracking foundation (Phase 7.0)
@.planning/phases/07.0-tracking-foundation/07.0-01-PLAN.md

# Reference existing cinematic patterns
@lib/cinematic/preset_loader.py
@lib/cinematic/tracking/types.py
</context>

<tasks>

<task type="auto">
  <name>Create tracking context manager</name>
  <files>lib/cinematic/tracking/context.py</files>
  <action>
Create context.py with a context manager that ensures proper Blender context for tracking operators.

Most bpy.ops.clip.* operators require an active Movie Clip Editor area with a loaded clip. This module provides a robust context manager pattern.

Key implementation requirements:

1. Create tracking_context(clip) context manager that:
   - Finds or creates a Clip Editor area
   - Sets the active clip
   - Provides context override for operators
   - Handles edge cases (headless mode, no screen)

2. Key patterns from research:
```python
from contextlib import contextmanager
from typing import Dict, Any, Optional, Generator

try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False


@contextmanager
def tracking_context(clip) -> Generator[Dict[str, Any], None, None]:
    """
    Context manager for tracking operations requiring Clip Editor.

    Sets up proper Blender context for bpy.ops.clip.* operators.
    Most tracking operators require an active Movie Clip Editor area
    with a loaded clip.

    Args:
        clip: bpy.types.MovieClip to set as active

    Yields:
        Context override dict for use with operators

    Usage:
        with tracking_context(clip) as ctx:
            bpy.ops.clip.detect_features(ctx, threshold=0.5)

    Raises:
        RuntimeError: If Blender not available or no Clip Editor found
    """
    if not BLENDER_AVAILABLE:
        raise RuntimeError("Blender not available - tracking requires Blender")

    # Find Clip Editor area
    clip_area = None
    for area in bpy.context.screen.areas:
        if area.type == 'CLIP_EDITOR':
            clip_area = area
            break

    if clip_area is None:
        raise RuntimeError("No Clip Editor area found. Open a Clip Editor.")

    # Store original state
    original_clip = clip_area.spaces.active.clip

    try:
        # Set active clip
        clip_area.spaces.active.clip = clip

        # Create context override
        override = bpy.context.copy()
        override['area'] = clip_area
        override['space_data'] = clip_area.spaces.active
        override['region'] = clip_area.regions[-1]  # Use last region (usually window)

        yield override

    finally:
        # Restore original state
        clip_area.spaces.active.clip = original_clip


def get_clip_editor_area():
    """Get the active Clip Editor area, or None if not found."""
    if not BLENDER_AVAILABLE:
        return None

    for area in bpy.context.screen.areas:
        if area.type == 'CLIP_EDITOR':
            return area
    return None


def ensure_clip_loaded(clip_path: str) -> 'bpy.types.MovieClip':
    """
    Ensure a movie clip is loaded and return it.

    Args:
        clip_path: Path to video file or image sequence

    Returns:
        Loaded MovieClip
    """
    if not BLENDER_AVAILABLE:
        raise RuntimeError("Blender not available")

    import os
    path = os.path.abspath(clip_path)

    # Check if already loaded
    for clip in bpy.data.movieclips:
        if clip.filepath == path:
            return clip

    # Load new clip
    return bpy.data.movieclips.load(path)
```

3. Include comprehensive error handling:
   - Check BLENDER_AVAILABLE before any bpy access
   - Handle missing screen context (headless mode)
   - Provide clear error messages for debugging

4. Add helper functions:
   - get_clip_editor_area() - Find Clip Editor area
   - ensure_clip_loaded(path) - Load or retrieve existing clip
   - get_active_clip() - Get currently active clip from Clip Editor
</action>
  <verify>
python3 -c "
# Test without Blender (should handle gracefully)
import sys
sys.path.insert(0, '.')

from lib.cinematic.tracking.context import (
    tracking_context, get_clip_editor_area, ensure_clip_loaded, BLENDER_AVAILABLE
)

print(f'BLENDER_AVAILABLE: {BLENDER_AVAILABLE}')
print('Context module imports work')

# Context manager should raise RuntimeError without Blender
if not BLENDER_AVAILABLE:
    try:
        with tracking_context(None):
            pass
        print('ERROR: Should have raised RuntimeError')
    except RuntimeError as e:
        print(f'Correctly raises RuntimeError: {e}')
"
  </verify>
  <done>
- lib/cinematic/tracking/context.py created with tracking_context manager
- BLENDER_AVAILABLE flag properly checked
- Error handling for missing Clip Editor
- Helper functions for clip management
  </done>
</task>

<task type="auto">
  <name>Create tracking preset loader</name>
  <files>lib/cinematic/tracking/presets.py</files>
  <action>
Create presets.py for tracking preset loading, following patterns from lib/cinematic/preset_loader.py.

1. Create the module with preset loading functions:

```python
"""
Tracking Preset Loader

Provides functions to load tracking presets from YAML configuration.
Presets control feature detection and tracking parameters.

Presets:
- high_quality: Maximum accuracy, slower processing
- balanced: Good trade-off (default)
- fast: Quick results, lower accuracy
- architectural: Optimized for buildings/interiors
"""

from __future__ import annotations
from pathlib import Path
from typing import Dict, Any, Optional
import os

# Try importing yaml, fall back to None
try:
    import yaml
except ImportError:
    yaml = None

# Default preset directory
PRESET_DIR = Path(__file__).parent.parent.parent.parent / "configs" / "cinematic" / "tracking"


def load_tracking_preset(preset_name: str) -> Dict[str, Any]:
    """
    Load a tracking preset by name.

    Args:
        preset_name: Name of preset (e.g., 'balanced', 'high_quality')

    Returns:
        Dict with preset parameters

    Raises:
        FileNotFoundError: If preset file or preset name not found
    """
    preset_file = PRESET_DIR / "tracking_presets.yaml"

    if not preset_file.exists():
        raise FileNotFoundError(f"Tracking presets file not found: {preset_file}")

    if yaml is None:
        raise RuntimeError("PyYAML not installed. Install with: pip install pyyaml")

    with open(preset_file, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    presets = data.get("presets", {})

    if preset_name not in presets:
        available = list(presets.keys())
        raise ValueError(f"Preset '{preset_name}' not found. Available: {available}")

    return presets[preset_name]


def get_tracking_preset(preset_name: str = "balanced") -> Dict[str, Any]:
    """
    Get tracking preset with defaults applied.

    Convenience wrapper that returns the preset dict with
    all parameters resolved.

    Args:
        preset_name: Name of preset

    Returns:
        Dict with detection and tracking parameters
    """
    return load_tracking_preset(preset_name)


def get_detection_params(preset_name: str = "balanced") -> Dict[str, Any]:
    """
    Get detection-specific parameters from preset.

    Args:
        preset_name: Name of preset

    Returns:
        Dict with detection parameters (threshold, margin, min_distance, etc.)
    """
    preset = load_tracking_preset(preset_name)
    return preset.get("detection", {})


def get_tracking_params(preset_name: str = "balanced") -> Dict[str, Any]:
    """
    Get tracking-specific parameters from preset.

    Args:
        preset_name: Name of preset

    Returns:
        Dict with tracking parameters (correlation_threshold, etc.)
    """
    preset = load_tracking_preset(preset_name)
    return preset.get("tracking", {})


def list_tracking_presets() -> list:
    """
    List all available tracking presets.

    Returns:
        List of preset names
    """
    preset_file = PRESET_DIR / "tracking_presets.yaml"

    if not preset_file.exists():
        return []

    if yaml is None:
        return []

    with open(preset_file, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    return list(data.get("presets", {}).keys())
```

2. Follow existing patterns from lib/cinematic/preset_loader.py for consistency.
</action>
  <verify>
python3 -c "
from lib.cinematic.tracking.presets import (
    load_tracking_preset, get_tracking_preset,
    get_detection_params, get_tracking_params, list_tracking_presets
)

# List available presets
presets = list_tracking_presets()
print(f'Available presets: {presets}')

# Load balanced preset (should exist after YAML update)
try:
    balanced = get_tracking_preset('balanced')
    print(f'Balanced preset loaded: {list(balanced.keys())}')
except FileNotFoundError as e:
    print(f'Presets file not found yet (expected if YAML not created): {e}')
"
  </verify>
  <done>
- lib/cinematic/tracking/presets.py created with preset loading functions
- Follows patterns from lib/cinematic/preset_loader.py
- Supports get_detection_params() and get_tracking_params() helpers
  </done>
</task>

<task type="auto">
  <name>Update tracking presets YAML</name>
  <files>configs/cinematic/tracking/tracking_presets.yaml</files>
  <action>
Update the tracking_presets.yaml with comprehensive detection and tracking parameters for all presets.

The YAML should include:

```yaml
# Motion Tracking Presets
# Configures feature detection and tracking parameters

presets:
  # High-quality tracking (slower, more accurate)
  high_quality:
    description: "Maximum accuracy for critical shots"
    detection:
      method: "default"          # Blender's built-in detection
      threshold: 0.3             # Corner detection threshold (0-1, lower = more features)
      margin: 16                 # Margin from frame edges in pixels
      min_distance: 16           # Minimum distance between features in pixels
      min_corners: 200           # Target minimum features to detect
    tracking:
      motion_model: "Perspective"  # LocRot, LocRotScale, Affine, Perspective
      correlation_min: 0.8       # Minimum correlation for valid track (0-1)
      pattern_match: "KEYFRAME"  # KEYFRAME or PREV_FRAME
      frames_limit: 0            # Max frames to track (0 = unlimited)
      weight: 1.0                # Track weight for solver
    clean:
      frames: 8                  # Remove tracks shorter than N frames
      error: 1.5                 # Remove tracks with error > N pixels

  # Balanced (default)
  balanced:
    description: "Good trade-off between speed and accuracy"
    detection:
      method: "default"
      threshold: 0.5
      margin: 16
      min_distance: 8
      min_corners: 100
    tracking:
      motion_model: "Perspective"
      correlation_min: 0.7
      pattern_match: "KEYFRAME"
      frames_limit: 0
      weight: 1.0
    clean:
      frames: 5
      error: 2.0

  # Fast tracking (lower quality, faster)
  fast:
    description: "Quick results for preview or simple shots"
    detection:
      method: "default"
      threshold: 0.7
      margin: 8
      min_distance: 4
      min_corners: 50
    tracking:
      motion_model: "LocRot"     # Simpler motion model
      correlation_min: 0.6
      pattern_match: "PREV_FRAME"
      frames_limit: 0
      weight: 1.0
    clean:
      frames: 3
      error: 3.0

  # Architectural (buildings, interiors)
  architectural:
    description: "Optimized for buildings and interior spaces"
    detection:
      method: "default"
      threshold: 0.4
      margin: 24
      min_distance: 32           # Larger spacing for wider features
      min_corners: 150
    tracking:
      motion_model: "Affine"     # Better for rigid structures
      correlation_min: 0.75
      pattern_match: "KEYFRAME"
      frames_limit: 0
      weight: 1.0
    clean:
      frames: 8
      error: 1.8
```

If the file already exists from Phase 7.0, merge these parameters into it rather than replacing.
</action>
  <verify>
python3 -c "
import yaml
from pathlib import Path

preset_file = Path('configs/cinematic/tracking/tracking_presets.yaml')
if preset_file.exists():
    with open(preset_file, 'r') as f:
        data = yaml.safe_load(f)

    presets = data.get('presets', {})
    print(f'Presets defined: {list(presets.keys())}')

    # Check required presets exist
    required = ['high_quality', 'balanced', 'fast', 'architectural']
    for p in required:
        if p in presets:
            print(f'  {p}: detection params = {list(presets[p].get(\"detection\", {}).keys())}')
else:
    print('Presets file not found (will be created)')
"
  </verify>
  <done>
- tracking_presets.yaml contains all four presets
- Each preset has detection, tracking, and clean sections
- Parameters match research recommendations
  </done>
</task>

</tasks>

<verification>
# Phase-level verification
1. tracking_context imports and handles missing Blender gracefully
2. Preset loader functions work correctly
3. All four presets defined in YAML
4. Detection parameters accessible via get_detection_params()
</verification>

<success_criteria>
- lib/cinematic/tracking/context.py provides robust context management
- lib/cinematic/tracking/presets.py loads presets correctly
- tracking_presets.yaml has comprehensive preset definitions
- All modules import without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07.1-core-tracking/07.1-01-SUMMARY.md`
</output>
