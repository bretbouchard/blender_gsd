# Phase 13.6: Vehicle Plugins Integration

**Goal**: Integrate vehicle animation plugins into GSD workflow with procedural car fleet generation.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-08)

**Depends On**: Phase 13.0 (Rigging)

**Duration**: 5-6 days (updated for procedural car system + launch control + stunt coordination)

**Approach**: Use procedural node-based car generator with exposed style/color controls.

---

## Overview

Integrate vehicle animation tools for:
- **Procedural Cars** (node-based, style/color controllable, fleet generation)
- Planes (control surfaces, propellers)
- Robots (mechanical joints)
- Tanks (treads, turret)

**Philosophy**: Vehicles are procedural Geometry Nodes rigs with deterministic style control.

---

## Procedural Car Fleet System

### Source Asset
- **Template**: `assets/vehicles/procedural_car_exposed.blend`
- **Original**: `assets/vehicles/procedural low poly car.blend` (backup)
- **Part Variations**: 14 front bodies, 13 rear bodies, 10 bumpers, 11 wheels, etc.

### Exposed Node Inputs (38 total)

**Original Style Inputs:**
- `random`, `length`, `width`, `wheels`, `front`, `central`, `back`
- `front headlights`, `back headlights`, `handles`, `front bumper`, `back bumper`, `mirrors`, `grid`

**Added Style Inputs:**
- `Seed`, `Body Style`, `Front/Back Base/Bumper/Lights`, `Wheel/Mirror/Handle/Grill Style`

**Color Inputs:**
- `Body Color`, `Secondary Color`, `Accent Color`, `Glass Color`
- `Metalness`, `Roughness`

**Scale Inputs:**
- `Scale X`, `Scale Y`, `Scale Z`

### Available Presets

**Styles (8):** economy, sedan, sports, suv, pickup, muscle, luxury, hatchback

**Colors (14):** cherry_red, racing_red, midnight_blue, forest_green, canary_yellow, pearl_white, obsidian_black, silver_metallic, sunset_orange, electric_purple, matte_gray, police, taxi

---

## Plugin Options

| Plugin | Best For | License |
|--------|----------|---------|
| **Blender Physics** | Basic vehicle motion | Free (built-in) |
| **Vehicle Rigger** | Cars, trucks | Commercial |
| **MCamTools** | Vehicle camera rigs | Commercial |
| **RigACar** | Full car rigs | Commercial |

---

## Architecture

```
lib/animation/
â”œâ”€â”€ vehicle/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ wheel_system.py       # Wheel rotation/steering
â”‚   â”œâ”€â”€ suspension.py         # Suspension simulation
â”‚   â”œâ”€â”€ plugin_interface.py   # Generic plugin interface
â”‚   â”œâ”€â”€ vehicle_config.py     # Vehicle configuration
â”‚   â”œâ”€â”€ procedural_car.py     # ðŸ†• Procedural car factory
â”‚   â”œâ”€â”€ car_styling.py        # ðŸ†• Style/color control
â”‚   â”œâ”€â”€ launch_control.py     # ðŸ†• Launch control handler
â”‚   â”œâ”€â”€ stunt_coordinator.py  # ðŸ†• Stunt coordination system
â”‚   â””â”€â”€ driver_system.py      # ðŸ†• Expert driver profiles

configs/animation/
â””â”€â”€ vehicle/
    â”œâ”€â”€ car_basic.yaml        # Basic car config
    â”œâ”€â”€ procedural_car.yaml   # ðŸ†• Procedural car presets
    â”œâ”€â”€ truck.yaml            # Truck config
    â”œâ”€â”€ plane_prop.yaml       # Propeller plane
    â””â”€â”€ robot_walker.yaml     # Walking robot

assets/
â””â”€â”€ vehicles/
    â”œâ”€â”€ procedural_car_exposed.blend   # ðŸ†• Template with exposed inputs
    â””â”€â”€ procedural low poly car.blend  # Original source

projects/
â””â”€â”€ vehicles/
    â”œâ”€â”€ expose_car_inputs.py   # Script to expose node inputs
    â”œâ”€â”€ analyze_car_nodes.py   # Analysis utilities
    â””â”€â”€ test_car_system.py     # Test suite

.gsd-state/
â””â”€â”€ vehicle/
    â””â”€â”€ {vehicle_id}/
        â”œâ”€â”€ config.yaml
        â””â”€â”€ preview.mp4
```

---

## Data Model

### Vehicle Configuration
```yaml
# configs/animation/vehicle/car_basic.yaml
id: car_basic
name: "Basic Car"

type: automobile

dimensions:
  length: 4.5
  width: 1.8
  height: 1.4
  wheelbase: 2.7

wheels:
  - id: FL
    position: [1.35, 0.8, 0.3]
    radius: 0.35
    width: 0.2
    steering: true
    driven: false

  - id: FR
    position: [1.35, -0.8, 0.3]
    radius: 0.35
    width: 0.2
    steering: true
    driven: false

  - id: RL
    position: [-1.35, 0.8, 0.3]
    radius: 0.35
    width: 0.2
    steering: false
    driven: true

  - id: RR
    position: [-1.35, -0.8, 0.3]
    radius: 0.35
    width: 0.2
    steering: false
    driven: true

steering:
  max_angle: 35
  ackermann: true

suspension:
  type: independent
  travel: 0.15
  stiffness: 1.0

mesh:
  body: "car_body.obj"
  wheels: "car_wheel.obj"
```

### Types
```python
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Optional
from enum import Enum

class VehicleType(Enum):
    AUTOMOBILE = "automobile"
    TRUCK = "truck"
    PLANE = "plane"
    HELICOPTER = "helicopter"
    ROBOT = "robot"
    TANK = "tank"
    BOAT = "boat"
    CUSTOM = "custom"

@dataclass
class WheelConfig:
    id: str
    position: Tuple[float, float, float]
    radius: float = 0.35
    width: float = 0.2
    steering: bool = False
    driven: bool = False
    suspended: bool = True

@dataclass
class SteeringConfig:
    max_angle: float = 35.0
    ackermann: bool = True
    steering_wheel_ratio: float = 1.0

@dataclass
class SuspensionConfig:
    type: str = "independent"  # independent, solid_axle
    travel: float = 0.15
    stiffness: float = 1.0
    damping: float = 0.5

@dataclass
class VehicleDimensions:
    length: float = 4.5
    width: float = 1.8
    height: float = 1.4
    wheelbase: float = 2.7

@dataclass
class VehicleConfig:
    id: str
    name: str
    vehicle_type: VehicleType
    dimensions: VehicleDimensions = field(default_factory=VehicleDimensions)
    wheels: List[WheelConfig] = field(default_factory=list)
    steering: SteeringConfig = field(default_factory=SteeringConfig)
    suspension: SuspensionConfig = field(default_factory=SuspensionConfig)
    mesh_paths: Dict[str, str] = field(default_factory=dict)
```

---

## Tasks

### Task 1: Wheel System
**File**: `lib/animation/vehicle/wheel_system.py`

```python
import bpy
from typing import List, Dict, Optional
from math import pi, degrees, radians
from mathutils import Vector, Matrix

class WheelSystem:
    """Manage wheel rotation and steering."""

    @staticmethod
    def create_wheel_rig(
        wheel_object: bpy.types.Object,
        radius: float,
        steering_pivot: Optional[bpy.types.Object] = None
    ) -> Dict:
        """Create wheel rig with rotation and steering controls."""
        rig = {
            'wheel': wheel_object,
            'pivot': None,
            'rotation_driver': None,
            'steering_constraint': None
        }

        # Create pivot for steering
        if steering_pivot:
            rig['pivot'] = steering_pivot
        else:
            # Create pivot at wheel position
            pivot_name = f"{wheel_object.name}_pivot"
            pivot = bpy.data.objects.new(pivot_name, None)
            pivot.empty_display_type = 'ARROWS'
            pivot.location = wheel_object.location
            bpy.context.collection.objects.link(pivot)

            # Parent wheel to pivot
            wheel_object.parent = pivot
            rig['pivot'] = pivot

        return rig

    @staticmethod
    def add_rotation_driver(
        wheel_object: bpy.types.Object,
        speed_source: bpy.types.Object,
        speed_property: str = "location",  # Use X movement
        radius: float = 0.35,
        axis: str = 'Y'
    ) -> None:
        """Add driver to rotate wheel based on vehicle speed."""
        # Add driver to wheel rotation
        driver = wheel_object.driver_add(f"rotation_euler")[{'X': 0, 'Y': 1, 'Z': 2}[axis]]

        driver.driver.type = 'SCRIPTED'

        # Calculate rotation from distance traveled
        # rotation = distance / (2 * pi * radius)
        driver.driver.expression = f"({speed_source.name}.location[0] / (2 * {pi} * {radius}))"

    @staticmethod
    def add_simple_rotation_driver(
        wheel_object: bpy.types.Object,
        distance_object: bpy.types.Object,
        radius: float = 0.35
    ) -> None:
        """Add simple driver based on object X movement."""
        # Driver for Y rotation (wheel spinning)
        fcurve = wheel_object.driver_add("rotation_euler", 1)
        driver = fcurve.driver

        # Add variable for distance
        var = driver.variables.new()
        var.name = "dist"
        var.targets[0].id_type = 'OBJECT'
        var.targets[0].id = distance_object
        var.targets[0].data_path = "location[0]"

        # Expression: rotation = distance / circumference
        driver.expression = f"dist / (2 * {pi} * {radius})"

    @staticmethod
    def set_steering_angle(
        wheel_pivot: bpy.types.Object,
        angle_degrees: float,
        is_left: bool = True
    ) -> None:
        """Set steering angle for a wheel pivot."""
        # Apply Ackermann correction if needed
        corrected_angle = angle_degrees

        wheel_pivot.rotation_euler[2] = radians(corrected_angle)

    @staticmethod
    def apply_ackermann_steering(
        front_left: bpy.types.Object,
        front_right: bpy.types.Object,
        wheelbase: float,
        track_width: float,
        steering_angle: float
    ) -> tuple:
        """Apply Ackermann steering geometry."""
        from math import atan, degrees, tan

        if abs(steering_angle) < 0.1:
            return (0, 0)

        # Inner wheel turns more than outer wheel
        # Ackermann: cot(inner) - cot(outer) = track / wheelbase

        steer_rad = radians(steering_angle)

        # Calculate turn radius
        turn_radius = wheelbase / tan(steer_rad)

        # Inner wheel angle
        inner_angle = degrees(atan(wheelbase / (turn_radius - track_width / 2)))

        # Outer wheel angle
        outer_angle = degrees(atan(wheelbase / (turn_radius + track_width / 2)))

        if steering_angle > 0:
            # Turning left - left wheel is inner
            front_left.rotation_euler[2] = radians(inner_angle)
            front_right.rotation_euler[2] = radians(outer_angle)
        else:
            # Turning right - right wheel is inner
            front_left.rotation_euler[2] = radians(-outer_angle)
            front_right.rotation_euler[2] = radians(-inner_angle)

        return (inner_angle, outer_angle)


def setup_car_wheels(
    vehicle: bpy.types.Object,
    wheels: List[bpy.types.Object],
    radius: float = 0.35
) -> Dict:
    """Setup wheel system for a car."""
    system = WheelSystem()

    rigs = {}
    for wheel in wheels:
        rigs[wheel.name] = system.create_wheel_rig(wheel, radius)

    # Add rotation drivers
    for wheel in wheels:
        system.add_simple_rotation_driver(wheel, vehicle, radius)

    return rigs
```

**Acceptance**: Wheel rotation works

---

### Task 2: Suspension System
**File**: `lib/animation/vehicle/suspension.py`

```python
import bpy
from typing import List, Dict, Optional
from mathutils import Vector

class SuspensionSystem:
    """Manage vehicle suspension."""

    @staticmethod
    def create_suspension(
        wheel_object: bpy.types.Object,
        travel: float = 0.15,
        stiffness: float = 1.0
    ) -> Dict:
        """Create suspension system for a wheel."""
        # Create a suspension arm
        arm_name = f"{wheel_object.name}_suspension"
        arm = bpy.data.objects.new(arm_name, None)
        arm.empty_display_type = 'SINGLE_ARROW'
        arm.location = wheel_object.location.copy()
        bpy.context.collection.objects.link(arm)

        # Parent wheel to arm
        wheel_object.parent = arm

        return {
            'arm': arm,
            'wheel': wheel_object,
            'travel': travel,
            'stiffness': stiffness
        }

    @staticmethod
    def add_terrain_following(
        suspension_arm: bpy.types.Object,
        terrain_object: bpy.types.Object,
        ray_length: float = 1.0
    ) -> None:
        """Add shrinkwrap constraint to follow terrain."""
        con = suspension_arm.constraints.new('SHRINKWRAP')
        con.target = terrain_object
        con.shrinkwrap_type = 'PROJECT'
        con.distance = ray_length
        con.project_axis = 'NEG_Z'
        con.use_project_z = True

    @staticmethod
    def simulate_suspension(
        suspension_data: Dict,
        terrain_height: float,
        dt: float = 1/24
    ) -> float:
        """Simple spring-damper suspension simulation."""
        arm = suspension_data['arm']
        travel = suspension_data['travel']
        stiffness = suspension_data['stiffness']

        current_height = arm.location[2]
        target_height = terrain_height

        # Simple spring
        displacement = target_height - current_height
        force = stiffness * displacement

        # Apply force
        new_height = current_height + force * dt

        # Clamp to travel limits
        rest_height = suspension_data.get('rest_height', current_height)
        new_height = max(rest_height - travel, min(rest_height + travel, new_height))

        arm.location[2] = new_height

        return new_height


def setup_vehicle_suspension(
    wheels: List[bpy.types.Object],
    travel: float = 0.15
) -> Dict:
    """Setup suspension for all wheels."""
    system = SuspensionSystem()

    suspensions = {}
    for wheel in wheels:
        suspensions[wheel.name] = system.create_suspension(wheel, travel)

    return suspensions
```

**Acceptance**: Suspension follows terrain

---

### Task 3: Plugin Interface
**File**: `lib/animation/vehicle/plugin_interface.py`

```python
import bpy
from abc import ABC, abstractmethod
from typing import Dict, Any
from pathlib import Path

class VehiclePluginInterface(ABC):
    """Abstract interface for vehicle plugins."""

    @abstractmethod
    def is_available(self) -> bool:
        """Check if plugin is installed."""
        pass

    @abstractmethod
    def create_vehicle(self, config: Dict) -> Any:
        """Create a vehicle from configuration."""
        pass

    @abstractmethod
    def animate_along_path(self, vehicle_id: str, path: bpy.types.Curve) -> None:
        """Animate vehicle along a path."""
        pass


class BlenderPhysicsVehicle(VehiclePluginInterface):
    """Vehicle using Blender's built-in physics."""

    def is_available(self) -> bool:
        return True

    def create_vehicle(self, config: Dict) -> bpy.types.Object:
        # Create vehicle body
        body_name = config.get('name', 'vehicle')
        bpy.ops.mesh.primitive_cube_add(size=1)
        body = bpy.context.active_object
        body.name = body_name

        # Add rigid body
        bpy.ops.rigidbody.object_add()
        body.rigid_body.type = 'ACTIVE'
        body.rigid_body.mass = 1000

        return body

    def animate_along_path(self, vehicle_id: str, path: bpy.types.Curve) -> None:
        obj = bpy.data.objects.get(vehicle_id)
        if obj and path:
            con = obj.constraints.new('FOLLOW_PATH')
            con.target = path


# Plugin registry
PLUGINS = {
    'blender_physics': BlenderPhysicsVehicle(),
}

def get_plugin(name: str) -> VehiclePluginInterface:
    """Get vehicle plugin by name."""
    return PLUGINS.get(name, PLUGINS['blender_physics'])
```

**Acceptance**: Plugin interface works

---

### Task 4: Vehicle Configuration
**File**: `lib/animation/vehicle/vehicle_config.py`

```python
import yaml
from pathlib import Path
from typing import List, Dict, Optional
from ..types import (
    VehicleConfig, VehicleType, WheelConfig, SteeringConfig,
    SuspensionConfig, VehicleDimensions
)

VEHICLE_CONFIG_ROOT = Path(__file__).parent.parent.parent.parent / "configs" / "animation" / "vehicle"

class VehicleConfigManager:
    """Manage vehicle configurations."""

    @staticmethod
    def load(config_id: str) -> VehicleConfig:
        """Load vehicle configuration from YAML."""
        path = VEHICLE_CONFIG_ROOT / f"{config_id}.yaml"

        if not path.exists():
            raise FileNotFoundError(f"Vehicle config not found: {config_id}")

        with open(path) as f:
            data = yaml.safe_load(f)

        return VehicleConfigManager._parse_config(data)

    @staticmethod
    def _parse_config(data: dict) -> VehicleConfig:
        """Parse YAML data into VehicleConfig."""
        dims_data = data.get('dimensions', {})
        dimensions = VehicleDimensions(
            length=dims_data.get('length', 4.5),
            width=dims_data.get('width', 1.8),
            height=dims_data.get('height', 1.4),
            wheelbase=dims_data.get('wheelbase', 2.7)
        )

        wheels = []
        for w in data.get('wheels', []):
            wheels.append(WheelConfig(
                id=w['id'],
                position=tuple(w['position']),
                radius=w.get('radius', 0.35),
                width=w.get('width', 0.2),
                steering=w.get('steering', False),
                driven=w.get('driven', False)
            ))

        steer_data = data.get('steering', {})
        steering = SteeringConfig(
            max_angle=steer_data.get('max_angle', 35),
            ackermann=steer_data.get('ackermann', True)
        )

        susp_data = data.get('suspension', {})
        suspension = SuspensionConfig(
            type=susp_data.get('type', 'independent'),
            travel=susp_data.get('travel', 0.15),
            stiffness=susp_data.get('stiffness', 1.0)
        )

        return VehicleConfig(
            id=data['id'],
            name=data['name'],
            vehicle_type=VehicleType(data.get('type', 'automobile')),
            dimensions=dimensions,
            wheels=wheels,
            steering=steering,
            suspension=suspension,
            mesh_paths=data.get('mesh', {})
        )

    @staticmethod
    def list_configs() -> List[str]:
        """List available vehicle configurations."""
        if not VEHICLE_CONFIG_ROOT.exists():
            return []
        return [f.stem for f in VEHICLE_CONFIG_ROOT.glob("*.yaml")]


def load_vehicle_config(config_id: str) -> VehicleConfig:
    """Convenience function to load vehicle config."""
    return VehicleConfigManager.load(config_id)
```

**Acceptance**: Can load vehicle configs

---

### Task 5: Create Preset Configs
**Files**: `configs/animation/vehicle/*.yaml`

Create 4 preset files:
- `car_basic.yaml` - Standard car
- `truck.yaml` - Pickup truck
- `plane_prop.yaml` - Propeller plane
- `robot_walker.yaml` - Walking robot

**Acceptance**: Presets available

---

### Task 6: Procedural Car Factory
**File**: `lib/animation/vehicle/procedural_car.py`

Factory for creating launch-control compatible procedural cars with style/color control.

```python
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple
from pathlib import Path
import bpy
from mathutils import Vector

@dataclass
class CarStyle:
    """Style configuration for procedural car."""
    name: str
    body_type: str
    front_base: int = 1      # 1-14
    back_base: int = 1       # 1-15
    front_bumper: int = 1    # 1-10
    back_bumper: int = 1     # 1-9
    front_lights: int = 1    # 1-11
    back_lights: int = 1     # 1-13
    wheel_style: int = 1     # 1-11
    mirror_style: int = 1    # 1-5
    handle_style: int = 1    # 1-5

@dataclass
class CarColors:
    """Color configuration for procedural car."""
    body: Tuple[float, float, float] = (0.5, 0.5, 0.5)
    glass: Tuple[float, float, float, float] = (0.2, 0.3, 0.4, 0.5)
    metal: Tuple[float, float, float] = (0.8, 0.8, 0.8)
    # ... more color fields

# Preset styles
STYLE_PRESETS = {
    "sedan": CarStyle(name="Sedan", body_type="sedan", front_base=3, back_base=3, wheel_style=3),
    "sports": CarStyle(name="Sports Car", front_base=5, back_base=5, wheel_style=6),
    "suv": CarStyle(name="SUV", front_base=8, back_base=8, wheel_style=8),
    "pickup": CarStyle(name="Pickup Truck", front_base=10, back_base=14, wheel_style=10),
    "muscle": CarStyle(name="Muscle Car", front_base=2, back_base=3, wheel_style=5),
    # ... more presets
}

# Color presets
COLOR_PRESETS = {
    "red": CarColors(body=(0.8, 0.1, 0.1)),
    "blue": CarColors(body=(0.1, 0.2, 0.8)),
    # ... 14 total color presets
}

class ProceduralCarFactory:
    """Factory for creating launch-control compatible procedural cars."""

    def create_car(
        self,
        name: str = "Car",
        style: str = "sedan",
        color: str = "red",
        custom_style: Optional[CarStyle] = None,
        custom_color: Optional[CarColors] = None,
        seed: Optional[int] = None,
        position: Tuple[float, float, float] = (0, 0, 0)
    ) -> bpy.types.Object:
        """Create a procedural car with specified style and color."""
        ...

    def create_fleet(
        self,
        count: int,
        styles: Optional[List[str]] = None,
        colors: Optional[List[str]] = None,
        spacing: float = 5.0,
        seed: int = 42
    ) -> List[bpy.types.Object]:
        """Create a fleet of varied cars."""
        ...

    def setup_launch_compatible(self, car_obj: bpy.types.Object) -> Dict:
        """Setup car for launch control compatibility."""
        ...

# Convenience functions
def create_car(style: str = "sedan", color: str = "red", **kwargs) -> bpy.types.Object:
    ...

def create_fleet(count: int, **kwargs) -> List[bpy.types.Object]:
    ...
```

**Acceptance**: Can create styled cars and fleets with launch compatibility

---

### Task 7: Car Styling System
**File**: `lib/animation/vehicle/car_styling.py`

High-level interface for controlling car appearance through node inputs.

```python
from dataclasses import dataclass
from typing import Tuple
import bpy

@dataclass
class BodyProportions:
    length: float = 1.0
    width: float = 1.0
    height: float = 1.0
    wheel_size: float = 1.0
    ground_clearance: float = 1.0

@dataclass
class ColorScheme:
    primary: Tuple[float, float, float] = (0.5, 0.5, 0.5)
    secondary: Tuple[float, float, float] = (0.3, 0.3, 0.3)
    metalness: float = 0.8
    roughness: float = 0.3

# Style and color presets (same as procedural_car.py)

class CarStyler:
    """High-level interface for styling procedural cars."""

    def __init__(self, car_object: bpy.types.Object):
        self.car = car_object

    def set_style(self, style_name: str) -> None:
        """Apply a predefined style configuration."""
        ...

    def set_color_scheme(self, scheme_name: str) -> None:
        """Apply a predefined color scheme."""
        ...

    def set_body_color(self, color: Tuple[float, float, float]) -> None:
        """Set the primary body color."""
        ...

    def apply_proportions(self, proportions: BodyProportions) -> None:
        """Apply body proportion multipliers."""
        ...

    def randomize_variations(self, seed: int = 0) -> None:
        """Randomize part variations with a seed."""
        ...

def style_car(car_object, style="sedan", color_scheme="cherry_red", seed=None) -> CarStyler:
    """Convenience function to quickly style a car."""
    ...
```

**Acceptance**: Can apply styles and colors via clean API

---

### Task 8: Launch Control System
**File**: `lib/animation/vehicle/launch_control.py`

Manages vehicle launch sequences for cinematic scenes.

```python
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from enum import Enum
import bpy
import math
from mathutils import Vector

class LaunchState(Enum):
    STAGED = "staged"           # Waiting at start position
    COUNTDOWN = "countdown"     # Countdown in progress
    LAUNCHING = "launching"     # Accelerating
    RUNNING = "running"         # At speed
    STOPPING = "stopping"       # Decelerating
    STOPPED = "stopped"         # Full stop
    ABORTED = "aborted"         # Emergency abort

@dataclass
class LaunchConfig:
    """Configuration for a vehicle launch."""
    vehicle_id: str
    start_frame: int = 1
    target_speed: float = 60.0  # km/h
    acceleration: float = 5.0   # m/sÂ²
    path_curve: Optional[str] = None
    countdown_seconds: int = 3
    hold_at_end: bool = True

@dataclass
class LaunchController:
    """Manages vehicle launch sequences."""
    vehicles: Dict[str, LaunchConfig] = field(default_factory=dict)
    state: LaunchState = LaunchState.STAGED
    current_frame: int = 0
    countdown_start_frame: int = 0

    def stage_vehicle(
        self,
        vehicle: bpy.types.Object,
        position: Tuple[float, float, float],
        rotation: Tuple[float, float, float] = (0, 0, 0),
        config: Optional[LaunchConfig] = None
    ) -> None:
        """Position vehicle at launch staging area."""
        ...

    def start_countdown(self, start_frame: int) -> None:
        """Begin countdown sequence with audio sync markers."""
        ...

    def launch(self, frame: int) -> None:
        """Execute launch sequence for all staged vehicles."""
        ...

    def _apply_launch_animation(
        self,
        vehicle: bpy.types.Object,
        config: LaunchConfig,
        start_frame: int
    ) -> None:
        """Create launch keyframes with proper easing."""
        ...

    def abort(self, frame: int) -> None:
        """Emergency abort - stop all vehicles immediately."""
        ...

    def reset(self) -> None:
        """Reset all vehicles to staged state."""
        ...


def create_launch_controller() -> LaunchController:
    """Factory function for launch controller."""
    return LaunchController()
```

**Acceptance**: Can stage, countdown, and launch vehicles

---

### Task 7: Stunt Coordination System
**File**: `lib/animation/vehicle/stunt_coordinator.py`

Plans and animates stunt sequences for multiple vehicles.

```python
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from enum import Enum
import bpy
from mathutils import Vector
import math

class StuntType(Enum):
    JUMP = "jump"               # Vehicle jump/ramp
    DRIFT = "drift"             # Controlled slide
    BARREL_ROLL = "barrel_roll" # 360Â° roll
    J_TURN = "j_turn"          # 180Â° reverse direction
    BOOTLEG = "bootleg"        # 180Â° spin
    T_BONE = "t_bone"          # T-bone crash
    PURSUIT = "pursuit"        # Chase sequence
    FORMATION = "formation"    # Multi-vehicle formation

@dataclass
class StuntMarker:
    """Marker for a stunt event in timeline."""
    frame: int
    stunt_type: StuntType
    vehicles: List[str]
    duration_frames: int = 24
    intensity: float = 1.0  # 0-1, affects how extreme the stunt is
    notes: str = ""

@dataclass
class StuntCoordinator:
    """Coordinates stunt sequences for multiple vehicles."""
    markers: List[StuntMarker] = field(default_factory=list)
    safety_check_enabled: bool = True

    def plan_stunt(
        self,
        stunt_type: StuntType,
        vehicles: List[bpy.types.Object],
        start_frame: int,
        duration_frames: int = 24,
        intensity: float = 1.0
    ) -> StuntMarker:
        """Plan a stunt sequence."""
        ...

    def _animate_drift(self, vehicle: bpy.types.Object, marker: StuntMarker) -> None:
        """Animate a drift maneuver."""
        ...

    def _animate_jump(self, vehicle: bpy.types.Object, marker: StuntMarker) -> None:
        """Animate a vehicle jump with parabolic trajectory."""
        ...

    def _animate_barrel_roll(self, vehicle: bpy.types.Object, marker: StuntMarker) -> None:
        """Animate a 360Â° barrel roll."""
        ...

    def _animate_formation(self, vehicles: List[bpy.types.Object], marker: StuntMarker) -> None:
        """Animate vehicles into formation (wedge, v-shape, line)."""
        ...

    def safety_check(self, frame_range: Tuple[int, int]) -> List[str]:
        """Check for potential collisions in frame range."""
        ...

    def generate_shot_list(self) -> List[Dict]:
        """Generate shot list from stunt markers with camera suggestions."""
        ...


def create_stunt_coordinator() -> StuntCoordinator:
    """Factory function for stunt coordinator."""
    return StuntCoordinator()
```

**Acceptance**: Can plan and animate drift, jump, barrel roll, and formation stunts

---

### Task 8: Expert Driver System
**File**: `lib/animation/vehicle/driver_system.py`

Applies realistic driving characteristics based on driver profiles.

```python
from dataclasses import dataclass
from typing import List, Optional, Tuple
import bpy
from mathutils import Vector
import math

@dataclass
class DriverProfile:
    """Profile for how a vehicle is driven."""
    name: str
    skill_level: float = 1.0   # 0-1 (0=amateur, 1=expert/stunt driver)
    aggression: float = 0.5    # 0-1 (0=cautious, 1=aggressive)
    smoothness: float = 0.8    # 0-1 (0=jerky, 1=smooth inputs)
    consistency: float = 0.9   # 0-1 (0=variable, 1=consistent lap times)

# Preset driver profiles
DRIVER_PRESETS = {
    "stunt_driver": DriverProfile(
        name="Stunt Driver",
        skill_level=1.0,
        aggression=0.8,
        smoothness=0.95,
        consistency=0.95
    ),
    "race_driver": DriverProfile(
        name="Race Driver",
        skill_level=0.95,
        aggression=0.9,
        smoothness=0.85,
        consistency=0.9
    ),
    "average_driver": DriverProfile(
        name="Average Driver",
        skill_level=0.5,
        aggression=0.3,
        smoothness=0.6,
        consistency=0.5
    ),
    "nervous_driver": DriverProfile(
        name="Nervous Driver",
        skill_level=0.3,
        aggression=0.1,
        smoothness=0.3,
        consistency=0.2
    ),
}

class ExpertDriver:
    """Applies expert driving characteristics to vehicle animation."""

    @staticmethod
    def smooth_path(
        vehicle: bpy.types.Object,
        frame_range: Tuple[int, int],
        profile: DriverProfile
    ) -> None:
        """Smooth vehicle path based on driver skill."""
        ...

    @staticmethod
    def add_realism(
        vehicle: bpy.types.Object,
        profile: DriverProfile,
        add_jitter: bool = True
    ) -> None:
        """Add realistic driving imperfections based on driver profile."""
        ...

    @staticmethod
    def apply_racing_line(
        vehicle: bpy.types.Object,
        path_curve: bpy.types.Curve,
        profile: DriverProfile,
        frame_range: Tuple[int, int]
    ) -> None:
        """Apply racing line optimization to path following."""
        ...


def get_driver_profile(preset_name: str) -> DriverProfile:
    """Get a driver profile by preset name."""
    return DRIVER_PRESETS.get(preset_name, DRIVER_PRESETS["average_driver"])
```

**Acceptance**: Can apply driver profiles to vehicle animations

---

## Acceptance Criteria

### Must Have
- [ ] Wheel rotation from movement
- [ ] Steering with Ackermann geometry
- [ ] Suspension system
- [ ] Load/save vehicle configs
- [ ] 4 preset configurations
- [ ] ðŸ†• Procedural car factory (create styled cars)
- [ ] ðŸ†• Fleet generation (multiple cars with variations)
- [ ] ðŸ†• Style/color presets (8 styles, 14 colors)
- [ ] ðŸ†• Launch control (stage, countdown, launch)
- [ ] ðŸ†• Stunt coordination (drift, jump, barrel roll)
- [ ] ðŸ†• Driver profiles (stunt, race, average)

### Nice to Have
- [ ] Plugin integration (Vehicle Rigger, etc)
- [ ] Physics-based simulation
- [ ] Path following
- [ ] Node group internal wiring for deterministic style selection

---

## Commands

```python
# === PROCEDURAL CAR SYSTEM ===

# Create a single styled car
from lib.animation.vehicle.procedural_car import create_car
car = create_car(
    name="RaceCar_01",
    style="sports",      # economy, sedan, sports, suv, pickup, muscle, luxury, hatchback
    color="racing_red",  # 14 color presets
    seed=42,
    position=(0, 0, 0)
)

# Create a fleet of varied cars
from lib.animation.vehicle.procedural_car import create_fleet
fleet = create_fleet(
    count=10,
    styles=["sedan", "sports", "muscle"],
    colors=["cherry_red", "midnight_blue", "silver_metallic"],
    spacing=5.0,
    seed=12345
)

# Style an existing car
from lib.animation.vehicle.car_styling import style_car
styler = style_car(car, style="sports", color_scheme="electric_purple")
styler.randomize_variations(seed=42)

# Custom style
from lib.animation.vehicle.procedural_car import ProceduralCarFactory, CarStyle, CarColors
factory = ProceduralCarFactory()
custom_style = CarStyle(name="Custom", body_type="sedan", front_base=7, wheel_style=8)
custom_color = CarColors(body=(0.6, 0.1, 0.5))  # Purple
car = factory.create_car(custom_style=custom_style, custom_color=custom_color)

# === WHEEL SYSTEM ===

# Setup car wheels
from lib.animation.vehicle import setup_car_wheels
rigs = setup_car_wheels(vehicle, [wheel_FL, wheel_FR, wheel_RL, wheel_RR])

# Apply steering
from lib.animation.vehicle import WheelSystem
WheelSystem.apply_ackermann_steering(pivot_FL, pivot_FR, wheelbase=2.7, track_width=1.6, steering_angle=30)

# === LAUNCH CONTROL ===

from lib.animation.vehicle.launch_control import create_launch_controller
launcher = create_launch_controller()
launcher.stage_vehicle(car, position=(0, 0, 0))
launcher.start_countdown(start_frame=1)
launcher.launch(frame=73)  # After 3 second countdown at 24fps

# === STUNT COORDINATION ===

from lib.animation.vehicle.stunt_coordinator import create_stunt_coordinator, StuntType
coordinator = create_stunt_coordinator()
coordinator.plan_stunt(StuntType.DRIFT, [car], start_frame=100, intensity=0.8)
coordinator.plan_stunt(StuntType.JUMP, [car], start_frame=200, duration_frames=48)
coordinator.generate_shot_list()

# === DRIVER PROFILES ===

from lib.animation.vehicle.driver_system import get_driver_profile, ExpertDriver
profile = get_driver_profile("stunt_driver")
ExpertDriver.smooth_path(car, (1, 250), profile)
```

---

## AI Commands Reference

```
# === PROCEDURAL CARS ===

"Create a red sports car"
"Generate a fleet of 20 varied cars"
"Make me 5 pickup trucks in different colors"
"Create a police car and a taxi"
"Style this car to look like a muscle car"

# === SETUP VEHICLE ===

"Setup a car with 4 wheels and Ackermann steering"
"Turn the wheels 30 degrees to the left"

# === ANIMATE ===

"Drive the car along the road curve"

# === LAUNCH CONTROL ===

"Stage 3 cars at the starting line and launch them after a 3 second countdown"
"Create a race start sequence with 8 cars"

# === STUNTS ===

"Make the car drift around the corner at frame 100"
"Have the car jump over the ramp with medium intensity"
"Coordinate a 3-car wedge formation"
"Add a barrel roll stunt at frame 250"

# === DRIVER PROFILES ===

"Apply expert stunt driver profile to the lead car"
"Make the chase car drive like a nervous amateur"
"Give all cars in the fleet random driver profiles"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Geometry Rick - Mechanical Accuracy

1. **Ackermann Geometry Edge Case**
   - `apply_ackermann_steering()` returns (0, 0) for very small angles
   - Risk: Jittery steering at low angles
   - Recommendation: Use smooth falloff instead of hard cutoff at 0.1 degrees

2. **Wheel Driver Expression**
   - Driver uses object name directly in expression string
   - Risk: Breaks if object is renamed
   - Recommendation: Use driver variable with object reference instead

3. **Suspension Spring Simulation**
   - Missing damping coefficient in actual calculation
   - Risk: Suspension will oscillate indefinitely
   - Recommendation: Implement proper spring-damper: `force = stiffness * displacement - damping * velocity`

### Stunt Coord Rick - Stunt Safety & Realism

4. **Jump Trajectory**
   - Use parabolic trajectory with gravity constant (9.81 m/sÂ²)
   - Add suspension compression on landing (10-15% of travel)
   - Consider ramp angle for takeoff direction

5. **Drift Physics**
   - Real drift involves weight transfer - animate slight body roll
   - Tire smoke/dust should scale with drift intensity
   - Consider adding wheel spin during drift initiation

6. **Barrel Roll**
   - Verify roll axis is correct (usually local X for forward-moving car)
   - Add slight suspension preload before takeoff
   - Camera shake increases with intensity

### Dufus Rick - Testing Recommendations

7. **Test Tasks to Add**
   - Task: Test wheel rotation with negative radius
   - Task: Verify Ackermann at extreme angles (>60 degrees)
   - Task: Test suspension with terrain height changes
   - Task: Verify vehicle config loading with missing wheel definitions
   - Task: Test path following with closed loop curves
   - ðŸ†• Task: Test launch control with multiple vehicles
   - ðŸ†• Task: Verify stunt markers generate correct keyframes
   - ðŸ†• Task: Test driver profile smoothing on existing animation

8. **Physics Integration Note**
   - Current implementation is keyframe-based, not physics-based
   - Document that "physics" in plugin name refers to Blender's rigid body
   - Users should understand this is NOT a driving simulator

### Line Producer Rick - Production Concerns

9. **Launch Control Sync**
   - Countdown needs audio sync markers for sound design
   - Consider generating EDL for Premiere/DaVinci integration
   - Multi-vehicle launches need stagger option for safety

10. **Stunt Documentation**
    - Generate shot list with camera suggestions (already designed in)
    - Safety check should warn about potential collisions
    - Export stunt markers to timeline for editorial
