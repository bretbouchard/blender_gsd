# Phase 13.2: Pose Library

**Goal**: Save, organize, and blend reusable poses.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-04)

**Depends On**: Phase 13.0 (Rigging), Phase 13.1 (IK/FK)

**Duration**: 3-4 days

---

## Overview

Build a pose library that supports:
- Capture poses from current rig state
- Organize poses by category
- Blend multiple poses together
- Mirror poses (L ↔ R)
- Pose-to-pose animation

**Philosophy**: Poses are data. Capture once, reuse everywhere.

---

## Architecture

```
lib/animation/
├── pose_library.py       # Pose storage and retrieval
├── pose_blender.py       # Pose blending operations
├── pose_mirror.py        # Mirror pose utilities

configs/animation/
└── poses/
    ├── rest/
    │   ├── t_pose.yaml
    │   └── a_pose.yaml
    ├── locomotion/
    │   ├── walk_contact.yaml
    │   ├── walk_passing.yaml
    │   └── run_contact.yaml
    ├── action/
    │   ├── jump_start.yaml
    │   └── sit_idle.yaml
    └── expression/
        ├── neutral.yaml
        └── happy.yaml

.gsd-state/
└── poses/
    └── thumbnails/
        └── {pose_id}.png
```

---

## Data Model

### Pose Structure
```yaml
# configs/animation/poses/rest/t_pose.yaml
id: t_pose
name: "T-Pose"
category: rest
rig_type: human_biped
description: "Standard T-pose for rigging and export"

bones:
  root:
    location: [0, 0, 0]
    rotation: [0, 0, 0]
    scale: [1, 1, 1]

  spine:
    rotation: [0, 0, 0]

  spine_01:
    rotation: [0, 0, 0]

  # ... more bones

  shoulder_L:
    rotation: [0, 0, -60]

  upper_arm_L:
    rotation: [0, 90, 0]

  # ... etc

metadata:
  author: system
  created_at: 2026-02-19
  tags: [rest, export, standard]
  thumbnail: t_pose.png
```

### Types
```python
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional
from enum import Enum

class PoseCategory(Enum):
    REST = "rest"
    LOCOMOTION = "locomotion"
    ACTION = "action"
    EXPRESSION = "expression"
    HAND = "hand"
    CUSTOM = "custom"

@dataclass
class BonePose:
    location: Tuple[float, float, float] = (0, 0, 0)
    rotation: Tuple[float, float, float] = (0, 0, 0)  # Euler in degrees
    rotation_quat: Optional[Tuple[float, float, float, float]] = None
    scale: Tuple[float, float, float] = (1, 1, 1)

@dataclass
class Pose:
    id: str
    name: str
    category: PoseCategory
    rig_type: str
    description: str = ""
    bones: Dict[str, BonePose] = field(default_factory=dict)
    metadata: Dict = field(default_factory=dict)

    # For partial poses (only some bones)
    affected_bones: List[str] = field(default_factory=list)

    # Blending
    blend_weight: float = 1.0

@dataclass
class PoseBlend:
    poses: List[Tuple[str, float]]  # (pose_id, weight)
    blend_mode: str = "REPLACE"  # REPLACE, ADD, MIX

@dataclass
class PoseLibrary:
    name: str
    rig_type: str
    poses: Dict[str, Pose] = field(default_factory=dict)
    categories: List[PoseCategory] = field(default_factory=list)
```

---

## Tasks

### Task 1: Pose Library Core
**File**: `lib/animation/pose_library.py`

```python
import bpy
import yaml
from pathlib import Path
from typing import Dict, List, Optional
from .types import Pose, BonePose, PoseCategory

POSE_CONFIG_ROOT = Path(__file__).parent.parent.parent / "configs" / "animation" / "poses"

class PoseLibrary:
    """Manage pose storage, retrieval, and organization."""

    def __init__(self, rig_type: str = "human_biped"):
        self.rig_type = rig_type
        self.poses: Dict[str, Pose] = {}
        self._load_all_poses()

    def _load_all_poses(self) -> None:
        """Load all poses from config directory."""
        if not POSE_CONFIG_ROOT.exists():
            return

        for category_dir in POSE_CONFIG_ROOT.iterdir():
            if category_dir.is_dir():
                for pose_file in category_dir.glob("*.yaml"):
                    try:
                        pose = self.load_pose(pose_file)
                        self.poses[pose.id] = pose
                    except Exception as e:
                        print(f"Error loading pose {pose_file}: {e}")

    def load_pose(self, path: Path) -> Pose:
        """Load a pose from YAML file."""
        with open(path, 'r') as f:
            data = yaml.safe_load(f)

        bones = {}
        for bone_name, bone_data in data.get('bones', {}).items():
            bones[bone_name] = BonePose(
                location=tuple(bone_data.get('location', [0, 0, 0])),
                rotation=tuple(bone_data.get('rotation', [0, 0, 0])),
                rotation_quat=bone_data.get('rotation_quat'),
                scale=tuple(bone_data.get('scale', [1, 1, 1]))
            )

        return Pose(
            id=data['id'],
            name=data['name'],
            category=PoseCategory(data.get('category', 'custom')),
            rig_type=data.get('rig_type', 'human_biped'),
            description=data.get('description', ''),
            bones=bones,
            metadata=data.get('metadata', {})
        )

    def save_pose(self, pose: Pose, category: Optional[str] = None) -> Path:
        """Save a pose to YAML file."""
        cat = category or pose.category.value
        category_dir = POSE_CONFIG_ROOT / cat
        category_dir.mkdir(parents=True, exist_ok=True)

        path = category_dir / f"{pose.id}.yaml"

        data = {
            'id': pose.id,
            'name': pose.name,
            'category': pose.category.value,
            'rig_type': pose.rig_type,
            'description': pose.description,
            'bones': {
                bone_name: {
                    'location': list(bone.location),
                    'rotation': list(bone.rotation),
                    'scale': list(bone.scale)
                }
                for bone_name, bone in pose.bones.items()
            },
            'metadata': pose.metadata
        }

        with open(path, 'w') as f:
            yaml.dump(data, f, default_flow_style=False)

        return path

    def capture_pose(
        self,
        armature: bpy.types.Object,
        name: str,
        category: PoseCategory = PoseCategory.CUSTOM,
        bones: Optional[List[str]] = None
    ) -> Pose:
        """Capture current pose from armature."""
        from math import degrees

        pose_bones = {}

        for bone_name, pb in armature.pose.bones.items():
            if bones and bone_name not in bones:
                continue

            # Get rotation in degrees
            if pb.rotation_mode == 'QUATERNION':
                rot_quat = tuple(pb.rotation_quaternion)
                # Convert to euler for storage
                euler = pb.rotation_quaternion.to_euler('XYZ')
                rot = tuple(degrees(a) for a in euler)
            else:
                rot = tuple(degrees(a) for a in pb.rotation_euler)
                rot_quat = None

            pose_bones[bone_name] = BonePose(
                location=tuple(pb.location),
                rotation=rot,
                rotation_quat=rot_quat,
                scale=tuple(pb.scale)
            )

        return Pose(
            id=name.lower().replace(' ', '_'),
            name=name,
            category=category,
            rig_type=self.rig_type,
            bones=pose_bones
        )

    def apply_pose(
        self,
        armature: bpy.types.Object,
        pose: Pose,
        blend_weight: float = 1.0,
        bones: Optional[List[str]] = None
    ) -> None:
        """Apply a pose to an armature."""
        from math import radians

        target_bones = bones or list(pose.bones.keys())

        for bone_name in target_bones:
            if bone_name not in armature.pose.bones:
                continue
            if bone_name not in pose.bones:
                continue

            pb = armature.pose.bones[bone_name]
            bone_pose = pose.bones[bone_name]

            # Blend location
            pb.location = [
                pb.location[i] * (1 - blend_weight) + bone_pose.location[i] * blend_weight
                for i in range(3)
            ]

            # Blend rotation
            if pb.rotation_mode == 'QUATERNION' and bone_pose.rotation_quat:
                from mathutils import Quaternion
                target_quat = Quaternion(bone_pose.rotation_quat)
                pb.rotation_quaternion = pb.rotation_quaternion.slerp(target_quat, blend_weight)
            else:
                target_euler = [radians(a) for a in bone_pose.rotation]
                pb.rotation_euler = [
                    pb.rotation_euler[i] * (1 - blend_weight) + target_euler[i] * blend_weight
                    for i in range(3)
                ]

            # Blend scale
            pb.scale = [
                pb.scale[i] * (1 - blend_weight) + bone_pose.scale[i] * blend_weight
                for i in range(3)
            ]

    def get_poses_by_category(self, category: PoseCategory) -> List[Pose]:
        """Get all poses in a category."""
        return [p for p in self.poses.values() if p.category == category]

    def search_poses(self, query: str) -> List[Pose]:
        """Search poses by name or description."""
        query = query.lower()
        return [
            p for p in self.poses.values()
            if query in p.name.lower() or query in p.description.lower()
        ]


def capture_current_pose(armature: bpy.types.Object, name: str, category: str = "custom") -> Pose:
    """Convenience function to capture current pose."""
    library = PoseLibrary()
    return library.capture_pose(armature, name, PoseCategory(category))


def apply_pose_by_id(armature: bpy.types.Object, pose_id: str, blend: float = 1.0) -> None:
    """Apply a pose by its ID."""
    library = PoseLibrary()
    if pose_id in library.poses:
        library.apply_pose(armature, library.poses[pose_id], blend)
```

**Acceptance**: Can capture, save, load, apply poses

---

### Task 2: Pose Blender
**File**: `lib/animation/pose_blender.py`

```python
import bpy
from typing import List, Dict, Tuple
from .types import Pose, PoseBlend
from .pose_library import PoseLibrary

class PoseBlender:
    """Blend multiple poses together."""

    def __init__(self, armature: bpy.types.Object):
        self.armature = armature
        self.library = PoseLibrary()

    def blend_poses(
        self,
        pose_weights: List[Tuple[str, float]],
        blend_mode: str = "REPLACE",
        bones: List[str] = None
    ) -> None:
        """Blend multiple poses with weights."""
        if not pose_weights:
            return

        # Normalize weights
        total_weight = sum(w for _, w in pose_weights)

        if blend_mode == "REPLACE":
            # Start from rest pose
            self._reset_to_rest(bones)

        # Collect blended bone data
        blended_data: Dict[str, Dict] = {}

        for pose_id, weight in pose_weights:
            if pose_id not in self.library.poses:
                continue

            pose = self.library.poses[pose_id]
            normalized_weight = weight / total_weight if total_weight > 0 else 0

            for bone_name, bone_pose in pose.bones.items():
                if bones and bone_name not in bones:
                    continue

                if bone_name not in blended_data:
                    blended_data[bone_name] = {
                        'location': [0, 0, 0],
                        'rotation': [0, 0, 0],
                        'scale': [1, 1, 1],
                        'total_weight': 0
                    }

                # Accumulate weighted values
                for i in range(3):
                    blended_data[bone_name]['location'][i] += bone_pose.location[i] * normalized_weight
                    blended_data[bone_name]['rotation'][i] += bone_pose.rotation[i] * normalized_weight
                    blended_data[bone_name]['scale'][i] += (bone_pose.scale[i] - 1) * normalized_weight + 1

                blended_data[bone_name]['total_weight'] += normalized_weight

        # Apply blended data
        for bone_name, data in blended_data.items():
            if bone_name not in self.armature.pose.bones:
                continue

            pb = self.armature.pose.bones[bone_name]

            from math import radians
            pb.location = data['location']
            pb.rotation_euler = [radians(a) for a in data['rotation']]
            pb.scale = data['scale']

    def blend_with_current(
        self,
        pose_id: str,
        weight: float,
        bones: List[str] = None
    ) -> None:
        """Blend a pose with the current pose."""
        if pose_id not in self.library.poses:
            return

        pose = self.library.poses[pose_id]
        self.library.apply_pose(self.armature, pose, weight, bones)

    def additive_pose(
        self,
        pose_id: str,
        weight: float = 1.0,
        bones: List[str] = None
    ) -> None:
        """Add pose values on top of current pose (additive blending)."""
        if pose_id not in self.library.poses:
            return

        pose = self.library.poses[pose_id]

        target_bones = bones or list(pose.bones.keys())

        for bone_name in target_bones:
            if bone_name not in self.armature.pose.bones:
                continue
            if bone_name not in pose.bones:
                continue

            pb = self.armature.pose.bones[bone_name]
            bone_pose = pose.bones[bone_name]

            from math import radians

            # Add rotation
            pb.rotation_euler = [
                pb.rotation_euler[i] + radians(bone_pose.rotation[i]) * weight
                for i in range(3)
            ]

    def _reset_to_rest(self, bones: List[str] = None) -> None:
        """Reset bones to rest pose."""
        for bone_name, pb in self.armature.pose.bones.items():
            if bones and bone_name not in bones:
                continue

            pb.location = (0, 0, 0)
            pb.rotation_euler = (0, 0, 0)
            pb.rotation_quaternion = (1, 0, 0, 0)
            pb.scale = (1, 1, 1)


def blend_two_poses(armature: bpy.types.Object, pose_a: str, pose_b: str, blend: float) -> None:
    """Blend between two poses (0 = A, 1 = B)."""
    blender = PoseBlender(armature)
    blender.blend_poses([
        (pose_a, 1 - blend),
        (pose_b, blend)
    ])
```

**Acceptance**: Can blend multiple poses together

---

### Task 3: Pose Mirror
**File**: `lib/animation/pose_mirror.py`

```python
import bpy
from typing import Dict, Optional
from .types import Pose, BonePose
from .pose_library import PoseLibrary

class PoseMirror:
    """Mirror poses between left and right sides."""

    @staticmethod
    def get_mirror_bone_name(bone_name: str) -> str:
        """Get the mirrored bone name."""
        if bone_name.endswith('_L'):
            return bone_name[:-2] + '_R'
        elif bone_name.endswith('_R'):
            return bone_name[:-2] + '_L'
        elif '.L' in bone_name:
            return bone_name.replace('.L', '.R')
        elif '.R' in bone_name:
            return bone_name.replace('.R', '.L')
        elif '_left' in bone_name.lower():
            return bone_name.lower().replace('_left', '_right')
        elif '_right' in bone_name.lower():
            return bone_name.lower().replace('_right', '_left')
        return bone_name

    @staticmethod
    def mirror_pose(pose: Pose) -> Pose:
        """Create a mirrored version of a pose."""
        mirrored_bones = {}

        for bone_name, bone_pose in pose.bones.items():
            mirror_name = PoseMirror.get_mirror_bone_name(bone_name)

            # Mirror the rotation (invert X and Z)
            mirrored_rotation = (
                -bone_pose.rotation[0],
                bone_pose.rotation[1],
                -bone_pose.rotation[2]
            )

            # Mirror location (invert X)
            mirrored_location = (
                -bone_pose.location[0],
                bone_pose.location[1],
                bone_pose.location[2]
            )

            mirrored_bones[mirror_name] = BonePose(
                location=mirrored_location,
                rotation=mirrored_rotation,
                scale=bone_pose.scale
            )

        return Pose(
            id=f"{pose.id}_mirrored",
            name=f"{pose.name} (Mirrored)",
            category=pose.category,
            rig_type=pose.rig_type,
            description=f"Mirrored version of {pose.name}",
            bones=mirrored_bones
        )

    @staticmethod
    def apply_mirrored_pose(
        armature: bpy.types.Object,
        pose: Pose,
        side: str = 'both'
    ) -> None:
        """Apply a pose mirrored to the opposite side."""
        from math import radians

        for bone_name, bone_pose in pose.bones.items():
            mirror_name = PoseMirror.get_mirror_bone_name(bone_name)

            # Determine which side to apply to
            apply_bones = []
            if side == 'both':
                apply_bones = [bone_name, mirror_name]
            elif side == 'left' and ('_L' in bone_name or '.L' in bone_name):
                apply_bones = [bone_name]
            elif side == 'right' and ('_R' in bone_name or '.R' in bone_name):
                apply_bones = [bone_name]

            for target_bone in apply_bones:
                if target_bone not in armature.pose.bones:
                    continue

                pb = armature.pose.bones[target_bone]

                # Check if this is the mirrored side
                is_mirror = (target_bone != bone_name)

                if is_mirror:
                    # Apply mirrored values
                    pb.location = (
                        -bone_pose.location[0],
                        bone_pose.location[1],
                        bone_pose.location[2]
                    )
                    pb.rotation_euler = [
                        radians(-bone_pose.rotation[0]),
                        radians(bone_pose.rotation[1]),
                        radians(-bone_pose.rotation[2])
                    ]
                else:
                    # Apply original values
                    pb.location = bone_pose.location
                    pb.rotation_euler = [radians(a) for a in bone_pose.rotation]

    @staticmethod
    def flip_pose(armature: bpy.types.Object) -> None:
        """Flip the current pose (L <-> R)."""
        from math import radians, degrees

        # Store current pose
        current_pose = {}
        for bone_name, pb in armature.pose.bones.items():
            current_pose[bone_name] = {
                'location': tuple(pb.location),
                'rotation': tuple(degrees(a) for a in pb.rotation_euler),
                'scale': tuple(pb.scale)
            }

        # Apply mirrored values
        for bone_name, data in current_pose.items():
            mirror_name = PoseMirror.get_mirror_bone_name(bone_name)

            if mirror_name in armature.pose.bones and mirror_name != bone_name:
                mirror_pb = armature.pose.bones[mirror_name]

                # Apply mirrored values from original bone
                mirror_pb.location = (
                    -data['location'][0],
                    data['location'][1],
                    data['location'][2]
                )
                mirror_pb.rotation_euler = [
                    radians(-data['rotation'][0]),
                    radians(data['rotation'][1]),
                    radians(-data['rotation'][2])
                ]
                mirror_pb.scale = data['scale']


def mirror_current_pose(armature: bpy.types.Object) -> None:
    """Convenience function to mirror current pose."""
    PoseMirror.flip_pose(armature)
```

**Acceptance**: Can mirror poses L ↔ R

---

### Task 4: Create Standard Poses
**Files**: `configs/animation/poses/**/*.yaml`

Create pose files for:
- **rest/**: t_pose, a_pose, standing
- **locomotion/**: walk_contact, walk_passing, walk_up, run_contact
- **action/**: sit, jump_start, jump_peak
- **hand/**: fist, point, open, grip

**Acceptance**: 15+ poses available

---

## Acceptance Criteria

### Must Have
- [ ] Capture pose from armature
- [ ] Save pose to YAML
- [ ] Load pose from YAML
- [ ] Apply pose with blend weight
- [ ] Blend multiple poses
- [ ] Mirror pose (L ↔ R)
- [ ] 15+ standard poses included

### Nice to Have
- [ ] Pose thumbnails auto-generated
- [ ] Pose category organization
- [ ] Pose search
- [ ] Pose to keyframe

---

## Commands

```python
# Capture current pose
from lib.animation import capture_current_pose
pose = capture_current_pose(armature, "my_pose", "custom")

# Apply a pose
from lib.animation import apply_pose_by_id
apply_pose_by_id(armature, "t_pose", blend=0.5)

# Blend two poses
from lib.animation import blend_two_poses
blend_two_poses(armature, "walk_contact", "walk_passing", 0.5)

# Mirror pose
from lib.animation import mirror_current_pose
mirror_current_pose(armature)
```

---

## AI Commands Reference

```
# Capture pose
"Capture current pose as 'hero_idle'"

# Apply pose
"Apply t-pose to the character"

# Blend poses
"Blend walk_contact and walk_passing 50/50"

# Mirror pose
"Mirror the pose to the other side"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Automation Rick - Configuration Management

1. **YAML Schema Validation**
   - No validation on pose YAML structure before loading
   - Risk: Malformed YAML could cause runtime errors
   - Recommendation: Add `pose_schema.yaml` and validate on load

2. **Pose ID Collisions**
   - `capture_pose()` generates ID from name but doesn't check for duplicates
   - Risk: Overwriting existing poses silently
   - Recommendation: Add `pose_id_exists()` check and auto-increment option

3. **File System Safety**
   - Direct `yaml.dump()` without atomic write
   - Risk: Corrupted files on crash mid-write
   - Recommendation: Implement atomic write (write to temp, then rename)

### Dufus Rick - Testing Recommendations

4. **Test Tasks to Add**
   - Task: Verify pose load with missing optional fields
   - Task: Test pose blending with 0.0 weight (should be no-op)
   - Task: Test mirror pose with non-standard bone naming
   - Task: Verify quaternion to euler conversion accuracy
   - Task: Test pose save with Unicode characters in name

5. **Acceptance Criteria Improvements**
   - "15+ poses available" → "15+ poses with documented bone requirements"
   - Add: "Poses load within 50ms for <100 bones"
