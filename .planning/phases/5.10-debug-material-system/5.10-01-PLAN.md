---
phase: 5.10-debug-material-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/inputs/debug_materials.py
  - lib/inputs/node_group_builder.py
  - lib/inputs/__init__.py
  - projects/inputs/render_knob.py
autonomous: true

must_haves:
  truths:
    - "Each section (A_Top, A_Mid, B_Mid, B_Bot) shows distinct color in debug mode"
    - "Single boolean toggle switches between debug and production materials"
    - "Debug colors are customizable via preset palettes (rainbow, grayscale, complementary, heat_map)"
    - "No performance impact when debug mode is off"
  artifacts:
    - path: "lib/inputs/debug_materials.py"
      provides: "Debug material creation utilities and palette presets"
      exports: ["create_debug_material", "create_debug_palette", "DEBUG_COLORS", "DEBUG_PRESETS"]
    - path: "lib/inputs/node_group_builder.py"
      provides: "Per-section material assignment in geometry node tree"
      contains: "debug_mode"
    - path: "lib/inputs/__init__.py"
      provides: "Package exports for debug material functions"
  key_links:
    - from: "lib/inputs/node_group_builder.py"
      to: "lib/inputs/debug_materials.py"
      via: "import and use create_debug_material"
      pattern: "from.*debug_materials.*import"
    - from: "_build_geometry()"
      to: "Set Material nodes"
      via: "per-section material assignment before Join"
      pattern: "SetMaterial.*section"
---

<objective>
Create a node-centric debug material workflow that allows per-section material assignment for visualization and debugging, with an easy toggle to switch back to production materials.

Purpose: When building complex geometry node systems, it's hard to visualize individual sections and debug zone separation. This system provides distinct colors for each section with a single toggle.

Output: Debug material utilities, per-section material assignment in node builder, and preset palettes.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/inputs/node_group_builder.py
@lib/inputs/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Debug Material Utilities</name>
  <files>lib/inputs/debug_materials.py</files>
  <action>
Create `lib/inputs/debug_materials.py` with the following:

1. **DEBUG_COLORS constant** - Default rainbow palette:
   ```python
   DEBUG_COLORS = {
       "A_Top": (1.0, 0.4, 0.4),    # Red
       "A_Mid": (0.4, 1.0, 0.4),    # Green
       "B_Mid": (0.4, 0.4, 1.0),    # Blue
       "B_Bot": (1.0, 1.0, 0.4),    # Yellow
   }
   ```

2. **DEBUG_PRESETS dict** - Four preset palettes:
   - `rainbow`: Red/Green/Blue/Yellow (default)
   - `grayscale`: 20%/40%/60%/80% gray
   - `complementary`: Cyan/Magenta/Yellow/Black
   - `heat_map`: Blue->Cyan->Yellow->Red

3. **create_debug_material(name: str, color: tuple) -> bpy.types.Material**
   - Create a simple Principled BSDF material with the given color
   - Set metallic=0, roughness=0.5 for clear visualization
   - Name format: "Debug_{section_name}"

4. **create_debug_palette(preset_name: str = "rainbow") -> dict**
   - Return dict mapping section names to color tuples
   - Raise ValueError if preset not found

5. **create_all_debug_materials(preset: str = "rainbow") -> dict**
   - Create materials for all sections using the preset
   - Return dict mapping section names to Material objects

Do NOT use bpy.ops - use direct API calls only. Match the pattern from `_create_material()` in node_group_builder.py.
  </action>
  <verify>
```python
# Verify in Blender Python console or test script:
import sys; sys.path.insert(0, '/Users/bretbouchard/apps/blender_gsd')
from lib.inputs.debug_materials import create_debug_material, create_debug_palette, DEBUG_PRESETS
mat = create_debug_material("Test", (1.0, 0.0, 0.0))
assert mat.name == "Debug_Test"
palette = create_debug_palette("grayscale")
assert len(palette) == 4
assert len(DEBUG_PRESETS) == 4
print("OK: debug_materials.py exports verified")
```
  </verify>
  <done>
- File exists at `lib/inputs/debug_materials.py`
- Exports: DEBUG_COLORS, DEBUG_PRESETS, create_debug_material, create_debug_palette, create_all_debug_materials
- Each function returns correct types (Material, dict)
- All 4 presets defined with correct section names
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Debug Materials into Node Group Builder</name>
  <files>lib/inputs/node_group_builder.py</files>
  <action>
Modify `InputNodeGroupBuilder` to support debug mode with per-section material assignment:

1. **Add to _create_interface()** (after existing material inputs):
   ```python
   # DEBUG MODE
   self._bool("Debug_Mode", False)
   self._material("Debug_A_Top_Material")
   self._material("Debug_A_Mid_Material")
   self._material("Debug_B_Mid_Material")
   self._material("Debug_B_Bot_Material")
   ```

2. **Add _material() helper method**:
   ```python
   def _material(self, name: str, default: bpy.types.Material = None):
       s = self.tree.interface.new_socket(name, in_out="INPUT", socket_type="NodeSocketMaterial")
       s.default_value = default
   ```

3. **Modify _build_geometry()** to apply materials per-section:
   - Add `_create_debug_set_material()` helper that creates a Switch node:
     - If Debug_Mode=True: use the debug material input
     - If Debug_Mode=False: use production material
   - Apply Set Material to each section AFTER transform, BEFORE join:
     ```python
     # After a_top_xform, before join:
     a_top_mat_switch = self._create_material_switch(
         gi.outputs["Debug_Mode"],
         gi.outputs["Debug_A_Top_Material"],
         mat,  # production material
         x, y, "A_Top_MatSwitch"
     )
     a_top_set_mat = self.nk.n("GeometryNodeSetMaterial", "Set_A_Top_Mat", x+150, y)
     self.nk.link(a_top_xform.outputs["Geometry"], a_top_set_mat.inputs["Geometry"])
     self.nk.link(a_top_mat_switch.outputs[0], a_top_set_mat.inputs["Material"])
     ```
   - Repeat for A_Mid, B_Mid, B_Bot
   - Join the set_material outputs instead of transform outputs
   - Remove the final Set_Material node (materials now applied per-section)

4. **Create _create_material_switch() helper**:
   - Uses GeometryNodeSwitch to select between debug and production material
   - Returns the switch node

The key insight: Instead of one Set Material at the end, apply Set Material to each section individually. The material input to each Set Material is selected via a Switch node controlled by Debug_Mode.

Do NOT modify any other files in this task. Only node_group_builder.py.
  </action>
  <verify>
```python
# Verify the builder creates correct interface:
import sys; sys.path.insert(0, '/Users/bretbouchard/apps/blender_gsd')
from lib.inputs.node_group_builder import InputNodeGroupBuilder
import bpy

builder = InputNodeGroupBuilder()
tree = builder.build("Test_Debug")

# Check interface has debug inputs
input_names = [s.name for s in tree.interface.items_tree if s.item_type == 'SOCKET' and s.in_out == 'INPUT']
assert "Debug_Mode" in input_names, f"Missing Debug_Mode, got {input_names}"
assert "Debug_A_Top_Material" in input_names, f"Missing Debug_A_Top_Material"
assert "Debug_A_Mid_Material" in input_names
assert "Debug_B_Mid_Material" in input_names
assert "Debug_B_Bot_Material" in input_names

# Check there are 4 Set Material nodes (one per section)
set_mat_nodes = [n for n in tree.nodes if n.bl_idname == "GeometryNodeSetMaterial"]
assert len(set_mat_nodes) == 4, f"Expected 4 SetMaterial nodes, got {len(set_mat_nodes)}"

print("OK: node_group_builder.py debug integration verified")
```
  </verify>
  <done>
- `Debug_Mode` boolean input exists in interface
- 4 debug material inputs exist (Debug_A_Top_Material, etc.)
- 4 Set Material nodes in node tree (one per section)
- Switch nodes control material selection per section
- No final Set Material after Join (materials applied per-section)
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Package Exports</name>
  <files>lib/inputs/__init__.py</files>
  <action>
Update `lib/inputs/__init__.py` to export the new debug material functions:

```python
from .debug_materials import (
    DEBUG_COLORS,
    DEBUG_PRESETS,
    create_debug_material,
    create_debug_palette,
    create_all_debug_materials,
)

__all__ = [
    # ... existing exports ...
    # Debug materials
    "DEBUG_COLORS",
    "DEBUG_PRESETS",
    "create_debug_material",
    "create_debug_palette",
    "create_all_debug_materials",
]
```

Preserve all existing exports. Only add the new debug material exports.
  </action>
  <verify>
```python
# Verify imports work:
import sys; sys.path.insert(0, '/Users/bretbouchard/apps/blender_gsd')
from lib.inputs import DEBUG_COLORS, DEBUG_PRESETS, create_debug_material, create_debug_palette, create_all_debug_materials
print("OK: __init__.py exports verified")
```
  </verify>
  <done>
- All debug material functions exported from lib.inputs
- Existing exports unchanged
- No import errors
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Render Script for Debug Mode</name>
  <files>projects/inputs/render_knob.py</files>
  <action>
Add debug render support to the render script. If the file does not exist, create it with a minimal implementation.

If `projects/inputs/render_knob.py` exists:
1. Add `debug_mode: bool = False` parameter to render functions
2. When debug_mode=True:
   - Call `create_all_debug_materials()` to get debug materials
   - Pass debug materials to the node group inputs
   - Optionally render a second frame with "_debug" suffix

If file does not exist, create a minimal render script:
```python
"""
Render script for knobs with debug mode support.
"""
import bpy
import sys
from pathlib import Path

# Add project root to path
ROOT = Path(__file__).resolve().parents[2]
sys.path.insert(0, str(ROOT))

from lib.inputs.node_group_builder import create_input_node_group
from lib.inputs.debug_materials import create_all_debug_materials


def render_knob(
    output_path: str = "knob.png",
    debug_mode: bool = False,
    preset: str = "rainbow",
    **knob_params
):
    """
    Render a knob with optional debug mode.

    Args:
        output_path: Output file path
        debug_mode: If True, render with section debug colors
        preset: Debug color preset (rainbow, grayscale, complementary, heat_map)
        **knob_params: Parameters passed to the node group
    """
    # Create node group
    tree = create_input_node_group("Knob_Debug")

    # Create debug materials if needed
    if debug_mode:
        debug_mats = create_all_debug_materials(preset)
        # Set debug mode and materials on node group instance
        # (Implementation depends on how node groups are instantiated)

    # Render setup and output
    # (Minimal implementation - just verify the integration works)
    print(f"Rendering knob to {output_path}, debug_mode={debug_mode}")
    return output_path


if __name__ == "__main__":
    render_knob(debug_mode=True)
```

The key is to verify the integration path works, not to create a full render pipeline.
  </action>
  <verify>
```bash
# Verify the script imports work:
cd /Users/bretbouchard/apps/blender_gsd
python -c "from projects.inputs.render_knob import render_knob; print('OK: render_knob.py imports verified')"
```
  </verify>
  <done>
- File exists at `projects/inputs/render_knob.py`
- Exports `render_knob` function with `debug_mode` parameter
- Imports from `lib.inputs.debug_materials` work correctly
  </done>
</task>

</tasks>

<verification>
1. **Debug materials module loads correctly:**
   ```python
   from lib.inputs.debug_materials import create_debug_material, create_debug_palette, DEBUG_PRESETS
   assert len(DEBUG_PRESETS) == 4
   ```

2. **Node group builder creates debug inputs:**
   ```python
   from lib.inputs.node_group_builder import InputNodeGroupBuilder
   builder = InputNodeGroupBuilder()
   tree = builder.build("Test")
   inputs = [s.name for s in tree.interface.items_tree if s.item_type == 'SOCKET' and s.in_out == 'INPUT']
   assert "Debug_Mode" in inputs
   ```

3. **Per-section material assignment:**
   - 4 Set Material nodes in the tree
   - Each section (A_Top, A_Mid, B_Mid, B_Bot) has material applied before Join

4. **Package exports work:**
   ```python
   from lib.inputs import DEBUG_COLORS, create_debug_material
   ```

5. **Render script integration:**
   ```python
   from projects.inputs.render_knob import render_knob
   ```
</verification>

<success_criteria>
- Debug mode shows each section in distinct colors (Red, Green, Blue, Yellow)
- Single boolean toggle switches between debug and production materials
- Debug colors are customizable via 4 preset palettes
- No performance impact when debug mode is off (Switch node bypasses debug materials)
- Works with all input types that use the zone-based builder
</success_criteria>

<output>
After completion, create `.planning/phases/5.10-debug-material-system/5.10-01-SUMMARY.md`
</output>
