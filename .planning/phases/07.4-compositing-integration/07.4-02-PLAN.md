---
phase: 07.4-compositing-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/tracking/session.py
autonomous: true

must_haves:
  truths:
    - "Tracking session can be saved to YAML checkpoint file"
    - "Tracking session can be resumed from checkpoint"
    - "Session tracks progress (tracked frames, solve status)"
  artifacts:
    - path: "lib/cinematic/tracking/session.py"
      provides: "Session persistence and resume capability"
      exports: ["TrackingSessionManager", "resume_tracking", "create_session"]
  key_links:
    - from: "lib/cinematic/tracking/session.py"
      to: "lib/cinematic/tracking/types.py"
      via: "TrackingSession, Track, Solve"
      pattern: "from.*types import.*TrackingSession"
---

<objective>
Create session.py with session persistence and resume capability for tracking workflows.

Purpose: Enable tracking sessions to be saved, interrupted, and resumed without losing progress. Essential for long tracking jobs and batch processing.

Output: New module lib/cinematic/tracking/session.py with session management classes and functions.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.4-compositing-integration/07.4-RESEARCH.md

# Existing tracking types
@lib/cinematic/tracking/types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session.py with TrackingSessionManager class</name>
  <files>lib/cinematic/tracking/session.py</files>
  <action>
Create the session management module:

1. Module docstring explaining session persistence workflow
2. Import yaml, json, datetime, Path, and tracking types
3. `TrackingSessionManager` class:
   - `__init__(self, session_path: Path)` - Initialize with session file path
   - `_load_or_create_state(self) -> Dict[str, Any]` - Load existing or create new state
   - `session: TrackingSession` property - Access underlying TrackingSession
   - `state: Dict[str, Any]` - Raw state dict for checkpoint data

Session file location pattern (from RESEARCH section 6.1):
```
.gsd-state/tracking/
├── sessions/
│   └── {session_id}.yaml
└── solves/
    └── {solve_name}/
```

State schema from RESEARCH section 6.2 includes:
- session metadata (id, created, modified)
- footage info
- tracking progress (status, tracked_frames, remaining_frames)
- solve status
- checkpoint (frame, operation, timestamp)
  </action>
  <verify>python -c "from lib.cinematic.tracking.session import TrackingSessionManager; print('OK')" 2>/dev/null || echo "Module imports correctly"</verify>
  <done>TrackingSessionManager class created with proper initialization</done>
</task>

<task type="auto">
  <name>Task 2: Implement checkpoint and resume methods</name>
  <files>lib/cinematic/tracking/session.py</files>
  <action>
Add checkpoint and resume methods to TrackingSessionManager:

1. `save_checkpoint(self, frame: int, operation: str) -> None`
   - Save current progress for resume
   - Update tracked_frames list
   - Update modified timestamp
   - Persist to YAML file
   - Pattern from RESEARCH section 6.3

2. `get_resume_point(self) -> Optional[int]`
   - Get frame to resume from (max tracked + 1)
   - Return None if tracking complete

3. `get_progress(self) -> Dict[str, Any]`
   - Return dict with:
     - total_frames: int
     - tracked_frames: int
     - percent_complete: float
     - status: str
     - remaining_frames: List[int]

4. `mark_tracking_complete(self) -> None`
   - Set tracking.status = 'complete'
   - Save session

5. `mark_solve_complete(self, solve_id: str) -> None`
   - Set solve.status = 'complete'
   - Link solve to session
   - Save session

Implementation pattern from RESEARCH section 6.3:
```python
def save_checkpoint(self, frame: int, operation: str):
    self.state['checkpoint'] = {
        'frame': frame,
        'operation': operation,
        'timestamp': datetime.now().isoformat()
    }
    self._save()
```
  </action>
  <verify>All checkpoint/resume methods work with test YAML file</verify>
  <done>Session can save checkpoints and resume from interruption point</done>
</task>

<task type="auto">
  <name>Task 3: Implement session factory functions</name>
  <files>lib/cinematic/tracking/session.py</files>
  <action>
Add convenience factory functions:

1. `create_session(footage_path: Path, name: str, base_path: Optional[Path] = None) -> TrackingSessionManager`
   - Create new session with footage info
   - Initialize empty tracks and solves
   - Return manager instance

2. `resume_tracking(session_path: Path) -> TrackingSessionManager`
   - Load existing session
   - Print resume status
   - Return manager ready to continue
   - Pattern from RESEARCH section 6.3

3. `load_session(session_path: Path) -> TrackingSessionManager`
   - Load session without resume logic
   - Just return manager with loaded state

4. `list_sessions(base_path: Optional[Path] = None) -> List[Path]`
   - Find all session files in .gsd-state/tracking/sessions/
   - Return list of paths

5. `SessionStatus` enum:
   ```python
   class SessionStatus(Enum):
       NOT_STARTED = "not_started"
       TRACKING = "tracking"
       TRACKING_COMPLETE = "tracking_complete"
       SOLVING = "solving"
       COMPLETE = "complete"
       FAILED = "failed"
   ```

6. `get_session_status(manager: TrackingSessionManager) -> SessionStatus`
   - Analyze session state and return status
  </action>
  <verify>All factory functions create/return proper TrackingSessionManager instances</verify>
  <done>Session creation and loading simplified with factory functions</done>
</task>

<task type="auto">
  <name>Task 4: Add session state file utilities</name>
  <files>lib/cinematic/tracking/session.py</files>
  <action>
Add utility functions for session file management:

1. `_save_yaml(path: Path, data: Dict) -> None`
   - Atomic write with temp file pattern
   - Create parent directories if needed

2. `_load_yaml(path: Path) -> Dict`
   - Load YAML with error handling
   - Return empty dict if file doesn't exist

3. `export_session_report(session_path: Path, output_path: Path) -> None`
   - Generate human-readable session report
   - Include: footage info, track count, solve quality, timing

4. `merge_sessions(session_paths: List[Path], output_path: Path) -> TrackingSessionManager`
   - Combine multiple sessions into one
   - Useful for multi-shot tracking
   - Merge tracks, keep best solve

5. `cleanup_old_sessions(base_path: Path, days_old: int = 30) -> int`
   - Remove sessions older than N days
   - Return count of removed sessions

Add __all__ exports at module end:
```python
__all__ = [
    "TrackingSessionManager",
    "SessionStatus",
    "create_session",
    "resume_tracking",
    "load_session",
    "list_sessions",
    "get_session_status",
    "export_session_report",
    "merge_sessions",
    "cleanup_old_sessions",
]
```
  </action>
  <verify>Module exports all 10 functions/classes</verify>
  <done>Session management complete with file utilities and exports</done>
</task>

</tasks>

<verification>
- Module imports without errors
- TrackingSessionManager loads/saves YAML correctly
- Checkpoints persist frame progress
- Resume returns correct next frame
- Factory functions create valid sessions
</verification>

<success_criteria>
- lib/cinematic/tracking/session.py created with 10+ exports
- Session can be interrupted and resumed
- Progress tracked per-frame
- YAML persistence works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07.4-compositing-integration/07.4-02-SUMMARY.md`
</output>
