---
phase: 07.4-compositing-integration
plan: 03
type: execute
wave: 2
depends_on: ["07.4-01", "07.4-02"]
files_modified:
  - lib/cinematic/tracking/shot_integration.py
autonomous: true

must_haves:
  truths:
    - "Shot YAML can reference footage for tracking"
    - "Tracking runs as part of shot assembly"
    - "Solved camera integrates with cinematic camera"
    - "Composite mode renders CG over footage"
  artifacts:
    - path: "lib/cinematic/tracking/shot_integration.py"
      provides: "Shot YAML extension for tracking workflow"
      exports: ["assemble_shot_with_tracking", "setup_tracked_shot", "TrackingShotConfig", "FootageConfig"]
  key_links:
    - from: "lib/cinematic/tracking/shot_integration.py"
      to: "lib/cinematic/tracking/session.py"
      via: "TrackingSessionManager, resume_tracking"
      pattern: "from.*session import.*TrackingSessionManager"
    - from: "lib/cinematic/tracking/shot_integration.py"
      to: "lib/cinematic/tracking/compositor.py"
      via: "create_stabilization_nodes, create_alpha_over_composite"
      pattern: "from.*compositor import.*create_stabilization"
    - from: "lib/cinematic/tracking/shot_integration.py"
      to: "lib/cinematic/shot.py"
      via: "assemble_shot, ShotAssemblyConfig"
      pattern: "from.*shot import.*assemble_shot"
---

<objective>
Create shot_integration.py to extend shot assembly with tracking workflow.

Purpose: Enable single YAML to produce tracked composite shot by integrating tracking, solving, and compositing into the shot assembly pipeline.

Output: New module lib/cinematic/tracking/shot_integration.py with tracking-aware shot assembly functions.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.4-compositing-integration/07.4-RESEARCH.md

# Existing modules to integrate
@lib/cinematic/shot.py
@lib/cinematic/camera.py
@lib/cinematic/tracking/types.py
@lib/cinematic/tracking/compositor.py
@lib/cinematic/tracking/session.py
@lib/cinematic/tracking/point_tracker.py
@lib/cinematic/tracking/camera_solver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shot_integration.py with configuration dataclasses</name>
  <files>lib/cinematic/tracking/shot_integration.py</files>
  <action>
Create the shot integration module with configuration types:

1. Module docstring explaining tracking-aware shot assembly
2. `FootageConfig` dataclass:
   ```python
   @dataclass
   class FootageConfig:
       file: str = ""                    # Path to footage file
       frame_range: Tuple[int, int] = (1, 120)
       color_space: str = "Rec.709"
       frame_rate: float = 24.0
       resolution: Tuple[int, int] = (1920, 1080)
   ```

3. `TrackingShotConfig` dataclass:
   ```python
   @dataclass
   class TrackingShotConfig:
       enabled: bool = False
       preset: str = "balanced"          # From tracking_presets.yaml
       solve: bool = True                # Run camera solver
       session_file: Optional[str] = None  # Resume from existing session
       auto_detect:
           min_tracks: int = 100
           quality_threshold: float = 0.01
   ```

4. `CompositeShotConfig` dataclass:
   ```python
   @dataclass
   class CompositeShotConfig:
       mode: str = "over_footage"        # over_footage, over_plate, multiply, add, screen
       background_source: str = "footage"  # footage, image, none
       lens_distortion:
           apply_to_cg: bool = True
           st_map_path: Optional[str] = None
       stabilization:
           enabled: bool = False
           tracks: str = "all"           # all, named_group
       shadow_catcher: bool = True
       film_transparent: bool = True
   ```

All dataclasses should have to_dict() and from_dict() methods for YAML serialization.
  </action>
  <verify>python -c "from lib.cinematic.tracking.shot_integration import TrackingShotConfig, FootageConfig, CompositeShotConfig; print('OK')" 2>/dev/null</verify>
  <done>Configuration dataclasses created with YAML serialization support</done>
</task>

<task type="auto">
  <name>Task 2: Implement setup_tracked_shot function</name>
  <files>lib/cinematic/tracking/shot_integration.py</files>
  <action>
Implement the core tracking setup function:

1. `setup_tracked_shot(shot_config: Dict[str, Any], session_manager: Optional[TrackingSessionManager] = None) -> TrackingSessionManager`
   - Check for tracking.enabled in shot_config
   - Load or create session based on config
   - If session_file provided: load existing session
   - If auto_detect: run feature detection
   - If solve: run camera solver
   - Apply solved camera to shot

Implementation pattern from RESEARCH section 4.3:
```python
def setup_tracked_shot(shot_config):
    tracking_config = shot_config.get('tracking', {})

    # Load existing session or run new tracking
    if tracking_config.get('session_file'):
        session = load_tracking_session(tracking_config['session_file'])
    else:
        session = run_tracking(
            footage=shot_config['footage']['file'],
            preset=tracking_config.get('preset', 'balanced')
        )

    # Apply solved camera if requested
    if shot_config.get('camera', {}).get('from_tracking'):
        apply_solved_camera(session.solve, shot_config['camera'])

    # Setup compositor
    setup_composite_nodes(shot_config['composite'], session)

    return session
```

Handle the case where tracking is not enabled by returning None or raising informative error.
  </action>
  <verify>Function setup_tracked_shot handles enabled/disabled tracking correctly</verify>
  <done>Core tracking setup function integrated with session management</done>
</task>

<task type="auto">
  <name>Task 3: Implement assemble_shot_with_tracking function</name>
  <files>lib/cinematic/tracking/shot_integration.py</files>
  <action>
Implement the main entry point for tracked shot assembly:

1. `assemble_shot_with_tracking(shot_config: Dict[str, Any], scene: Optional[Any] = None) -> Dict[str, Any]`
   - Wraps assemble_shot from shot.py
   - Checks for tracking config
   - If tracking enabled:
     - Load/create tracking session
     - Run tracking/solving if needed
     - Apply solved camera
     - Setup compositor nodes
   - Return result dict with:
     - All keys from assemble_shot (camera, lights, backdrop, subject)
     - session: TrackingSessionManager
     - compositor_nodes: Dict of created nodes

Extended YAML structure support (from RESEARCH section 4.2):
```yaml
shot:
  name: composite_knob_hero
  footage:
    file: footage/knob_hero_4k.mp4
    frame_range: [1, 150]
  tracking:
    enabled: true
    preset: high_quality
    solve: true
  camera:
    from_tracking: true
  composite:
    mode: over_footage
    shadow_catcher: true
```

This function is the main integration point - it ties together:
- shot.py for base assembly
- session.py for tracking persistence
- compositor.py for node creation
- camera_solver.py for solving
  </action>
  <verify>Function creates complete tracked composite shot from YAML config</verify>
  <done>Main entry point ready for tracked shot assembly workflow</done>
</task>

<task type="auto">
  <name>Task 4: Implement helper functions for camera and compositing</name>
  <files>lib/cinematic/tracking/shot_integration.py</files>
  <action>
Add helper functions for camera and compositor integration:

1. `apply_solved_camera(solve: Solve, camera_config: Dict, scene: Any = None) -> bpy.types.Object`
   - Create Blender camera from Solve data
   - Keyframe position and rotation from SolveResult per frame
   - Set focal length from solve
   - Return camera object
   - Integrate with cinematic camera system (camera.py)

2. `setup_shot_compositing(composite_config: CompositeShotConfig, session: TrackingSessionManager, scene: Any = None) -> Dict[str, Any]`
   - Setup compositor based on composite config
   - Create background footage node if needed
   - Apply stabilization if enabled
   - Setup shadow catcher composite if enabled
   - Apply ST-Map distortion if configured
   - Return dict of created nodes

3. `load_tracking_shot_yaml(path: Path) -> Dict[str, Any]`
   - Load shot YAML with tracking extension
   - Parse FootageConfig, TrackingShotConfig, CompositeShotConfig
   - Return complete config dict

4. `validate_tracking_shot_config(config: Dict) -> List[str]`
   - Validate tracking shot configuration
   - Check required fields exist
   - Check footage file exists
   - Return list of validation errors (empty if valid)

Add __all__ exports:
```python
__all__ = [
    "FootageConfig",
    "TrackingShotConfig",
    "CompositeShotConfig",
    "setup_tracked_shot",
    "assemble_shot_with_tracking",
    "apply_solved_camera",
    "setup_shot_compositing",
    "load_tracking_shot_yaml",
    "validate_tracking_shot_config",
]
```
  </action>
  <verify>All 8 functions/classes exported and working</verify>
  <done>Shot integration complete with camera and compositing helpers</done>
</task>

</tasks>

<verification>
- Module imports without errors
- Configuration dataclasses serialize/deserialize correctly
- assemble_shot_with_tracking creates tracked shot
- Solved camera applies to Blender camera object
- Compositor nodes created from tracking data
</verification>

<success_criteria>
- lib/cinematic/tracking/shot_integration.py created with 8+ exports
- Single YAML produces tracked composite shot
- Tracking runs as part of shot assembly
- Solved camera integrates with cinematic camera system
</success_criteria>

<output>
After completion, create `.planning/phases/07.4-compositing-integration/07.4-03-SUMMARY.md`
</output>
