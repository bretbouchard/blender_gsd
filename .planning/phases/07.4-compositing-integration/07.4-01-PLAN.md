---
phase: 07.4-compositing-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/tracking/compositor.py
autonomous: true

must_haves:
  truths:
    - "Compositor nodes can be created from tracking data"
    - "2D stabilization uses Translate-Rotate-Scale chain"
    - "Corner pin uses relative coordinates (0-1)"
  artifacts:
    - path: "lib/cinematic/tracking/compositor.py"
      provides: "Compositor node creation from tracking data"
      exports: ["create_stabilization_nodes", "create_corner_pin_nodes", "create_alpha_over_composite", "create_shadow_composite"]
  key_links:
    - from: "lib/cinematic/tracking/compositor.py"
      to: "lib/cinematic/tracking/types.py"
      via: "StabilizationResult, Track"
      pattern: "from.*types import.*StabilizationResult"
---

<objective>
Create compositor.py with functions to generate Blender compositor nodes from tracking data.

Purpose: Provide the foundation for automatic compositor node creation that integrates tracking data (point tracks, solves, stabilization) with Blender's compositor system.

Output: New module lib/cinematic/tracking/compositor.py with 8+ exported functions for node creation.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.4-compositing-integration/07.4-RESEARCH.md

# Existing codebase patterns
@lib/cinematic/lens_fx.py
@lib/cinematic/color.py
@lib/cinematic/tracking/types.py
@lib/cinematic/tracking/stabilization.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compositor.py module with node setup utilities</name>
  <files>lib/cinematic/tracking/compositor.py</files>
  <action>
Create the compositor module with core utility functions:

1. Module docstring explaining Blender compositor node API usage
2. Import bpy (with BLENDER_AVAILABLE guard), existing tracking types
3. `_ensure_compositor_enabled()` - Enable compositor if not already enabled
4. `_get_or_create_node(tree, node_type, name)` - Helper to get existing or create new node
5. `_position_node_chain(nodes, start_x, start_y, spacing)` - Position nodes in readable layout
6. `clear_compositor_tree(scene)` - Clear all compositor nodes

Pattern from existing lens_fx.py:
```python
try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False
```

Node creation pattern from lens_fx.py:
```python
scene = bpy.context.scene
scene.use_nodes = True
tree = scene.node_tree
node = tree.nodes.new('CompositorNodeTranslate')
node.location = (x, y)
tree.links.new(output_socket, input_socket)
```
  </action>
  <verify>python -c "from lib.cinematic.tracking.compositor import BLENDER_AVAILABLE; print('OK')" 2>/dev/null || echo "Module imports correctly"</verify>
  <done>Module loads without errors, utility functions defined with proper type hints</done>
</task>

<task type="auto">
  <name>Task 2: Implement stabilization node chain creation</name>
  <files>lib/cinematic/tracking/compositor.py</files>
  <action>
Add stabilization node creation functions:

1. `create_translate_node(tree, name, x_value, y_value)` -> CompositorNodeTranslate
2. `create_rotate_node(tree, name, angle_radians)` -> CompositorNodeRotate
3. `create_scale_node(tree, name, scale_factor)` -> CompositorNodeScale

4. `create_stabilization_nodes(tree, stabilization_data, frame_range)` -> Dict[str, Node]
   - Creates Translate -> Rotate -> Scale chain
   - Uses StabilizationResult from tracking/types.py for per-frame values
   - Keyframes translate_x, translate_y, rotation, scale on each node
   - Returns dict with 'translate', 'rotate', 'scale', 'input', 'output' socket references

From RESEARCH section 2.3:
```python
translate_node = tree.nodes.new('CompositorNodeTranslate')
translate_node.use_relative = False  # Use absolute pixel values
translate_node.inputs['X'].default_value = translate_x
translate_node.inputs['Y'].default_value = translate_y

# For keyframing per-frame stabilization:
bpy.context.scene.frame_set(frame_number)
translate_node.inputs['X'].default_value = x_value
translate_node.inputs['X'].keyframe_insert(data_path='default_value', frame=frame_number)
```

Position nodes at (0, 0), (300, 0), (600, 0) for readability.
  </action>
  <verify>Function create_stabilization_nodes accepts StabilizationResult list and returns node dict</verify>
  <done>Stabilization node chain created with proper keyframing for each frame in range</done>
</task>

<task type="auto">
  <name>Task 3: Implement corner pin and alpha over node creation</name>
  <files>lib/cinematic/tracking/compositor.py</files>
  <action>
Add planar tracking and compositing node functions:

1. `create_corner_pin_nodes(tree, corners_per_frame, frame_range, width, height)` -> Dict[str, Node]
   - Creates CompositorNodeCornerPin
   - corners_per_frame: List of 4 corners [(x,y), ...] per frame in PIXEL coordinates
   - Converts to relative coordinates (0-1): relative = (pixel_x / width, pixel_y / height)
   - Keyframes each corner position per frame
   - Socket mapping: Upper Left=1, Upper Right=2, Lower Right=3, Lower Left=4

2. `create_image_node(tree, image_path, name)` -> CompositorNodeImage
   - Loads footage/image for compositing

3. `create_alpha_over_composite(tree, name)` -> CompositorNodeAlphaOver
   - Creates AlphaOver node for CG over background compositing
   - Returns node with socket info: Fac=0, FG=1, BG=2

4. `create_mix_node(tree, blend_type, name)` -> CompositorNodeMixRGB
   - Creates MixRGB node with specified blend type (MULTIPLY, ADD, SCREEN, etc.)

From RESEARCH section 3.2:
```python
corners_relative = [(x / width, y / height) for x, y in corners_px]
# Map to corner pin sockets in order: UL, UR, LR, LL
```
  </action>
  <verify>Function create_corner_pin_nodes converts pixel to relative coordinates correctly</verify>
  <done>Corner pin, image, alpha over, and mix nodes created with proper socket handling</done>
</task>

<task type="auto">
  <name>Task 4: Implement shadow composite and ST-Map workflow</name>
  <files>lib/cinematic/tracking/compositor.py</files>
  <action>
Add shadow catcher and ST-Map integration:

1. `create_shadow_composite(tree, background_image)` -> Dict[str, Node]
   - Creates MixRGB node with MULTIPLY blend type
   - Connects shadow pass from Render Layers to multiply over background
   - Returns nodes dict with 'background', 'shadow_mix', 'output' references
   - Pattern from RESEARCH section 5.4

2. `apply_stmap_distortion(tree, stmap_image, source_node)` -> CompositorNodeMapUV
   - Creates MapUV node for ST-Map application
   - Links ST-Map to Vector input, source to Image input
   - Uses BILINEAR filtering for quality
   - Pattern from RESEARCH section 7.2

3. `setup_lens_distortion_workflow(tree, mode, stmap_path, cg_node, footage_node)` -> Dict
   - mode: 'distort_cg' (apply distortion to CG) or 'undistort_footage'
   - Returns final output node reference

4. `CompositeConfig` dataclass for configuration:
   ```python
   @dataclass
   class CompositeConfig:
       mode: str = 'over_footage'  # over_footage, over_plate, multiply, add, screen
       background_source: str = 'footage'  # footage, image, none
       lens_distortion: str = 'none'  # none, distort_cg, undistort_footage
       stabilization_enabled: bool = False
       shadow_catcher: bool = False
   ```
  </action>
  <verify>All 4 new functions create proper compositor node chains</verify>
  <done>Shadow composite and ST-Map workflow functions ready for shot integration</done>
</task>

</tasks>

<verification>
- Module imports without errors (with and without Blender)
- All functions have proper type hints and docstrings
- Stabilization node chain creates Translate->Rotate->Scale with keyframes
- Corner pin converts pixel to relative coordinates (0-1)
- Alpha over composite connects FG/BG correctly
- Shadow composite uses MULTIPLY blend mode
</verification>

<success_criteria>
- lib/cinematic/tracking/compositor.py created with 8+ exported functions
- All functions follow existing lens_fx.py patterns
- Module handles Blender unavailable gracefully
- Node positioning follows readable layout pattern
</success_criteria>

<output>
After completion, create `.planning/phases/07.4-compositing-integration/07.4-01-SUMMARY.md`
</output>
