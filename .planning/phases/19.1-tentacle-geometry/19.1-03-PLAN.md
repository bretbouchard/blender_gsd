# Plan 19.1-03: Zombie Mouth Foundation

**Phase:** 19.1 - Tentacle Geometry
**Est. Time:** 3-4 hours
**Status:** Planned
**Depends on:** 19.1-01, 19.1-02

---

## Goal

Implement zombie mouth tentacle attachment and multi-tentacle array generation.

---

## Deliverables

| File | Description |
|------|-------------|
| `lib/tentacle/zombie/__init__.py` | Package exports |
| `lib/tentacle/zombie/mouth_attach.py` | Mouth attachment utilities |
| `lib/tentacle/zombie/multi_array.py` | MultiTentacleArray generator |
| `configs/tentacle/zombie_presets.yaml` | Zombie mouth presets |
| `tests/unit/test_tentacle_zombie.py` | Unit tests |

---

## Requirements Coverage

| ID | Requirement | Implementation |
|----|-------------|----------------|
| REQ-TENT-06-01 | Mouth anchor attachment | `attach_to_mouth_socket()` |
| REQ-TENT-06-02 | Multi-tentacle (1-6) | `MultiTentacleArray` |
| REQ-TENT-06-03 | Size variation | `SizeMixConfig` |

---

## Implementation

### lib/tentacle/zombie/mouth_attach.py

```python
"""Zombie mouth tentacle attachment utilities."""

from dataclasses import dataclass
from typing import Optional, Tuple
import numpy as np

try:
    import bpy
    from bpy.types import Object, Bone, PoseBone
    BLENDER_AVAILABLE = True
except ImportError:
    BLENDER_AVAILABLE = False

from ..types import TentacleConfig


@dataclass
class MouthAttachmentPoint:
    """Definition of a tentacle attachment point in mouth."""

    name: str                       # Identifier
    position: Tuple[float, float, float]  # Local position relative to mouth
    rotation: Tuple[float, float, float]  # Euler angles (radians)
    scale: float = 1.0              # Size multiplier
    tentacle_config: Optional[TentacleConfig] = None


@dataclass
class MouthSocketResult:
    """Result of mouth socket creation."""

    socket_name: str
    position: Tuple[float, float, float]
    tentacle_roots: list  # List of attached tentacle objects


def create_mouth_socket(
    jaw_bone_name: str,
    socket_name: str = "Mouth_Inside",
    offset: Tuple[float, float, float] = (0, -0.02, 0),
) -> Optional[Object]:
    """
    Create a socket empty inside the mouth for tentacle attachment.

    Args:
        jaw_bone_name: Name of the jaw bone to parent to
        socket_name: Name for the socket object
        offset: Position offset from jaw bone head

    Returns:
        Created socket object (or None if Blender unavailable)
    """
    if not BLENDER_AVAILABLE:
        return None

    # Find jaw bone
    armature = bpy.context.object
    if not armature or armature.type != 'ARMATURE':
        raise ValueError("Active object must be an armature")

    jaw_bone = armature.data.bones.get(jaw_bone_name)
    if not jaw_bone:
        raise ValueError(f"Bone '{jaw_bone_name}' not found")

    # Create empty socket
    socket = bpy.data.objects.new(socket_name, None)
    socket.empty_display_type = 'SPHERE'
    socket.empty_display_size = 0.01

    # Position relative to jaw
    jaw_head = jaw_bone.head_local
    socket.location = (
        jaw_head[0] + offset[0],
        jaw_head[1] + offset[1],
        jaw_head[2] + offset[2],
    )

    # Link to scene
    bpy.context.collection.objects.link(socket)

    # Parent to jaw bone
    socket.parent = armature
    socket.parent_type = 'BONE'
    socket.parent_bone = jaw_bone_name

    return socket


def attach_tentacle_to_socket(
    tentacle_obj: Object,
    socket_name: str,
    index: int = 0,
) -> None:
    """
    Attach a tentacle object to a mouth socket.

    Args:
        tentacle_obj: Tentacle mesh object
        socket_name: Name of the mouth socket
        index: Tentacle index for naming
    """
    if not BLENDER_AVAILABLE:
        return

    socket = bpy.data.objects.get(socket_name)
    if not socket:
        raise ValueError(f"Socket '{socket_name}' not found")

    # Parent tentacle to socket
    tentacle_obj.parent = socket

    # Rename for clarity
    tentacle_obj.name = f"Tentacle_{index:02d}"


def calculate_mouth_distribution(
    tentacle_count: int,
    spread_angle: float = 60.0,
    distribution: str = "staggered",
) -> list:
    """
    Calculate attachment positions for multiple tentacles across mouth.

    Args:
        tentacle_count: Number of tentacles
        spread_angle: Total angle spread in degrees
        distribution: Distribution pattern (uniform, random, staggered)

    Returns:
        List of (angle, z_offset) tuples for each tentacle
    """
    positions = []
    half_spread = np.radians(spread_angle / 2)

    if distribution == "uniform":
        # Evenly spaced
        for i in range(tentacle_count):
            t = i / (tentacle_count - 1) if tentacle_count > 1 else 0.5
            angle = -half_spread + t * 2 * half_spread
            positions.append((angle, 0.0))

    elif distribution == "staggered":
        # Alternating heights
        for i in range(tentacle_count):
            t = i / (tentacle_count - 1) if tentacle_count > 1 else 0.5
            angle = -half_spread + t * 2 * half_spread
            z_offset = 0.005 if i % 2 == 0 else -0.005
            positions.append((angle, z_offset))

    elif distribution == "random":
        # Random positions within spread
        rng = np.random.default_rng(42)
        for i in range(tentacle_count):
            angle = rng.uniform(-half_spread, half_spread)
            z_offset = rng.uniform(-0.005, 0.005)
            positions.append((angle, z_offset))

    else:
        raise ValueError(f"Unknown distribution: {distribution}")

    return positions


def angle_to_position(
    angle: float,
    z_offset: float,
    radius: float = 0.03,
) -> Tuple[float, float, float]:
    """
    Convert angle to 3D position on mouth arc.

    Args:
        angle: Angle in radians
        z_offset: Vertical offset
        radius: Distance from mouth center

    Returns:
        (x, y, z) position tuple
    """
    x = radius * np.sin(angle)
    y = radius * np.cos(angle) * -0.3  # Flatten toward mouth interior
    z = z_offset

    return (x, y, z)
```

### lib/tentacle/zombie/multi_array.py

```python
"""Multi-tentacle array generation for zombie mouths."""

from dataclasses import dataclass, field
from typing import List, Optional, Tuple
import numpy as np

try:
    import bpy
    from bpy.types import Object
    BLENDER_AVAILABLE = True
except ImportError:
    BLENDER_AVAILABLE = False

from ..types import TentacleConfig, ZombieMouthConfig
from ..geometry import TentacleBodyGenerator, TentacleResult
from .mouth_attach import (
    calculate_mouth_distribution,
    angle_to_position,
    attach_tentacle_to_socket,
)


@dataclass
class SizeMixConfig:
    """Configuration for mixing tentacle sizes."""

    main_ratio: float = 0.5         # Ratio of main tentacles
    main_config: Optional[TentacleConfig] = None
    feeler_config: Optional[TentacleConfig] = None

    def get_config_for_index(self, index: int, total: int) -> TentacleConfig:
        """
        Get tentacle config for a specific index based on size mix.

        Args:
            index: Tentacle index
            total: Total number of tentacles

        Returns:
            TentacleConfig for this tentacle
        """
        # Determine if this is a main or feeler tentacle
        main_count = max(1, int(total * self.main_ratio))

        if index < main_count:
            return self.main_config or TentacleConfig()
        else:
            return self.feeler_config or self._default_feeler_config()

    def _default_feeler_config(self) -> TentacleConfig:
        """Create default feeler configuration."""
        return TentacleConfig(
            length=0.5,
            base_diameter=0.04,
            tip_diameter=0.01,
            segments=12,
            name="Feeler",
        )


@dataclass
class MultiTentacleResult:
    """Result of multi-tentacle generation."""

    tentacles: List[TentacleResult] = field(default_factory=list)
    positions: List[Tuple[float, float, float]] = field(default_factory=list)
    socket_name: Optional[str] = None

    @property
    def count(self) -> int:
        """Number of tentacles generated."""
        return len(self.tentacles)

    @property
    def total_vertices(self) -> int:
        """Total vertex count across all tentacles."""
        return sum(t.vertex_count for t in self.tentacles)

    @property
    def total_faces(self) -> int:
        """Total face count across all tentacles."""
        return sum(t.face_count for t in self.tentacles)


class MultiTentacleArray:
    """Generate and manage multiple tentacles for zombie mouth."""

    def __init__(self, config: ZombieMouthConfig):
        """
        Initialize array generator.

        Args:
            config: Zombie mouth configuration
        """
        self.config = config
        self._size_mix = SizeMixConfig(
            main_ratio=1.0 - config.size_mix,  # size_mix=0 means all main
            main_config=config.main_tentacle,
            feeler_config=config.feeler_tentacle,
        )

    def generate(self, name_prefix: str = "ZombieTentacle") -> MultiTentacleResult:
        """
        Generate all tentacles in the array.

        Args:
            name_prefix: Prefix for tentacle names

        Returns:
            MultiTentacleResult with all tentacles
        """
        result = MultiTentacleResult()

        # Calculate distribution
        positions = calculate_mouth_distribution(
            self.config.tentacle_count,
            self.config.spread_angle,
            self.config.distribution,
        )

        # Generate each tentacle
        for i in range(self.config.tentacle_count):
            # Get config for this tentacle
            tentacle_config = self._size_mix.get_config_for_index(
                i, self.config.tentacle_count
            )

            # Generate tentacle
            generator = TentacleBodyGenerator(tentacle_config)
            tentacle_result = generator.generate(name=f"{name_prefix}_{i:02d}")
            result.tentacles.append(tentacle_result)

            # Calculate position
            angle, z_offset = positions[i]
            pos = angle_to_position(angle, z_offset)
            result.positions.append(pos)

        return result

    def attach_to_character(
        self,
        result: MultiTentacleResult,
        jaw_bone_name: str,
        socket_name: str = "Mouth_Inside",
    ) -> Optional[str]:
        """
        Attach generated tentacles to character face rig.

        Args:
            result: Multi-tentacle generation result
            jaw_bone_name: Name of jaw bone
            socket_name: Name for mouth socket

        Returns:
            Socket name if successful, None otherwise
        """
        if not BLENDER_AVAILABLE:
            return None

        from .mouth_attach import create_mouth_socket, attach_tentacle_to_socket

        # Create mouth socket
        socket = create_mouth_socket(jaw_bone_name, socket_name)
        if not socket:
            return None

        # Attach each tentacle
        for i, tentacle_result in enumerate(result.tentacles):
            if tentacle_result.object:
                attach_tentacle_to_socket(
                    tentacle_result.object,
                    socket_name,
                    index=i,
                )
                # Set position
                pos = result.positions[i]
                tentacle_result.object.location = pos

        return socket_name


def create_zombie_mouth(
    config: ZombieMouthConfig,
    name_prefix: str = "ZombieTentacle",
) -> MultiTentacleResult:
    """
    Convenience function to create zombie mouth tentacles.

    Args:
        config: Zombie mouth configuration
        name_prefix: Prefix for tentacle names

    Returns:
        MultiTentacleResult with all tentacles
    """
    array = MultiTentacleArray(config)
    return array.generate(name_prefix)
```

### lib/tentacle/zombie/__init__.py

```python
"""Zombie mouth tentacle integration package."""

from .mouth_attach import (
    MouthAttachmentPoint,
    MouthSocketResult,
    create_mouth_socket,
    attach_tentacle_to_socket,
    calculate_mouth_distribution,
    angle_to_position,
)
from .multi_array import (
    SizeMixConfig,
    MultiTentacleResult,
    MultiTentacleArray,
    create_zombie_mouth,
)

__all__ = [
    # Mouth attachment
    "MouthAttachmentPoint",
    "MouthSocketResult",
    "create_mouth_socket",
    "attach_tentacle_to_socket",
    "calculate_mouth_distribution",
    "angle_to_position",

    # Multi-array
    "SizeMixConfig",
    "MultiTentacleResult",
    "MultiTentacleArray",
    "create_zombie_mouth",
]
```

---

## Configuration

### configs/tentacle/zombie_presets.yaml

```yaml
# Zombie Mouth Tentacle Presets

# Individual tentacle configurations for zombies
tentacles:
  zombie_main:
    length: 1.2
    base_diameter: 0.10
    tip_diameter: 0.025
    segments: 25
    curve_resolution: 48
    taper_profile: "organic"
    twist: 15.0
    subdivision_levels: 2
    seed: 42
    name: "ZombieMain"

  zombie_feeler:
    length: 0.6
    base_diameter: 0.04
    tip_diameter: 0.01
    segments: 12
    curve_resolution: 32
    taper_profile: "smooth"
    twist: 5.0
    subdivision_levels: 1
    seed: 42
    name: "ZombieFeeler"

  zombie_thick:
    length: 1.0
    base_diameter: 0.14
    tip_diameter: 0.04
    segments: 20
    curve_resolution: 48
    taper_profile: "organic"
    twist: 10.0
    subdivision_levels: 2
    seed: 42
    name: "ZombieThick"

  zombie_thin:
    length: 0.8
    base_diameter: 0.03
    tip_diameter: 0.008
    segments: 15
    curve_resolution: 32
    taper_profile: "linear"
    twist: 20.0
    subdivision_levels: 1
    seed: 42
    name: "ZombieThin"

# Mouth configurations
mouths:
  # Standard 4-tentacle zombie
  standard:
    tentacle_count: 4
    distribution: "staggered"
    size_mix: 0.5
    spread_angle: 60.0
    main_tentacle: "zombie_main"
    feeler_tentacle: "zombie_feeler"

  # Aggressive 6-tentacle zombie
  aggressive:
    tentacle_count: 6
    distribution: "uniform"
    size_mix: 0.3
    spread_angle: 80.0
    main_tentacle: "zombie_thick"
    feeler_tentacle: "zombie_feeler"

  # Subtle 2-tentacle zombie
  subtle:
    tentacle_count: 2
    distribution: "random"
    size_mix: 0.8
    spread_angle: 40.0
    main_tentacle: "zombie_thin"
    feeler_tentacle: null

  # Heavy 4-tentacle with thick main
  heavy:
    tentacle_count: 4
    distribution: "uniform"
    size_mix: 0.2
    spread_angle: 50.0
    main_tentacle: "zombie_thick"
    feeler_tentacle: "zombie_main"

  # Swarm 6-tentacle with thin feelers
  swarm:
    tentacle_count: 6
    distribution: "staggered"
    size_mix: 0.7
    spread_angle: 70.0
    main_tentacle: "zombie_feeler"
    feeler_tentacle: "zombie_thin"
```

---

## Test Coverage

### tests/unit/test_tentacle_zombie.py

```python
"""Unit tests for zombie mouth tentacle system."""

import pytest
import numpy as np

from lib.tentacle import (
    TentacleConfig,
    ZombieMouthConfig,
)
from lib.tentacle.zombie import (
    calculate_mouth_distribution,
    angle_to_position,
    SizeMixConfig,
    MultiTentacleArray,
    MultiTentacleResult,
    create_zombie_mouth,
)


class TestMouthDistribution:
    """Test mouth distribution calculations."""

    def test_uniform_distribution(self):
        """Test uniform tentacle distribution."""
        positions = calculate_mouth_distribution(4, 60.0, "uniform")
        assert len(positions) == 4

        # All z_offsets should be 0 for uniform
        for angle, z in positions:
            assert z == 0.0

    def test_staggered_distribution(self):
        """Test staggered tentacle distribution."""
        positions = calculate_mouth_distribution(4, 60.0, "staggered")
        assert len(positions) == 4

        # Alternating z_offsets
        for i, (angle, z) in enumerate(positions):
            if i % 2 == 0:
                assert z > 0
            else:
                assert z < 0

    def test_random_distribution_deterministic(self):
        """Test that random distribution is deterministic."""
        p1 = calculate_mouth_distribution(4, 60.0, "random")
        p2 = calculate_mouth_distribution(4, 60.0, "random")
        assert p1 == p2

    def test_single_tentacle(self):
        """Test single tentacle at center."""
        positions = calculate_mouth_distribution(1, 60.0, "uniform")
        assert len(positions) == 1
        angle, z = positions[0]
        assert angle == pytest.approx(0.0)  # Center


class TestAngleToPosition:
    """Test angle to position conversion."""

    def test_center_position(self):
        """Test position at center (angle=0)."""
        pos = angle_to_position(0.0, 0.0, radius=0.03)
        assert pos[0] == pytest.approx(0.0)
        assert pos[2] == pytest.approx(0.0)

    def test_angle_offset(self):
        """Test position with angle offset."""
        pos = angle_to_position(np.pi / 4, 0.0, radius=0.03)
        assert pos[0] != 0.0  # X should be offset

    def test_z_offset(self):
        """Test z_offset affects z coordinate."""
        pos1 = angle_to_position(0.0, 0.0)
        pos2 = angle_to_position(0.0, 0.01)
        assert pos2[2] > pos1[2]


class TestSizeMixConfig:
    """Test size mix configuration."""

    def test_all_main(self):
        """Test size mix = 0 (all main tentacles)."""
        main_config = TentacleConfig(length=1.0)
        mix = SizeMixConfig(
            main_ratio=1.0,
            main_config=main_config,
        )

        for i in range(4):
            config = mix.get_config_for_index(i, 4)
            assert config.length == 1.0

    def test_mixed_sizes(self):
        """Test mixed main/feeler tentacles."""
        main_config = TentacleConfig(length=1.0, name="Main")
        feeler_config = TentacleConfig(length=0.5, name="Feeler")
        mix = SizeMixConfig(
            main_ratio=0.5,
            main_config=main_config,
            feeler_config=feeler_config,
        )

        # First 2 should be main (50% of 4)
        assert mix.get_config_for_index(0, 4).name == "Main"
        assert mix.get_config_for_index(1, 4).name == "Main"
        # Last 2 should be feelers
        assert mix.get_config_for_index(2, 4).name == "Feeler"
        assert mix.get_config_for_index(3, 4).name == "Feeler"


class TestMultiTentacleArray:
    """Test multi-tentacle array generation."""

    def test_generate_array(self):
        """Test generating tentacle array."""
        config = ZombieMouthConfig(
            tentacle_count=4,
            distribution="uniform",
            size_mix=0.5,
            spread_angle=60.0,
        )

        array = MultiTentacleArray(config)
        result = array.generate()

        assert isinstance(result, MultiTentacleResult)
        assert result.count == 4
        assert len(result.positions) == 4

    def test_total_vertex_count(self):
        """Test total vertex count calculation."""
        config = ZombieMouthConfig(tentacle_count=2)
        array = MultiTentacleArray(config)
        result = array.generate()

        # Should have vertices
        assert result.total_vertices > 0
        # Should be sum of individual tentacles
        assert result.total_vertices == sum(t.vertex_count for t in result.tentacles)

    def test_position_count_matches_tentacles(self):
        """Test that position count matches tentacle count."""
        config = ZombieMouthConfig(tentacle_count=6)
        array = MultiTentacleArray(config)
        result = array.generate()

        assert len(result.positions) == result.count


class TestCreateZombieMouth:
    """Test convenience function."""

    def test_create_zombie_mouth(self):
        """Test create_zombie_mouth convenience function."""
        config = ZombieMouthConfig(
            tentacle_count=4,
            distribution="staggered",
        )

        result = create_zombie_mouth(config)

        assert isinstance(result, MultiTentacleResult)
        assert result.count == 4
```

---

## Acceptance Criteria

- [ ] Mouth socket creation for character face rigs
- [ ] Tentacle attachment to socket
- [ ] Distribution calculation (uniform, staggered, random)
- [ ] Multi-tentacle array generation
- [ ] Size variation between main and feeler tentacles
- [ ] YAML presets for zombie mouth configurations
- [ ] 80%+ test coverage
- [ ] Works without Blender for testing
