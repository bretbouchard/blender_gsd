# Plan 19.1-02: Tentacle Body Generation

**Phase:** 19.1 - Tentacle Geometry
**Est. Time:** 4-6 hours
**Status:** Planned
**Depends on:** 19.1-01 (Types & Configuration)

---

## Goal

Implement procedural tentacle body generation using Blender curves and mesh conversion.

---

## Deliverables

| File | Description |
|------|-------------|
| `lib/tentacle/geometry/__init__.py` | Package exports |
| `lib/tentacle/geometry/body.py` | TentacleBodyGenerator |
| `lib/tentacle/geometry/taper.py` | Taper profile functions |
| `lib/tentacle/geometry/segments.py` | Segmentation utilities |
| `tests/unit/test_tentacle_geometry.py` | Unit tests |

---

## Architecture

### Generation Pipeline

```
TentacleConfig
    ↓
create_base_curve() → Bézier curve with control points
    ↓
apply_taper() → Set curve radius at each point
    ↓
resample_segments() → Distribute points based on segment count
    ↓
curve_to_mesh() → Convert to mesh geometry
    ↓
apply_subdivision() → Smooth surface
    ↓
TentacleResult (mesh + metadata)
```

---

## Implementation

### lib/tentacle/geometry/body.py

```python
"""Tentacle body generation from curves."""

from dataclasses import dataclass
from typing import Optional, Tuple
import numpy as np

try:
    import bpy
    from bpy.types import Object, Curve, Mesh
    BLENDER_AVAILABLE = True
except ImportError:
    BLENDER_AVAILABLE = False

from ..types import TentacleConfig
from .taper import calculate_taper_radii, TaperProfile
from .segments import distribute_segment_points


@dataclass
class TentacleResult:
    """Result of tentacle generation."""

    object: Optional[Object] = None     # Blender mesh object
    curve: Optional[Object] = None      # Base curve (for animation)
    mesh: Optional[Mesh] = None         # Mesh data

    # Metadata
    vertex_count: int = 0
    face_count: int = 0
    length: float = 0.0
    base_radius: float = 0.0
    tip_radius: float = 0.0

    # For testing without Blender
    vertices: Optional[np.ndarray] = None
    faces: Optional[np.ndarray] = None


class TentacleBodyGenerator:
    """Generate procedural tentacle bodies from curves."""

    def __init__(self, config: TentacleConfig):
        """
        Initialize generator with configuration.

        Args:
            config: Tentacle geometry configuration
        """
        self.config = config
        self._validate_config()

    def _validate_config(self) -> None:
        """Validate configuration parameters."""
        if not 0.1 <= self.config.length <= 3.0:
            raise ValueError(f"Length must be 0.1-3.0m, got {self.config.length}")
        if not 10 <= self.config.segments <= 50:
            raise ValueError(f"Segments must be 10-50, got {self.config.segments}")
        if self.config.tip_diameter >= self.config.base_diameter:
            raise ValueError("Tip diameter must be smaller than base diameter")

    def generate(self, name: Optional[str] = None) -> TentacleResult:
        """
        Generate tentacle mesh.

        Args:
            name: Override object name

        Returns:
            TentacleResult with mesh and metadata
        """
        name = name or self.config.name

        if BLENDER_AVAILABLE:
            return self._generate_blender(name)
        else:
            return self._generate_numpy(name)

    def _generate_blender(self, name: str) -> TentacleResult:
        """Generate tentacle using Blender API."""
        # Create curve
        curve_obj = self._create_base_curve(name)
        curve = curve_obj.data

        # Apply taper profile
        self._apply_taper_to_curve(curve)

        # Resample for segments
        self._resample_curve(curve)

        # Convert to mesh
        mesh_obj = self._curve_to_mesh(curve_obj, f"{name}_mesh")

        # Apply subdivision
        if self.config.subdivision_levels > 0:
            self._apply_subdivision(mesh_obj)

        # Calculate metadata
        mesh = mesh_obj.data
        result = TentacleResult(
            object=mesh_obj,
            curve=curve_obj,
            mesh=mesh,
            vertex_count=len(mesh.vertices),
            face_count=len(mesh.polygons),
            length=self.config.length,
            base_radius=self.config.base_diameter / 2,
            tip_radius=self.config.tip_diameter / 2,
        )

        return result

    def _generate_numpy(self, name: str) -> TentacleResult:
        """Generate tentacle geometry as numpy arrays (for testing)."""
        # Calculate taper radii
        radii = calculate_taper_radii(
            self.config.segments + 1,
            self.config.base_diameter / 2,
            self.config.tip_diameter / 2,
            self.config.taper_profile,
        )

        # Generate curve points
        t = np.linspace(0, 1, self.config.segments + 1)
        z = t * self.config.length

        # Create circle vertices at each point
        resolution = self.config.curve_resolution
        angles = np.linspace(0, 2 * np.pi, resolution, endpoint=False)

        vertices = []
        faces = []

        for i, (zi, ri) in enumerate(zip(z, radii)):
            for angle in angles:
                x = ri * np.cos(angle)
                y = ri * np.sin(angle)
                vertices.append([x, y, zi])

        vertices = np.array(vertices)

        # Create faces (quad strips)
        for i in range(self.config.segments):
            for j in range(resolution):
                j_next = (j + 1) % resolution
                v1 = i * resolution + j
                v2 = i * resolution + j_next
                v3 = (i + 1) * resolution + j_next
                v4 = (i + 1) * resolution + j
                faces.append([v1, v2, v3, v4])

        faces = np.array(faces)

        return TentacleResult(
            vertices=vertices,
            faces=faces,
            vertex_count=len(vertices),
            face_count=len(faces),
            length=self.config.length,
            base_radius=self.config.base_diameter / 2,
            tip_radius=self.config.tip_diameter / 2,
        )

    def _create_base_curve(self, name: str) -> Object:
        """Create base Bézier curve for tentacle."""
        curve_data = bpy.data.curves.new(name=f"{name}_curve", type='CURVE')
        curve_data.dimensions = '3D'
        curve_data.resolution_u = self.config.curve_resolution

        # Create spline
        spline = curve_data.splines.new('BEZIER')

        # Add control points (start, middle, end)
        spline.bezier_points.add(2)  # 3 points total

        # Set point positions
        spline.bezier_points[0].co = (0, 0, 0)
        spline.bezier_points[1].co = (0, 0, self.config.length * 0.5)
        spline.bezier_points[2].co = (0, 0, self.config.length)

        # Set handles for smooth curve
        for point in spline.bezier_points:
            point.handle_left_type = 'AUTO'
            point.handle_right_type = 'AUTO'

        # Create object
        curve_obj = bpy.data.objects.new(name, curve_data)
        bpy.context.collection.objects.link(curve_obj)

        return curve_obj

    def _apply_taper_to_curve(self, curve: Curve) -> None:
        """Apply taper profile to curve radii."""
        spline = curve.splines[0]
        point_count = len(spline.bezier_points)

        radii = calculate_taper_radii(
            point_count,
            self.config.base_diameter / 2,
            self.config.tip_diameter / 2,
            self.config.taper_profile,
        )

        for i, point in enumerate(spline.bezier_points):
            point.radius = radii[i]

    def _resample_curve(self, curve: Curve) -> None:
        """Resample curve to match segment count."""
        # Use path conversion for segment distribution
        curve.resolution_u = self.config.segments

    def _curve_to_mesh(self, curve_obj: Object, name: str) -> Object:
        """Convert curve to mesh."""
        # Add bevel depth for tube shape
        curve = curve_obj.data
        curve.bevel_depth = 1.0  # Full radius
        curve.bevel_resolution = self.config.curve_resolution // 4

        # Convert to mesh
        bpy.context.view_layer.objects.active = curve_obj
        curve_obj.select_set(True)
        bpy.ops.object.convert(target='MESH')

        mesh_obj = bpy.context.active_object
        mesh_obj.name = name

        return mesh_obj

    def _apply_subdivision(self, mesh_obj: Object) -> None:
        """Apply subdivision surface modifier."""
        mod = mesh_obj.modifiers.new(name="Subdivision", type='SUBSURF')
        mod.levels = self.config.subdivision_levels
        mod.render_levels = self.config.subdivision_levels


def create_tentacle(config: TentacleConfig, name: Optional[str] = None) -> TentacleResult:
    """
    Convenience function to create a tentacle.

    Args:
        config: Tentacle configuration
        name: Optional object name

    Returns:
        TentacleResult with mesh and metadata
    """
    generator = TentacleBodyGenerator(config)
    return generator.generate(name)
```

### lib/tentacle/geometry/taper.py

```python
"""Taper profile calculations for tentacle bodies."""

from typing import List, Optional, Tuple
import numpy as np

from ..types import TaperProfile


def calculate_taper_radii(
    point_count: int,
    base_radius: float,
    tip_radius: float,
    profile_type: str = "organic",
    profile: Optional[TaperProfile] = None,
) -> np.ndarray:
    """
    Calculate radius at each point along tentacle length.

    Args:
        point_count: Number of points along tentacle
        base_radius: Radius at base (start)
        tip_radius: Radius at tip (end)
        profile_type: Built-in profile type
        profile: Custom profile (overrides profile_type)

    Returns:
        Array of radii for each point
    """
    t = np.linspace(0, 1, point_count)

    if profile and profile.points:
        # Use custom profile points
        return _interpolate_custom_profile(t, profile, base_radius, tip_radius)

    # Use built-in profile
    if profile_type == "linear":
        factors = _linear_profile(t)
    elif profile_type == "smooth":
        factors = _smooth_profile(t)
    elif profile_type == "organic":
        factors = _organic_profile(t, base_ratio=2.5, mid_point=0.4)
    else:
        factors = _organic_profile(t)  # Default to organic

    # Scale to actual radii
    return tip_radius + (base_radius - tip_radius) * (1 - factors)


def _linear_profile(t: np.ndarray) -> np.ndarray:
    """Linear taper from base to tip."""
    return t


def _smooth_profile(t: np.ndarray) -> np.ndarray:
    """Smooth ease-in-out taper."""
    # Smoothstep function: 3t² - 2t³
    return 3 * t**2 - 2 * t**3


def _organic_profile(
    t: np.ndarray,
    base_ratio: float = 2.5,
    mid_point: float = 0.4,
) -> np.ndarray:
    """
    Organic/natural taper with bulbous base.

    Args:
        t: Normalized position (0-1)
        base_ratio: Ratio of base to tip diameter
        mid_point: Where taper accelerates (0-1)

    Returns:
        Radius factors (0 at base, 1 at tip)
    """
    # Create smooth organic curve
    # Faster taper at base, slower toward tip
    factor = np.zeros_like(t)

    for i, ti in enumerate(t):
        if ti < mid_point:
            # Bulbous base - slower initial taper
            factor[i] = 0.5 * (ti / mid_point) ** 2
        else:
            # Accelerating taper toward tip
            normalized = (ti - mid_point) / (1 - mid_point)
            factor[i] = 0.5 + 0.5 * (2 * normalized - normalized**2)

    return factor


def _interpolate_custom_profile(
    t: np.ndarray,
    profile: TaperProfile,
    base_radius: float,
    tip_radius: float,
) -> np.ndarray:
    """Interpolate custom profile points."""
    points = sorted(profile.points, key=lambda p: p[0])
    positions = np.array([p[0] for p in points])
    factors = np.array([p[1] for p in points])

    # Interpolate
    result = np.interp(t, positions, factors)

    # Scale to radii
    return tip_radius + (base_radius - tip_radius) * (1 - result)


def create_taper_curve(
    base_radius: float,
    tip_radius: float,
    resolution: int = 64,
    profile_type: str = "organic",
) -> List[Tuple[float, float, float]]:
    """
    Create taper curve as list of (x, y, z) points.

    Args:
        base_radius: Radius at base
        tip_radius: Radius at tip
        resolution: Number of points
        profile_type: Profile type

    Returns:
        List of (x, y, z) tuples for curve points
    """
    radii = calculate_taper_radii(resolution, base_radius, tip_radius, profile_type)

    points = []
    for i, radius in enumerate(radii):
        z = i / (resolution - 1)  # Normalized length
        points.append((radius, 0, z))

    return points
```

### lib/tentacle/geometry/segments.py

```python
"""Segmentation utilities for tentacle bodies."""

from typing import List, Tuple
import numpy as np


def distribute_segment_points(
    segment_count: int,
    length: float,
    uniform: bool = True,
    variation: float = 0.0,
    seed: int = 42,
) -> np.ndarray:
    """
    Distribute segment points along tentacle length.

    Args:
        segment_count: Number of segments
        length: Total tentacle length
        uniform: Equal segment lengths
        variation: Random variation (0-0.2)
        seed: Random seed for determinism

    Returns:
        Array of z-positions for segment boundaries
    """
    if uniform and variation == 0:
        # Perfectly uniform distribution
        return np.linspace(0, length, segment_count + 1)

    # Random variation
    rng = np.random.default_rng(seed)

    # Start with uniform
    positions = np.linspace(0, length, segment_count + 1)

    # Apply variation to interior points
    if variation > 0:
        segment_length = length / segment_count
        for i in range(1, segment_count):
            offset = rng.uniform(-variation, variation) * segment_length
            positions[i] = np.clip(
                positions[i] + offset,
                positions[i - 1] + segment_length * 0.1,
                positions[i + 1] - segment_length * 0.1,
            )

    return positions


def calculate_segment_length(
    total_length: float,
    segment_count: int,
    index: int,
) -> float:
    """
    Calculate length of a specific segment.

    Args:
        total_length: Total tentacle length
        segment_count: Number of segments
        index: Segment index (0-based)

    Returns:
        Length of segment
    """
    return total_length / segment_count


def get_segment_bounds(
    total_length: float,
    segment_count: int,
    index: int,
) -> Tuple[float, float]:
    """
    Get start and end z-position of a segment.

    Args:
        total_length: Total tentacle length
        segment_count: Number of segments
        index: Segment index (0-based)

    Returns:
        (start_z, end_z) tuple
    """
    segment_length = total_length / segment_count
    start_z = index * segment_length
    end_z = (index + 1) * segment_length
    return start_z, end_z
```

### lib/tentacle/geometry/__init__.py

```python
"""Tentacle geometry generation package."""

from .body import (
    TentacleBodyGenerator,
    TentacleResult,
    create_tentacle,
)
from .taper import (
    calculate_taper_radii,
    create_taper_curve,
)
from .segments import (
    distribute_segment_points,
    calculate_segment_length,
    get_segment_bounds,
)

__all__ = [
    # Body generation
    "TentacleBodyGenerator",
    "TentacleResult",
    "create_tentacle",

    # Taper
    "calculate_taper_radii",
    "create_taper_curve",

    # Segments
    "distribute_segment_points",
    "calculate_segment_length",
    "get_segment_bounds",
]
```

---

## Test Coverage

### tests/unit/test_tentacle_geometry.py

```python
"""Unit tests for tentacle geometry generation."""

import pytest
import numpy as np

from lib.tentacle import TentacleConfig
from lib.tentacle.geometry import (
    TentacleBodyGenerator,
    TentacleResult,
    create_tentacle,
    calculate_taper_radii,
    distribute_segment_points,
)


class TestTaperCalculations:
    """Test taper profile calculations."""

    def test_linear_taper(self):
        """Test linear taper profile."""
        radii = calculate_taper_radii(5, 0.04, 0.01, "linear")
        assert len(radii) == 5
        assert radii[0] == pytest.approx(0.04)  # Base
        assert radii[-1] == pytest.approx(0.01)  # Tip

    def test_organic_taper(self):
        """Test organic taper profile."""
        radii = calculate_taper_radii(20, 0.04, 0.01, "organic")
        assert len(radii) == 20
        assert radii[0] > radii[-1]  # Base larger than tip

    def test_radii_decrease(self):
        """Test that radii decrease from base to tip."""
        radii = calculate_taper_radii(10, 0.04, 0.01, "smooth")
        for i in range(len(radii) - 1):
            assert radii[i] >= radii[i + 1]


class TestSegmentDistribution:
    """Test segment point distribution."""

    def test_uniform_distribution(self):
        """Test uniform segment distribution."""
        positions = distribute_segment_points(10, 1.0, uniform=True)
        assert len(positions) == 11  # n+1 points for n segments
        assert positions[0] == 0.0
        assert positions[-1] == 1.0

    def test_deterministic_variation(self):
        """Test that variation is deterministic with seed."""
        p1 = distribute_segment_points(10, 1.0, variation=0.1, seed=42)
        p2 = distribute_segment_points(10, 1.0, variation=0.1, seed=42)
        np.testing.assert_array_equal(p1, p2)

    def test_different_seeds_different_results(self):
        """Test that different seeds produce different results."""
        p1 = distribute_segment_points(10, 1.0, variation=0.1, seed=42)
        p2 = distribute_segment_points(10, 1.0, variation=0.1, seed=43)
        assert not np.array_equal(p1, p2)


class TestTentacleBodyGenerator:
    """Test tentacle body generation."""

    def test_config_validation(self):
        """Test configuration validation."""
        # Invalid length
        with pytest.raises(ValueError):
            TentacleBodyGenerator(TentacleConfig(length=5.0))

        # Invalid segments
        with pytest.raises(ValueError):
            TentacleBodyGenerator(TentacleConfig(segments=100))

    def test_numpy_generation(self):
        """Test generation without Blender."""
        config = TentacleConfig(
            length=1.0,
            base_diameter=0.08,
            tip_diameter=0.02,
            segments=10,
        )
        generator = TentacleBodyGenerator(config)
        result = generator.generate()

        assert isinstance(result, TentacleResult)
        assert result.vertex_count > 0
        assert result.face_count > 0
        assert result.length == 1.0

    def test_vertex_count_matches_segments(self):
        """Test that vertex count matches expected for segments."""
        config = TentacleConfig(segments=10, curve_resolution=16)
        generator = TentacleBodyGenerator(config)
        result = generator.generate()

        # Expected: (segments + 1) * resolution
        expected = (10 + 1) * 16
        assert result.vertex_count == expected

    def test_deterministic_output(self):
        """Test that same config produces same mesh."""
        config = TentacleConfig(seed=42)

        gen1 = TentacleBodyGenerator(config)
        result1 = gen1.generate()

        gen2 = TentacleBodyGenerator(config)
        result2 = gen2.generate()

        np.testing.assert_array_equal(result1.vertices, result2.vertices)


class TestCreateTentacleConvenience:
    """Test convenience function."""

    def test_create_tentacle(self):
        """Test create_tentacle convenience function."""
        config = TentacleConfig()
        result = create_tentacle(config)

        assert isinstance(result, TentacleResult)
        assert result.vertex_count > 0
```

---

## Acceptance Criteria

- [ ] TentacleBodyGenerator creates mesh from config
- [ ] Taper profiles (linear, smooth, organic) implemented
- [ ] Segment distribution with uniform and variation modes
- [ ] Deterministic output with same config
- [ ] Works without Blender (numpy-only mode for testing)
- [ ] Real-time viewport preview capability
- [ ] 80%+ test coverage
