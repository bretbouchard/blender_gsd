# Phase 13.3: Blocking System

**Goal**: Rough animation pass to establish timing and key poses.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-05)

**Depends On**: Phase 13.2 (Pose Library)

**Duration**: 3-4 days

---

## Overview

Build a blocking system that supports:
- Stepped interpolation mode (no in-betweening)
- Key pose markers on timeline
- Pose thumbnails on timeline
- Copy/paste poses between frames
- Onion skinning (show adjacent poses)

**Philosophy**: Block first, refine later. Get the timing right before polish.

---

## Architecture

```
lib/animation/
├── blocking.py            # Blocking workflow tools
├── keyframe_markers.py    # Timeline markers
├── onion_skin.py          # Ghost/overlay display

configs/animation/
└── blocking/
    └── blocking_presets.yaml   # Common blocking patterns

.gsd-state/
└── blocking/
    └── thumbnails/
        └── {scene}_{frame}.png
```

---

## Data Model

### Blocking State
```yaml
# .gsd-state/blocking/scene_001_blocking.yaml
scene: scene_001
character: Hero_Rig

key_poses:
  - frame: 1
    pose_id: t_pose
    description: "Start pose"
    thumbnail: frame_001.png

  - frame: 24
    pose_id: walk_contact_L
    description: "First step - left foot contact"
    thumbnail: frame_024.png

  - frame: 48
    pose_id: walk_contact_R
    description: "Second step - right foot contact"
    thumbnail: frame_048.png

breakdowns:
  - frame: 12
    description: "Passing position"

timing_notes:
  - "Need to extend hold on frame 24"
  - "Consider speeding up steps"
```

### Types
```python
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import Enum

class InterpolationMode(Enum):
    STEPPED = "STEPPED"      # No interpolation (blocking)
    LINEAR = "LINEAR"        # Linear interpolation
    BEZIER = "BEZIER"        # Smooth curves

@dataclass
class KeyPose:
    frame: int
    pose_id: Optional[str] = None
    description: str = ""
    thumbnail_path: Optional[str] = None
    is_breakdown: bool = False

@dataclass
class BlockingSession:
    scene_name: str
    character_name: str
    key_poses: List[KeyPose] = field(default_factory=list)
    timing_notes: List[str] = field(default_factory=list)
    current_frame: int = 1
    range_start: int = 1
    range_end: int = 100

@dataclass
class OnionSkinConfig:
    show_previous: bool = True
    show_next: bool = True
    previous_frames: int = 1
    next_frames: int = 1
    previous_color: Tuple[float, float, float, float] = (0, 1, 0, 0.3)
    next_color: Tuple[float, float, float, float] = (1, 0, 0, 0.3)
    ghost_opacity: float = 0.3
```

---

## Tasks

### Task 1: Blocking Core
**File**: `lib/animation/blocking.py`

```python
import bpy
from typing import List, Optional, Dict
from .types import BlockingSession, KeyPose, InterpolationMode
from .pose_library import PoseLibrary

class BlockingSystem:
    """Manage blocking workflow for animation."""

    def __init__(self, armature: bpy.types.Object):
        self.armature = armature
        self.library = PoseLibrary()
        self.session: Optional[BlockingSession] = None

    def start_session(self, scene_name: str, range_start: int = 1, range_end: int = 100) -> None:
        """Start a new blocking session."""
        self.session = BlockingSession(
            scene_name=scene_name,
            character_name=self.armature.name,
            range_start=range_start,
            range_end=range_end
        )

    def set_interpolation_mode(self, mode: InterpolationMode) -> None:
        """Set interpolation mode for all bones."""
        for pb in self.armature.pose.bones:
            for fcurve in self._get_bone_fcurves(pb.name):
                for kf in fcurve.keyframe_points:
                    kf.interpolation = mode.value

    def set_stepped_mode(self) -> None:
        """Set stepped interpolation (blocking mode)."""
        self.set_interpolation_mode(InterpolationMode.STEPPED)

    def set_bezier_mode(self) -> None:
        """Set bezier interpolation (smooth mode)."""
        self.set_interpolation_mode(InterpolationMode.BEZIER)

    def add_key_pose(
        self,
        frame: int,
        pose_id: Optional[str] = None,
        description: str = "",
        is_breakdown: bool = False
    ) -> KeyPose:
        """Add a key pose at a frame."""
        # Set current frame
        bpy.context.scene.frame_set(frame)

        # Apply pose if specified
        if pose_id and pose_id in self.library.poses:
            self.library.apply_pose(self.armature, self.library.poses[pose_id])

        # Keyframe all bones
        self._keyframe_all_bones(frame)

        # Create key pose record
        key_pose = KeyPose(
            frame=frame,
            pose_id=pose_id,
            description=description,
            is_breakdown=is_breakdown
        )

        if self.session:
            self.session.key_poses.append(key_pose)
            self.session.key_poses.sort(key=lambda x: x.frame)

        return key_pose

    def add_breakdown(self, frame: int, description: str = "") -> KeyPose:
        """Add a breakdown pose."""
        return self.add_key_pose(frame, description=description, is_breakdown=True)

    def copy_pose_to_frame(self, source_frame: int, target_frame: int) -> None:
        """Copy pose from one frame to another."""
        bpy.context.scene.frame_set(source_frame)
        bpy.context.view_layer.update()

        # Store current pose
        from .pose_library import PoseLibrary
        temp_pose = self.library.capture_pose(self.armature, "temp")

        # Go to target frame and apply
        bpy.context.scene.frame_set(target_frame)
        self.library.apply_pose(self.armature, temp_pose)
        self._keyframe_all_bones(target_frame)

    def delete_key_pose(self, frame: int) -> None:
        """Delete key pose at frame."""
        # Remove keyframes
        for pb in self.armature.pose.bones:
            self._delete_keyframe_at_frame(pb.name, frame)

        # Remove from session
        if self.session:
            self.session.key_poses = [
                kp for kp in self.session.key_poses if kp.frame != frame
            ]

    def get_key_poses(self) -> List[KeyPose]:
        """Get all key poses."""
        return self.session.key_poses if self.session else []

    def get_next_key_frame(self, current_frame: int) -> Optional[int]:
        """Get the next key frame after current."""
        if not self.session:
            return None

        for kp in self.session.key_poses:
            if kp.frame > current_frame:
                return kp.frame
        return None

    def get_prev_key_frame(self, current_frame: int) -> Optional[int]:
        """Get the previous key frame before current."""
        if not self.session:
            return None

        for kp in reversed(self.session.key_poses):
            if kp.frame < current_frame:
                return kp.frame
        return None

    def _keyframe_all_bones(self, frame: int) -> None:
        """Keyframe all bones at frame."""
        bpy.context.scene.frame_set(frame)

        for pb in self.armature.pose.bones:
            pb.keyframe_insert(data_path="location", frame=frame)
            pb.keyframe_insert(data_path="rotation_euler", frame=frame)
            pb.keyframe_insert(data_path="scale", frame=frame)

    def _get_bone_fcurves(self, bone_name: str) -> list:
        """Get all fcurves for a bone."""
        if not self.armature.animation_data:
            return []
        if not self.armature.animation_data.action:
            return []

        fcurves = []
        prefix = f'pose.bones["{bone_name}"].'

        for fcurve in self.armature.animation_data.action.fcurves:
            if fcurve.data_path.startswith(prefix):
                fcurves.append(fcurve)

        return fcurves

    def _delete_keyframe_at_frame(self, bone_name: str, frame: int) -> None:
        """Delete keyframe at frame for a bone."""
        for fcurve in self._get_bone_fcurves(bone_name):
            for kp in fcurve.keyframe_points:
                if kp.co.x == frame:
                    fcurve.keyframe_points.remove(kp)
                    break


def start_blocking(armature: bpy.types.Object, start: int = 1, end: int = 100) -> BlockingSystem:
    """Start blocking session."""
    system = BlockingSystem(armature)
    system.start_session("blocking", start, end)
    system.set_stepped_mode()
    return system
```

**Acceptance**: Can create stepped key poses

---

### Task 2: Keyframe Markers
**File**: `lib/animation/keyframe_markers.py`

```python
import bpy
from typing import List, Dict, Optional
from .blocking import KeyPose

class KeyPoseMarkers:
    """Manage timeline markers for key poses."""

    @staticmethod
    def add_marker(frame: int, name: str, color: tuple = (1, 1, 1)) -> bpy.types.TimelineMarker:
        """Add a timeline marker."""
        markers = bpy.context.scene.timeline_markers
        marker = markers.new(name, frame=frame)
        marker.color = color
        return marker

    @staticmethod
    def add_key_pose_marker(key_pose: KeyPose) -> bpy.types.TimelineMarker:
        """Add marker for a key pose."""
        color = (0.2, 0.8, 0.2) if not key_pose.is_breakdown else (0.8, 0.8, 0.2)
        name = f"KP_{key_pose.frame}"
        if key_pose.description:
            name = key_pose.description[:20]

        return KeyPoseMarkers.add_marker(key_pose.frame, name, color)

    @staticmethod
    def remove_marker(frame: int) -> None:
        """Remove marker at frame."""
        markers = bpy.context.scene.timeline_markers
        for marker in markers:
            if marker.frame == frame:
                markers.remove(marker)
                break

    @staticmethod
    def get_marker_at_frame(frame: int) -> Optional[bpy.types.TimelineMarker]:
        """Get marker at frame."""
        for marker in bpy.context.scene.timeline_markers:
            if marker.frame == frame:
                return marker
        return None

    @staticmethod
    def clear_all_markers() -> None:
        """Clear all markers."""
        markers = bpy.context.scene.timeline_markers
        while markers:
            markers.remove(markers[0])

    @staticmethod
    def sync_markers_with_key_poses(key_poses: List[KeyPose]) -> None:
        """Sync timeline markers with key poses."""
        # Clear existing markers
        KeyPoseMarkers.clear_all_markers()

        # Add markers for each key pose
        for kp in key_poses:
            KeyPoseMarkers.add_key_pose_marker(kp)

    @staticmethod
    def jump_to_next_marker() -> None:
        """Jump to next marker."""
        current = bpy.context.scene.frame_current
        markers = sorted(bpy.context.scene.timeline_markers, key=lambda m: m.frame)

        for marker in markers:
            if marker.frame > current:
                bpy.context.scene.frame_set(marker.frame)
                return

    @staticmethod
    def jump_to_prev_marker() -> None:
        """Jump to previous marker."""
        current = bpy.context.scene.frame_current
        markers = sorted(bpy.context.scene.timeline_markers, key=lambda m: m.frame, reverse=True)

        for marker in markers:
            if marker.frame < current:
                bpy.context.scene.frame_set(marker.frame)
                return


class PoseThumbnails:
    """Generate and manage pose thumbnails."""

    @staticmethod
    def capture_thumbnail(armature: bpy.types.Object, frame: int, output_path: str) -> str:
        """Capture a thumbnail of the pose at frame."""
        import os

        # Set frame
        bpy.context.scene.frame_set(frame)

        # Find camera or create temporary
        camera = bpy.context.scene.camera
        if not camera:
            # Create temp camera
            cam_data = bpy.data.cameras.new("temp_thumb_cam")
            camera = bpy.data.objects.new("temp_thumb_cam", cam_data)
            bpy.context.collection.objects.link(camera)
            camera.location = (5, -5, 3)
            camera.rotation_euler = (1.1, 0, 0.785)
            bpy.context.scene.camera = camera

        # Set render settings
        original_res = (bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y)
        bpy.context.scene.render.resolution_x = 256
        bpy.context.scene.render.resolution_y = 256
        bpy.context.scene.render.film_transparent = True

        # Render
        bpy.context.scene.render.filepath = output_path
        bpy.ops.render.render(write_still=True)

        # Restore settings
        bpy.context.scene.render.resolution_x, bpy.context.scene.render.resolution_y = original_res

        return output_path

    @staticmethod
    def generate_all_thumbnails(armature: bpy.types.Object, key_poses: List[KeyPose], output_dir: str) -> Dict[int, str]:
        """Generate thumbnails for all key poses."""
        import os

        os.makedirs(output_dir, exist_ok=True)
        thumbnails = {}

        for kp in key_poses:
            filename = f"frame_{kp.frame:04d}.png"
            filepath = os.path.join(output_dir, filename)
            thumbnails[kp.frame] = PoseThumbnails.capture_thumbnail(armature, kp.frame, filepath)
            kp.thumbnail_path = filepath

        return thumbnails
```

**Acceptance**: Markers and thumbnails work

---

### Task 3: Onion Skinning
**File**: `lib/animation/onion_skin.py`

```python
import bpy
from typing import List, Tuple, Optional
from .types import OnionSkinConfig

class OnionSkinning:
    """Display ghost poses before/after current frame."""

    def __init__(self, armature: bpy.types.Object, config: Optional[OnionSkinConfig] = None):
        self.armature = armature
        self.config = config or OnionSkinConfig()
        self.ghost_objects: List[bpy.types.Object] = []

    def enable(self) -> None:
        """Enable onion skinning."""
        self.update()

    def disable(self) -> None:
        """Disable onion skinning and remove ghosts."""
        self._clear_ghosts()

    def update(self) -> None:
        """Update onion skin display for current frame."""
        self._clear_ghosts()

        current_frame = bpy.context.scene.frame_current

        # Show previous frames
        if self.config.show_previous:
            for i in range(1, self.config.previous_frames + 1):
                frame = current_frame - i
                if frame >= 1:
                    self._create_ghost(frame, self.config.previous_color, "prev")

        # Show next frames
        if self.config.show_next:
            for i in range(1, self.config.next_frames + 1):
                frame = current_frame + i
                self._create_ghost(frame, self.config.next_color, "next")

    def _create_ghost(self, frame: int, color: Tuple, prefix: str) -> bpy.types.Object:
        """Create a ghost mesh at frame."""
        # Set frame to get pose
        original_frame = bpy.context.scene.frame_current
        bpy.context.scene.frame_set(frame)
        bpy.context.view_layer.update()

        # Duplicate mesh with armature modifier applied
        for child in self.armature.children:
            if child.type == 'MESH':
                # Select and duplicate
                bpy.ops.object.select_all(action='DESELECT')
                child.select_set(True)
                bpy.context.view_layer.objects.active = child
                bpy.ops.object.duplicate()

                ghost = bpy.context.active_object
                ghost.name = f"ghost_{prefix}_{frame}"

                # Remove armature modifier, apply as mesh
                for mod in ghost.modifiers:
                    if mod.type == 'ARMATURE':
                        ghost.modifiers.remove(mod)

                # Create material for ghost
                mat = bpy.data.materials.new(name=f"ghost_mat_{prefix}")
                mat.use_nodes = True
                bsdf = mat.node_tree.nodes["Principled BSDF"]
                bsdf.inputs['Base Color'].default_value = color[:3]
                bsdf.inputs['Alpha'].default_value = color[3]
                mat.blend_method = 'BLEND'
                mat.shadow_method = 'NONE'

                # Assign material
                if ghost.data.materials:
                    ghost.data.materials[0] = mat
                else:
                    ghost.data.materials.append(mat)

                # Make non-selectable
                ghost.hide_select = True
                ghost.show_wire = True

                self.ghost_objects.append(ghost)

        # Restore frame
        bpy.context.scene.frame_set(original_frame)

        return ghost

    def _clear_ghosts(self) -> None:
        """Remove all ghost objects."""
        for ghost in self.ghost_objects:
            if ghost.name in bpy.data.objects:
                bpy.data.objects.remove(ghost, do_unlink=True)

        self.ghost_objects = []

    def set_range(self, previous: int, next: int) -> None:
        """Set onion skin range."""
        self.config.previous_frames = previous
        self.config.next_frames = next
        self.update()

    def set_colors(self, previous_color: Tuple, next_color: Tuple) -> None:
        """Set onion skin colors."""
        self.config.previous_color = previous_color
        self.config.next_color = next_color
        self.update()


def enable_onion_skin(armature: bpy.types.Object, prev_frames: int = 1, next_frames: int = 1) -> OnionSkinning:
    """Enable onion skinning for armature."""
    config = OnionSkinConfig(
        previous_frames=prev_frames,
        next_frames=next_frames
    )
    skinning = OnionSkinning(armature, config)
    skinning.enable()
    return skinning
```

**Acceptance**: Onion skinning shows ghosts

---

## Acceptance Criteria

### Must Have
- [ ] Stepped interpolation mode
- [ ] Add key poses at frames
- [ ] Copy pose between frames
- [ ] Timeline markers for key poses
- [ ] Jump between key poses

### Nice to Have
- [ ] Pose thumbnails
- [ ] Onion skinning
- [ ] Breakdown poses
- [ ] Timing notes

---

## Commands

```python
# Start blocking session
from lib.animation import start_blocking
blocking = start_blocking(armature, start=1, end=100)

# Add key poses
blocking.add_key_pose(1, "t_pose", "Start pose")
blocking.add_key_pose(24, "walk_contact_L", "First step")
blocking.add_breakdown(12, "Passing position")

# Copy pose
blocking.copy_pose_to_frame(1, 100)

# Enable onion skin
from lib.animation import enable_onion_skin
skinning = enable_onion_skin(armature, prev_frames=2, next_frames=2)
```

---

## AI Commands Reference

```
# Start blocking
"Start blocking session for hero character, frames 1-100"

# Add key pose
"Add key pose at frame 24 using walk_contact pose"

# Add breakdown
"Add breakdown at frame 12"

# Enable onion skin
"Show onion skin for 2 frames before and after"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Render Rick - Viewport Performance

1. **Onion Skinning Performance**
   - Each ghost duplicates mesh with armature applied
   - With 5+ ghosts on high-poly character, viewport may lag
   - Recommendation: Limit default to 2 frames before/after
   - Add option to use wireframe-only ghosts for heavy scenes

2. **Ghost Material Strategy**
   - Current: Creates new material per ghost
   - Issue: Material slot explosion with many ghosts
   - Recommendation: Use single shared material with object color

3. **Memory Considerations**
   - Ghosts remain until `disable()` called
   - Add auto-cleanup when changing frames significantly
   - Consider object pool for ghost reuse

### Dufus Rick - Testing Recommendations

4. **Test Tasks to Add**
   - Task: Test onion skinning with 50k+ poly mesh
   - Task: Verify ghost cleanup on disable
   - Task: Test marker synchronization with key poses
   - Task: Verify stepped interpolation mode toggle

5. **Acceptance Criteria Improvements**
   - "Onion skinning shows ghosts" → "Onion skinning shows ghosts within 100ms"
   - Add performance benchmark for ghost creation
