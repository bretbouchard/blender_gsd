# Phase 13.1: Pixel Converter

**Phase**: 13.1
**Priority**: P0
**Dependencies**: Phase 6.x (Core Cinematic)
**Est. Duration**: 3-4 days

---

## Goal

Implement pixel art conversion system that transforms photorealistic renders into stylized pixel art across multiple retro console styles.

---

## Requirements

- REQ-RETRO-01: Multiple pixel style modes
- REQ-RETRO-02: Resolution downscaling with aspect ratio preservation
- RET-RETRO-03: Edge-aware pixelation
- REQ-RETRO-04: Integration with compositor pipeline

---

## Plans

### Plan 13.1-01: Pixel Types

**Deliverable**: `lib/retro/pixel_types.py`

```python
@dataclass
class PixelStyle:
    """Pixel art style configuration."""
    mode: str = "16bit"  # photorealistic, stylized, 32bit, 16bit, 8bit, 4bit, 2bit, 1bit
    pixel_size: int = 1
    color_limit: int = 256
    preserve_edges: bool = True
    posterize_levels: int = 0  # 0 = disabled

    # Sub-pixel settings
    sub_pixel_layout: str = "rgb"  # rgb, bgr, for LCD simulation

@dataclass
class PixelationConfig:
    """Complete pixelation configuration."""
    style: PixelStyle
    target_resolution: Tuple[int, int]
    aspect_ratio_mode: str = "preserve"  # preserve, stretch, crop
    scaling_filter: str = "nearest"  # nearest, bilinear, lanczos

    # Edge detection
    edge_detection: bool = True
    edge_threshold: float = 0.1
    edge_enhancement: float = 0.0

    # Output
    output_scale: int = 1  # Integer scale for final output

@dataclass
class PixelationResult:
    """Result of pixelation process."""
    image: Any  # PIL Image or numpy array
    original_resolution: Tuple[int, int]
    pixel_resolution: Tuple[int, int]
    color_count: int
    processing_time: float
```

**Tasks**:
1. Create all dataclasses
2. Add validation methods
3. Add presets for each mode

---

### Plan 13.1-02: Pixelation Engine

**Deliverable**: `lib/retro/pixelator.py`

```python
def pixelate(image: Any, config: PixelationConfig) -> PixelationResult:
    """Main pixelation function."""
    pass

def downscale_image(image: Any, target_size: Tuple[int, int], filter: str) -> Any:
    """Downscale image to target resolution."""
    pass

def pixelate_block(image: Any, block_size: int) -> Any:
    """Apply block pixelation (average color per block)."""
    pass

def enhance_edges(image: Any, threshold: float, strength: float) -> Any:
    """Detect and enhance edges before pixelation."""
    pass

def posterize(image: Any, levels: int) -> Any:
    """Reduce color levels for posterized look."""
    pass

# Mode-specific functions

def pixelate_16bit(image: Any, config: PixelationConfig) -> Any:
    """16-bit style (SNES/Genesis)."""
    # 320x240 max, smooth gradients
    pass

def pixelate_8bit(image: Any, config: PixelationConfig) -> Any:
    """8-bit style (NES/Master System)."""
    # Limited colors, visible pixels
    pass

def pixelate_4bit(image: Any, config: PixelationConfig) -> Any:
    """4-bit style (Game Boy)."""
    # 4 colors, chunky pixels
    pass

def pixelate_1bit(image: Any, config: PixelationConfig) -> Any:
    """1-bit style (Mac Plus, LCD)."""
    # Pure black and white, dithered
    pass
```

**Tasks**:
1. Implement main pixelate function
2. Implement downscaling with filters
3. Implement block pixelation
4. Implement edge detection/enhancement
5. Implement posterize
6. Implement each mode function
7. Test with various inputs

---

### Plan 13.1-03: Color Quantization

**Deliverable**: `lib/retro/quantizer.py`

```python
def quantize_colors(image: Any, color_count: int, method: str = "median_cut") -> Any:
    """Reduce image to specified number of colors."""
    pass

def quantize_to_palette(image: Any, palette: List[Tuple[int, int, int]]) -> Any:
    """Reduce image to specific palette."""
    pass

def extract_palette(image: Any, count: int) -> List[Tuple[int, int, int]]:
    """Extract dominant colors from image."""
    pass

# Quantization methods

def median_cut_quantize(image: Any, colors: int) -> Any:
    """Median cut color quantization."""
    pass

def kmeans_quantize(image: Any, colors: int) -> Any:
    """K-means color quantization."""
    pass

def octree_quantize(image: Any, colors: int) -> Any:
    """Octree color quantization (faster)."""
    pass

def nearest_color_match(image: Any, palette: List[Tuple[int, int, int]]) -> Any:
    """Match each pixel to nearest palette color."""
    pass
```

**Tasks**:
1. Implement median cut
2. Implement k-means
3. Implement octree
4. Implement palette matching
5. Implement palette extraction
6. Benchmark performance

---

### Plan 13.1-04: Presets & Profiles

**Deliverable**: `configs/cinematic/retro/pixel_profiles.yaml`

```yaml
profiles:
  # Modern pixel art
  modern_pixel:
    style:
      mode: "stylized"
      pixel_size: 4
      color_limit: 256
      preserve_edges: true
      posterize_levels: 8
    scaling_filter: "nearest"

  # SNES style
  snes:
    style:
      mode: "16bit"
      pixel_size: 2
      color_limit: 256
      preserve_edges: true
    target_resolution: [256, 224]
    scaling_filter: "nearest"

  # NES style
  nes:
    style:
      mode: "8bit"
      pixel_size: 2
      color_limit: 54  # NES usable colors
      preserve_edges: true
      posterize_levels: 4
    target_resolution: [256, 240]
    scaling_filter: "nearest"

  # Game Boy style
  gameboy:
    style:
      mode: "4bit"
      pixel_size: 3
      color_limit: 4
      preserve_edges: true
    target_resolution: [160, 144]
    scaling_filter: "nearest"

  # Mac Plus 1-bit
  mac_plus:
    style:
      mode: "1bit"
      pixel_size: 1
      color_limit: 2
      preserve_edges: false
    target_resolution: [512, 342]
    scaling_filter: "nearest"

  # PICO-8 fantasy console
  pico8:
    style:
      mode: "8bit"
      pixel_size: 4
      color_limit: 16
      preserve_edges: true
    target_resolution: [128, 128]
    scaling_filter: "nearest"
```

**Tasks**:
1. Create preset file
2. Implement preset loader
3. Create examples for each style
4. Document each preset

---

### Plan 13.1-05: Compositor Integration

**Deliverable**: `lib/retro/pixel_compositor.py`

```python
def create_pixelator_nodes(node_tree: Any, config: PixelationConfig) -> Any:
    """Create Blender compositor nodes for pixelation."""
    pass

def setup_pixelator_pass(node_tree: Any, config: PixelationConfig) -> str:
    """Set up pixelation as render pass."""
    pass

def bake_pixelation(render_path: str, config: PixelationConfig, output_path: str) -> None:
    """Apply pixelation to rendered image."""
    pass

# Node-based approach for real-time preview

def create_scale_node(node_tree: Any, scale: float, filter: str) -> Any:
    """Create scale node for down/upscaling."""
    pass

def create_posterize_node(node_tree: Any, levels: int) -> Any:
    """Create posterize node."""
    pass
```

**Tasks**:
1. Implement node creation
2. Implement render pass setup
3. Implement baking
4. Test in Blender
5. Update __init__.py

---

## Acceptance Criteria

- [ ] All 8 pixel modes work correctly
- [ ] Resolution scaling preserves aspect ratio
- [ ] Edge detection improves pixel clarity
- [ ] Color quantization matches target limits
- [ ] Compositor integration works in Blender
- [ ] Presets produce expected results

---

## Files

```
lib/retro/
├── __init__.py
├── pixel_types.py         # Data structures
├── pixelator.py           # Main pixelation
├── quantizer.py           # Color reduction
└── pixel_compositor.py    # Blender integration

configs/cinematic/retro/
├── pixel_profiles.yaml    # Style presets
└── examples/
    └── comparison.yaml    # Side-by-side examples
```
