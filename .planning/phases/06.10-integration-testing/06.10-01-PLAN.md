---
phase: 06.10-integration-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/types.py
  - lib/cinematic/preset_loader.py
autonomous: true

must_haves:
  truths:
    - "IntegrationConfig connects cinematic with control surface system"
    - "End-to-end test configurations supported"
    - "Performance benchmarks defined"
  artifacts:
    - path: "lib/cinematic/types.py"
      provides: "Integration and test configuration types"
      contains: "IntegrationConfig"
    - path: "lib/cinematic/preset_loader.py"
      provides: "Integration test preset loaders"
  key_links:
    - from: "lib/cinematic/"
      to: "lib/controls/"
      via: "IntegrationConfig"
---

<objective>
Add integration and test configuration types for Phase 6.10.

Purpose: Provide type definitions for control surface integration, end-to-end testing, and performance benchmarking.
Output: IntegrationConfig, TestConfig, PerformanceConfig dataclasses.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns
@lib/cinematic/types.py
@lib/cinematic/preset_loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add integration and test types to types.py</name>
  <files>lib/cinematic/types.py</files>
  <action>
Add integration and test dataclasses after CameraProfile (around line 1994).

```python
@dataclass
class IntegrationConfig:
    """
    Integration configuration for connecting cinematic with control surfaces.

    Defines how the cinematic rendering system integrates with the
    control surface design system for unified product visualization.

    Attributes:
        control_surface_preset: Control surface style preset name
        apply_to_subject: Apply control surface materials to subject
        sync_animations: Synchronize control surface animations with camera
        auto_frame_subject: Automatically frame control surface in camera
        material_sync: Sync material properties between systems
        render_modes: Available render modes (hero, catalog, turntable)
    """
    control_surface_preset: str = ""
    apply_to_subject: bool = True
    sync_animations: bool = True
    auto_frame_subject: bool = True
    material_sync: bool = True
    render_modes: List[str] = field(default_factory=lambda: ["hero", "catalog", "turntable"])

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "control_surface_preset": self.control_surface_preset,
            "apply_to_subject": self.apply_to_subject,
            "sync_animations": self.sync_animations,
            "auto_frame_subject": self.auto_frame_subject,
            "material_sync": self.material_sync,
            "render_modes": self.render_modes,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IntegrationConfig":
        """Create from dictionary."""
        return cls(
            control_surface_preset=data.get("control_surface_preset", ""),
            apply_to_subject=data.get("apply_to_subject", True),
            sync_animations=data.get("sync_animations", True),
            auto_frame_subject=data.get("auto_frame_subject", True),
            material_sync=data.get("material_sync", True),
            render_modes=data.get("render_modes", ["hero", "catalog", "turntable"]),
        )


@dataclass
class TestConfig:
    """
    Test configuration for end-to-end rendering tests.

    Defines test scenarios for validating the cinematic system.

    Attributes:
        name: Test name
        description: Test description
        shot_config: Shot configuration to test
        expected_passes: List of expected render passes
        validation_checks: List of validation checks to perform
        tolerance: Comparison tolerance for validation
        reference_image: Optional reference image for comparison
    """
    name: str = ""
    description: str = ""
    shot_config: Dict[str, Any] = field(default_factory=dict)
    expected_passes: List[str] = field(default_factory=lambda: ["combined"])
    validation_checks: List[str] = field(default_factory=list)
    tolerance: float = 0.01
    reference_image: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "name": self.name,
            "description": self.description,
            "shot_config": self.shot_config,
            "expected_passes": self.expected_passes,
            "validation_checks": self.validation_checks,
            "tolerance": self.tolerance,
            "reference_image": self.reference_image,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "TestConfig":
        """Create from dictionary."""
        return cls(
            name=data.get("name", ""),
            description=data.get("description", ""),
            shot_config=data.get("shot_config", {}),
            expected_passes=data.get("expected_passes", ["combined"]),
            validation_checks=data.get("validation_checks", []),
            tolerance=data.get("tolerance", 0.01),
            reference_image=data.get("reference_image", ""),
        )


@dataclass
class PerformanceConfig:
    """
    Performance benchmarking configuration.

    Defines performance targets and measurement parameters.

    Attributes:
        target_render_time_preview: Target time for preview renders (seconds)
        target_render_time_production: Target time for production renders (seconds/frame)
        target_orbit_animation_time: Target for orbit animation setup (ms)
        target_shot_assembly_time: Target for shot assembly (ms)
        memory_limit_mb: Maximum memory usage (MB)
        gpu_utilization_target: Target GPU utilization (0-1)
        enable_profiling: Enable performance profiling
        profile_output: Path to save profiling data
    """
    target_render_time_preview: float = 10.0
    target_render_time_production: float = 120.0
    target_orbit_animation_time: float = 50.0
    target_shot_assembly_time: float = 100.0
    memory_limit_mb: int = 4096
    gpu_utilization_target: float = 0.8
    enable_profiling: bool = False
    profile_output: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "target_render_time_preview": self.target_render_time_preview,
            "target_render_time_production": self.target_render_time_production,
            "target_orbit_animation_time": self.target_orbit_animation_time,
            "target_shot_assembly_time": self.target_shot_assembly_time,
            "memory_limit_mb": self.memory_limit_mb,
            "gpu_utilization_target": self.gpu_utilization_target,
            "enable_profiling": self.enable_profiling,
            "profile_output": self.profile_output,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PerformanceConfig":
        """Create from dictionary."""
        return cls(
            target_render_time_preview=data.get("target_render_time_preview", 10.0),
            target_render_time_production=data.get("target_render_time_production", 120.0),
            target_orbit_animation_time=data.get("target_orbit_animation_time", 50.0),
            target_shot_assembly_time=data.get("target_shot_assembly_time", 100.0),
            memory_limit_mb=data.get("memory_limit_mb", 4096),
            gpu_utilization_target=data.get("gpu_utilization_target", 0.8),
            enable_profiling=data.get("enable_profiling", False),
            profile_output=data.get("profile_output", ""),
        )


@dataclass
class BenchmarkResult:
    """
    Performance benchmark result.

    Stores timing and resource usage measurements.

    Attributes:
        name: Benchmark name
        duration_seconds: Total duration in seconds
        memory_peak_mb: Peak memory usage in MB
        gpu_utilization: Average GPU utilization (0-1)
        frames_rendered: Number of frames rendered
        passes_generated: Number of passes generated
        timestamp: ISO timestamp of benchmark
        passed: Whether benchmark passed performance targets
    """
    name: str = ""
    duration_seconds: float = 0.0
    memory_peak_mb: float = 0.0
    gpu_utilization: float = 0.0
    frames_rendered: int = 0
    passes_generated: int = 0
    timestamp: str = ""
    passed: bool = True

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "name": self.name,
            "duration_seconds": self.duration_seconds,
            "memory_peak_mb": self.memory_peak_mb,
            "gpu_utilization": self.gpu_utilization,
            "frames_rendered": self.frames_rendered,
            "passes_generated": self.passes_generated,
            "timestamp": self.timestamp,
            "passed": self.passed,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BenchmarkResult":
        """Create from dictionary."""
        return cls(
            name=data.get("name", ""),
            duration_seconds=data.get("duration_seconds", 0.0),
            memory_peak_mb=data.get("memory_peak_mb", 0.0),
            gpu_utilization=data.get("gpu_utilization", 0.0),
            frames_rendered=data.get("frames_rendered", 0),
            passes_generated=data.get("passes_generated", 0),
            timestamp=data.get("timestamp", ""),
            passed=data.get("passed", True),
        )
```
  </action>
  <verify>python3 -c "
from lib.cinematic.types import IntegrationConfig, TestConfig, PerformanceConfig, BenchmarkResult

# Test instantiation
ic = IntegrationConfig(control_surface_preset='neve_classic')
assert ic.control_surface_preset == 'neve_classic'
assert ic.apply_to_subject == True

tc = TestConfig(name='test_hero_shot', validation_checks=['camera_exists', 'lights_exist'])
assert tc.name == 'test_hero_shot'
assert len(tc.validation_checks) == 2

pc = PerformanceConfig(target_render_time_preview=5.0)
assert pc.target_render_time_preview == 5.0

br = BenchmarkResult(name='benchmark_1', duration_seconds=10.5, passed=True)
assert br.duration_seconds == 10.5

# Test round-trip
data = ic.to_dict()
ic2 = IntegrationConfig.from_dict(data)
assert ic2.control_surface_preset == ic.control_surface_preset

print('Integration and test types OK')
"</verify>
  <done>IntegrationConfig, TestConfig, PerformanceConfig, BenchmarkResult dataclasses</done>
</task>

</tasks>

<verification>
1. IntegrationConfig with control surface integration settings
2. TestConfig with test scenario definition
3. PerformanceConfig with benchmark targets
4. BenchmarkResult for storing results
</verification>

<success_criteria>
- All four dataclasses serialize correctly
- Pattern matches existing types
</success_criteria>

<output>
After completion, create `.planning/phases/06.10-integration-testing/06.10-01-SUMMARY.md`
</output>
