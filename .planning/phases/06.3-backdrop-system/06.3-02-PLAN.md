---
phase: 06.3-backdrop-system
plan: 02
type: execute
wave: 2
depends_on: ["06.3-01"]
files_modified:
  - lib/cinematic/backdrops.py
autonomous: true

must_haves:
  truths:
    - "User can create infinite curve backdrop with gradient material"
    - "User can create HDRI backdrop using existing HDRI system"
    - "Shadow catcher mode produces correct alpha in render"
    - "Gradient material changes color based on Z position"
    - "Backdrop geometry has no visible seams"
  artifacts:
    - path: "lib/cinematic/backdrops.py"
      provides: "Core backdrop creation functions"
      exports: ["create_infinite_curve", "create_gradient_material", "setup_shadow_catcher", "create_backdrop", "create_backdrop_from_preset"]
      min_lines: 250
  key_links:
    - from: "lib/cinematic/backdrops.py"
      to: "lib/cinematic/types.py"
      via: "BackdropConfig"
      pattern: "BackdropConfig"
    - from: "lib/cinematic/backdrops.py"
      to: "lib/cinematic/hdri.py"
      via: "setup_hdri, load_hdri_preset"
      pattern: "from \.hdri import"
    - from: "lib/cinematic/backdrops.py"
      to: "bpy"
      via: "bmesh"
      pattern: "bmesh\\.new"
---

<objective>
Create the core backdrop module with infinite curve geometry, HDRI backdrop support, and shadow catcher configuration.

Purpose: Implement procedural infinite curve geometry generation using bmesh, HDRI backdrop via the existing hdri.py module, gradient shader materials, and shadow catcher support. This is the core visual functionality for product photography backdrops.
Output: New backdrops.py module with create_infinite_curve(), create_gradient_material(), setup_shadow_catcher(), create_backdrop(), and create_backdrop_from_preset() functions.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference the prior plan for extended types
@.planning/phases/06.3-backdrop-system/06.3-01-PLAN.md

# Existing patterns to follow
@lib/cinematic/types.py
@lib/cinematic/lighting.py
@lib/cinematic/hdri.py

# Research findings - contains complete code examples
@.planning/phases/06.3-backdrop-system/06.3-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backdrops.py with infinite curve geometry</name>
  <files>lib/cinematic/backdrops.py</files>
  <action>
Create a new module `lib/cinematic/backdrops.py` implementing infinite curve backdrop generation using bmesh.

Follow the guarded bpy import pattern from lighting.py:
```python
try:
    import bpy
    import bmesh
    import mathutils
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    bmesh = None
    mathutils = None
    BLENDER_AVAILABLE = False
```

Implement `create_infinite_curve()` function based on the algorithm in RESEARCH.md:

```python
def create_infinite_curve(
    name: str = "gsd_backdrop",
    radius: float = 5.0,
    curve_height: float = 3.0,
    curve_segments: int = 32,
    depth: float = 10.0  # Y-axis extent
) -> Optional[bpy.types.Object]:
```

Key implementation details:
1. Use bmesh.new() to build geometry procedurally
2. Generate floor vertices along X axis at Z=0
3. Generate curve vertices using quarter circle formula (sin/cos)
4. Generate wall vertices at height curve_height
5. Connect faces ensuring proper winding order
6. Use bm.to_mesh() and bm.free()
7. Link object to current collection

Do NOT use bpy.ops.mesh - use bmesh directly for context-free operation.

Return None if BLENDER_AVAILABLE is False or on any exception.
  </action>
  <verify>python3 -c "from lib.cinematic.backdrops import create_infinite_curve, BLENDER_AVAILABLE; print(f'BLENDER_AVAILABLE={BLENDER_AVAILABLE}'); print('Module loads OK')"</verify>
  <done>Infinite curve geometry function implemented with bmesh pattern</done>
</task>

<task type="auto">
  <name>Task 2: Implement gradient material creation</name>
  <files>lib/cinematic/backdrops.py</files>
  <action>
Add `create_gradient_material()` function to backdrops.py following the shader node pattern from RESEARCH.md.

```python
def create_gradient_material(
    name: str = "gsd_backdrop_mat",
    color_bottom: Tuple[float, float, float] = (0.95, 0.95, 0.95),
    color_top: Tuple[float, float, float] = (1.0, 1.0, 1.0),
    gradient_height: float = 3.0
) -> Optional[bpy.types.Material]:
```

Node tree structure (from RESEARCH.md):
1. ShaderNodeNewGeometry (Position output)
2. ShaderNodeSeparateXYZ (Z channel)
3. ShaderNodeMath (DIVIDE operation, divisor = gradient_height)
4. ShaderNodeValToRGB (ColorRamp for gradient)
5. ShaderNodeBsdfPrincipled (Base Color from ramp)
6. ShaderNodeOutputMaterial

Set color ramp interpolation to 'LINEAR' to avoid banding.
Position nodes in a clean horizontal layout.
Return None if BLENDER_AVAILABLE is False or on exception.

Also add `apply_gradient_material(obj, color_bottom, color_top, gradient_height)` helper that creates material and assigns to object.
  </action>
  <verify>python3 -c "from lib.cinematic.backdrops import create_gradient_material, apply_gradient_material; print('Gradient material functions OK')"</verify>
  <done>Gradient shader material creation with Z-position based coloring</done>
</task>

<task type="auto">
  <name>Task 3: Implement shadow catcher configuration</name>
  <files>lib/cinematic/backdrops.py</files>
  <action>
Add shadow catcher configuration functions to backdrops.py following the pattern from RESEARCH.md.

```python
def setup_shadow_catcher(
    obj: bpy.types.Object,
    enabled: bool = True
) -> bool:
    """Configure object as shadow catcher for alpha compositing."""

def configure_render_for_shadow_catcher(
    scene: Optional[bpy.types.Scene] = None
) -> bool:
    """Configure render settings for shadow catcher output."""
```

For setup_shadow_catcher():
- Set obj.is_shadow_catcher = enabled (Cycles property)
- If material exists: mat.shadow_method = 'CLIP', mat.use_backface_culling = True
- Return True on success, False on failure

For configure_render_for_shadow_catcher():
- Get scene from bpy.context.scene if not provided
- Set scene.render.film_transparent = True
- Enable view_layer.use_pass_shadow = True
- Return True on success, False on failure

CRITICAL: shadow_method must be 'CLIP' (not 'HASHED') for clean shadow edges per design requirements.
  </action>
  <verify>python3 -c "from lib.cinematic.backdrops import setup_shadow_catcher, configure_render_for_shadow_catcher; print('Shadow catcher functions OK')"</verify>
  <done>Shadow catcher setup with correct render settings for alpha output</done>
</task>

<task type="auto">
  <name>Task 4: Add create_backdrop() convenience function with HDRI support</name>
  <files>lib/cinematic/backdrops.py</files>
  <action>
Add a main `create_backdrop()` function that orchestrates geometry, material, and shadow catcher setup, including HDRI backdrop support.

```python
def create_backdrop(
    config: Optional[BackdropConfig] = None,
    **kwargs
) -> Optional[bpy.types.Object]:
```

Accept either a BackdropConfig object or keyword arguments. If config is None, create one from kwargs.

Implementation for each backdrop_type:
1. `backdrop_type == "infinite_curve"`:
   - Call create_infinite_curve() with config parameters
   - Apply gradient material using apply_gradient_material()
   - If config.shadow_catcher: call setup_shadow_catcher() and configure_render_for_shadow_catcher()
   - Return the created object

2. `backdrop_type == "hdri"`:
   - Import and delegate to the existing hdri.py module
   - If config.hdri_preset is set: call load_hdri_preset(config.hdri_preset)
   - Otherwise: call setup_hdri() with HDRI file path from config
   - Return None (HDRI backdrops modify world settings, not objects)

3. Other types (gradient, mesh): Log warning and return None (future implementation)

Also add:
- `create_backdrop_from_preset(preset_name: str) -> Optional[bpy.types.Object]`
  - Load preset and call create_backdrop
  - **Dispatch logic to determine which preset file to load:**
    1. Try get_infinite_curve_preset(preset_name) first - if found, create BackdropConfig with backdrop_type="infinite_curve"
    2. Try get_gradient_preset(preset_name) - if found, create BackdropConfig with backdrop_type="gradient"
    3. Try get_environment_preset(preset_name) - if found, create BackdropConfig with backdrop_type="hdri" and set hdri_preset
    4. If none found, raise ValueError with available presets
  - Handle ValueError from preset loaders gracefully by trying next type

- `delete_backdrop(name: str = "gsd_backdrop") -> bool` - removes backdrop object and material
- `get_backdrop(name: str = "gsd_backdrop") -> Optional[bpy.types.Object]` - retrieves existing backdrop

Import BackdropConfig from .types and preset loaders from .preset_loader.
Import setup_hdri and load_hdri_preset from .hdri for HDRI backdrop type.
  </action>
  <verify>python3 -c "from lib.cinematic.backdrops import create_backdrop, create_backdrop_from_preset, delete_backdrop, get_backdrop; print('Convenience functions OK')"</verify>
  <done>Main create_backdrop() function with HDRI support, preset dispatch logic, and cleanup utilities</done>
</task>

</tasks>

<verification>
1. Module imports successfully outside Blender
2. All functions have proper docstrings
3. Guarded bpy pattern allows testing without Blender
4. Code follows patterns from lighting.py and hdri.py
5. HDRI backdrop type delegates to existing hdri.py module
6. create_backdrop_from_preset dispatches to correct preset loader
</verification>

<success_criteria>
- backdrops.py module created with 8+ exported functions
- Infinite curve geometry generation works
- HDRI backdrop delegates to existing hdri.py module
- Gradient material shader nodes configured correctly
- Shadow catcher setup with film_transparent enabled
- Convenience functions with preset dispatch logic
</success_criteria>

<output>
After completion, create `.planning/phases/06.3-backdrop-system/06.3-02-SUMMARY.md`
</output>
