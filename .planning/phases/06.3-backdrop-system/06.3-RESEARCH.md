# Phase 6.3: Backdrop System - Research

**Researched:** 2026-02-18
**Domain:** Blender procedural geometry, shadow catchers, product photography backdrops
**Confidence:** MEDIUM

## Summary

This research covers the implementation of a backdrop system for cinematic product rendering in Blender. The system needs to support infinite curves (seamless sweeps), gradient backgrounds, HDRI dome backdrops, and shadow catcher functionality. The existing codebase already has partial infrastructure with `BackdropConfig` in types.py and an HDRI module that can be reused.

Key implementation areas include:
1. Procedural mesh generation using bmesh for infinite curves
2. Shadow catcher setup for Cycles and EEVEE
3. Gradient shader material creation
4. Integration with existing HDRI system
5. Preset management in YAML configuration files

**Primary recommendation:** Use bmesh for procedural geometry generation with a shader node tree for gradient materials. Implement shadow catchers using Blender's `is_shadow_catcher` object property with `film_transparent` render setting.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| bmesh | Blender API | Procedural mesh generation | Direct mesh manipulation, creates geometry from scratch |
| mathutils | Blender API | Vector/Matrix math | Standard for 3D calculations in Blender |
| bpy.types.Material | Blender API | Material system | Native material with node trees |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| ShaderNodeValToRGB | Blender API | Color ramp for gradients | Gradient materials |
| ShaderNodeSeparateXYZ | Blender API | Position-based shading | Z-position gradient |
| ShaderNodeTexCoord | Blender API | Texture coordinates | UV/Generated coordinates |

### Existing Code to Reuse
| Module | Purpose | Integration |
|--------|---------|-------------|
| lib/cinematic/types.py | BackdropConfig dataclass | Already defined, extend as needed |
| lib/cinematic/hdri.py | HDRI environment setup | Reuse for HDRI backdrop type |
| lib/cinematic/preset_loader.py | YAML preset loading | Add backdrop preset loaders |

**No external installation required** - all components are part of Blender's Python API.

## Architecture Patterns

### Recommended Project Structure
```
lib/cinematic/
    backdrops.py          # Core backdrop creation module

configs/cinematic/backdrops/
    infinite_curves.yaml  # Product backdrop presets
    gradients.yaml        # Gradient color presets
    environments.yaml     # Pre-built scene references
```

### Pattern 1: Procedural Infinite Curve Generation
**What:** Generate seamless sweep geometry using bmesh with configurable radius and curve segments
**When to use:** Creating product photography backgrounds that need infinite appearance
**Example:**
```python
# Source: Based on Blender bmesh API documentation
# https://docs.blender.org/api/current/bmesh.html

import bpy
import bmesh
import math

def create_infinite_curve(config: dict) -> bpy.types.Object:
    """
    Create procedural infinite curve backdrop.

    Algorithm:
    1. Create floor plane vertices
    2. Create curve transition vertices (bezier-like smooth)
    3. Create vertical wall vertices
    4. Connect faces
    5. Apply gradient material
    """
    radius = config.get('radius', 5.0)
    curve_height = config.get('curve_height', 3.0)
    curve_segments = config.get('curve_segments', 32)

    # Create mesh
    mesh = bpy.data.meshes.new("gsd_backdrop_curve_mesh")
    obj = bpy.data.objects.new("gsd_backdrop_curve", mesh)
    bpy.context.collection.objects.link(obj)

    # Build geometry with bmesh
    bm = bmesh.new()

    # Floor vertices (X-Z plane at Y=0)
    floor_verts = []
    for i in range(curve_segments + 1):
        t = i / curve_segments
        x = -radius + (2 * radius * t)
        v = bm.verts.new((x, 0, 0))
        floor_verts.append(v)

    # Curve vertices (smooth transition using quarter circle)
    curve_radius = radius * 0.3  # Curve tightness
    curve_verts = []
    for i in range(curve_segments + 1):
        t = i / curve_segments
        angle = math.pi / 2 * t
        x = -curve_radius + (curve_radius * math.cos(angle))
        z = curve_radius * math.sin(angle)
        v = bm.verts.new((x, 0, z))
        curve_verts.append(v)

    # Wall vertices (vertical)
    wall_verts = []
    for i in range(curve_segments + 1):
        t = i / curve_segments
        x = -curve_radius + (2 * curve_radius * t)
        v = bm.verts.new((x, 0, curve_height))
        wall_verts.append(v)

    # Create faces (ensure proper winding)
    for i in range(curve_segments):
        # Floor to curve
        bm.faces.new([floor_verts[i], floor_verts[i+1],
                      curve_verts[i+1], curve_verts[i]])
        # Curve to wall
        bm.faces.new([curve_verts[i], curve_verts[i+1],
                      wall_verts[i+1], wall_verts[i]])

    bm.to_mesh(mesh)
    bm.free()

    return obj
```

### Pattern 2: Shadow Catcher Configuration
**What:** Set up object as shadow catcher for compositing workflows
**When to use:** When backdrop should receive shadows but be transparent in render
**Example:**
```python
# Source: Blender Python API - Object visibility settings
# Based on design document requirements

def setup_shadow_catcher(obj: bpy.types.Object, enabled: bool = True):
    """
    Configure object as shadow catcher for alpha compositing.

    Requirements from design:
    - shadow_method: CLIP (not HASHED or STOCHASTIC)
    - backface_culling: true
    - film_transparent: true in scene render settings
    """
    # Object-level shadow catcher (Cycles)
    obj.is_shadow_catcher = enabled

    # Material settings for shadow catcher
    if obj.data.materials:
        mat = obj.data.materials[0]
        if mat and mat.use_nodes:
            # Ensure proper shadow method
            mat.shadow_method = 'CLIP'
            mat.use_backface_culling = True
            mat.blend_method = 'HASHED'  # For alpha blending
            mat.show_transparent_back = False

def configure_render_for_shadow_catcher(scene):
    """
    Configure render settings for shadow catcher output.
    """
    # Enable transparent film for alpha output
    scene.render.film_transparent = True

    # Enable required passes
    view_layer = scene.view_layers[0]
    view_layer.use_pass_shadow = True
    view_layer.use_pass_combined = True
```

### Pattern 3: Gradient Material Shader
**What:** Create position-based gradient material using shader nodes
**When to use:** For infinite curves and gradient backdrops
**Example:**
```python
# Source: Blender shader node API patterns

def create_gradient_material(
    name: str,
    color_bottom: tuple,
    color_top: tuple,
    gradient_height: float = 3.0
) -> bpy.types.Material:
    """
    Create gradient material based on Z position.

    Node tree:
    Geometry -> Separate XYZ -> Divide -> Color Ramp -> Principled BSDF
    """
    import bpy

    mat = bpy.data.materials.new(name)
    mat.use_nodes = True

    nodes = mat.node_tree.nodes
    links = mat.node_tree.links

    # Clear default nodes
    nodes.clear()

    # Create nodes
    output = nodes.new('ShaderNodeOutputMaterial')
    principled = nodes.new('ShaderNodeBsdfPrincipled')

    # Geometry node for position
    geometry = nodes.new('ShaderNodeNewGeometry')

    # Separate XYZ for Z position
    separate = nodes.new('ShaderNodeSeparateXYZ')

    # Math node to normalize Z position
    math_divide = nodes.new('ShaderNodeMath')
    math_divide.operation = 'DIVIDE'
    math_divide.inputs[1].default_value = gradient_height

    # Color ramp for gradient
    ramp = nodes.new('ShaderNodeValToRGB')
    ramp.color_ramp.elements[0].color = (*color_bottom, 1.0)
    ramp.color_ramp.elements[1].color = (*color_top, 1.0)

    # Position nodes
    geometry.location = (-600, 0)
    separate.location = (-400, 0)
    math_divide.location = (-200, 0)
    ramp.location = (0, 0)
    principled.location = (200, 0)
    output.location = (400, 0)

    # Link nodes
    links.new(geometry.outputs['Position'], separate.inputs['Vector'])
    links.new(separate.outputs['Z'], math_divide.inputs[0])
    links.new(math_divide.outputs['Value'], ramp.inputs['Fac'])
    links.new(ramp.outputs['Color'], principled.inputs['Base Color'])
    links.new(principled.outputs['BSDF'], output.inputs['Surface'])

    return mat
```

### Anti-Patterns to Avoid
- **Using bpy.ops for mesh creation:** Operators depend on context, use bmesh directly
- **Creating separate objects for floor/wall:** Breaks seamless appearance, use single mesh
- **Hardcoded curve radius:** Should scale with subject bounding box
- **Not enabling film_transparent:** Shadow catcher won't produce correct alpha
- **Using HASHED shadow_method:** Use CLIP for clean shadow edges

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Mesh geometry generation | Raw vertex/face lists | bmesh module | Proper topology, UV support, normals |
| Gradient calculation | Custom math | ShaderNodeValToRGB | GPU-accelerated, interactive preview |
| Shadow compositing | Manual alpha blending | Blender shadow catcher | Physically accurate shadows |
| HDRI environment | Custom world setup | Existing hdri.py module | Already implemented, tested |

**Key insight:** Blender's native systems handle edge cases (anti-aliasing, motion blur, compositing) that custom implementations miss.

## Common Pitfalls

### Pitfall 1: Shadow Catcher Not Producing Alpha
**What goes wrong:** Shadow catcher renders solid instead of transparent
**Why it happens:** `film_transparent` not enabled in render settings
**How to avoid:** Always set `scene.render.film_transparent = True` when shadow catcher enabled
**Warning signs:** Alpha channel is fully white in output

### Pitfall 2: Visible Seam in Infinite Curve
**What goes wrong:** Corner visible where floor meets wall
**Why it happens:** Insufficient curve segments or wrong curve formula
**How to avoid:** Use minimum 32 segments, use smooth interpolation (sin/cos or bezier)
**Warning signs:** Visible hard edge at floor-wall transition in renders

### Pitfall 3: Shadow Catcher Material Conflicts
**What goes wrong:** Shadow catcher casts shadows or appears opaque
**Why it happens:** Wrong `shadow_method` or `blend_method` settings
**How to avoid:** Use `shadow_method='CLIP'`, `blend_method='HASHED'`, `use_backface_culling=True`
**Warning signs:** Shadow catcher object visible in reflections or casting shadows

### Pitfall 4: Gradient Banding
**What goes wrong:** Visible stepped bands in gradient instead of smooth transition
**Why it happens:** Low bit depth or integer color ramp
**How to avoid:** Use float color values, ensure color ramp interpolation is set to 'LINEAR'
**Warning signs:** Posterized appearance in gradient areas

## Code Examples

Verified patterns from official sources:

### Complete Backdrop Creation Function
```python
# Source: Synthesized from Blender API documentation and design requirements
# https://docs.blender.org/api/current/bmesh.html

import bpy
import bmesh
import math
from typing import Optional, Tuple

def create_backdrop(
    backdrop_type: str = "infinite_curve",
    radius: float = 5.0,
    curve_height: float = 3.0,
    color_bottom: Tuple[float, float, float] = (0.95, 0.95, 0.95),
    color_top: Tuple[float, float, float] = (1.0, 1.0, 1.0),
    shadow_catcher: bool = True,
    curve_segments: int = 32
) -> Optional[bpy.types.Object]:
    """
    Create backdrop with specified configuration.

    Args:
        backdrop_type: Type of backdrop (infinite_curve, gradient, hdri, mesh)
        radius: Distance from center to edge
        curve_height: Height of vertical wall
        color_bottom: RGB color at bottom of gradient
        color_top: RGB color at top of gradient
        shadow_catcher: Enable shadow catching mode
        curve_segments: Resolution of curve

    Returns:
        Created backdrop object or None if failed
    """
    try:
        # Create mesh
        mesh = bpy.data.meshes.new("gsd_backdrop_mesh")
        obj = bpy.data.objects.new("gsd_backdrop", mesh)
        bpy.context.collection.objects.link(obj)

        # Build geometry
        bm = bmesh.new()

        curve_radius = radius * 0.3

        # Floor
        floor_verts = []
        for i in range(curve_segments + 1):
            t = i / curve_segments
            x = -radius + (2 * radius * t)
            v = bm.verts.new((x, 0, 0))
            floor_verts.append(v)

        # Curve (quarter circle for smooth transition)
        curve_verts = []
        for i in range(curve_segments + 1):
            t = i / curve_segments
            angle = math.pi / 2 * t
            x = -curve_radius + (curve_radius * math.cos(angle))
            z = curve_radius * math.sin(angle)
            v = bm.verts.new((x, 0, z))
            curve_verts.append(v)

        # Wall
        wall_verts = []
        for i in range(curve_segments + 1):
            t = i / curve_segments
            x = -curve_radius + (2 * curve_radius * t)
            v = bm.verts.new((x, 0, curve_height))
            wall_verts.append(v)

        # Create faces
        for i in range(curve_segments):
            bm.faces.new([floor_verts[i], floor_verts[i+1],
                          curve_verts[i+1], curve_verts[i]])
            bm.faces.new([curve_verts[i], curve_verts[i+1],
                          wall_verts[i+1], wall_verts[i]])

        bm.to_mesh(mesh)
        bm.free()

        # Create and apply gradient material
        mat = create_gradient_material(
            "gsd_backdrop_mat",
            color_bottom,
            color_top,
            curve_height
        )
        obj.data.materials.append(mat)

        # Configure shadow catcher
        if shadow_catcher:
            obj.is_shadow_catcher = True
            mat.shadow_method = 'CLIP'
            mat.use_backface_culling = True

        return obj

    except Exception as e:
        print(f"Failed to create backdrop: {e}")
        return None
```

### HDRI Backdrop Integration
```python
# Source: Reusing existing hdri.py module pattern

from lib.cinematic.hdri import setup_hdri, clear_hdri

def create_hdri_backdrop(hdri_preset: str, visible: bool = True) -> bool:
    """
    Create HDRI backdrop using existing HDRI system.

    Args:
        hdri_preset: Name of HDRI preset from hdri_presets.yaml
        visible: Whether HDRI is visible in render background

    Returns:
        True if successful
    """
    from lib.cinematic.preset_loader import get_hdri_preset

    preset = get_hdri_preset(hdri_preset)

    return setup_hdri(
        hdri_path=preset.get('file', ''),
        exposure=preset.get('exposure', 0.0),
        rotation=preset.get('rotation', 0.0),
        background_visible=visible,
        saturation=preset.get('saturation', 1.0)
    )
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Boolean shadow catcher | is_shadow_catcher property | Blender 2.8+ | Simplified API |
| Fixed pipeline shading | Node-based materials | Blender 2.5+ | Full creative control |
| Separate floor/wall meshes | Single continuous mesh | Industry standard | Seamless appearance |

**Deprecated/outdated:**
- `bpy.ops.mesh.primitive_plane_add`: Use bmesh directly for procedural generation
- Fixed function materials: Use node trees exclusively

## Open Questions

Things that couldn't be fully resolved:

1. **EEVEE vs Cycles Shadow Catcher Behavior**
   - What we know: Cycles has full shadow catcher support, EEVEE Next (4.0+) has improved support
   - What's unclear: Exact differences in alpha output between engines
   - Recommendation: Implement for Cycles first, test EEVEE compatibility

2. **Subject-Aware Backdrop Sizing**
   - What we know: Need to calculate from bounding box
   - What's unclear: How to handle multi-object subjects or animated subjects
   - Recommendation: Start with single-object bounding box, add plumb_bob integration for complex cases

## Sources

### Primary (HIGH confidence)
- Blender Python API - bmesh module: https://docs.blender.org/api/current/bmesh.html
- CINEMATIC_SYSTEM_DESIGN.md - Part 5 (Backdrop System Design), Part 13.5 (Procedural Backdrop Geometry), Part 13.6 (Shadow Catcher Contract)
- lib/cinematic/types.py - Existing BackdropConfig dataclass
- lib/cinematic/hdri.py - Existing HDRI implementation patterns

### Secondary (MEDIUM confidence)
- Blender shader node patterns from official documentation
- Product photography backdrop best practices (general knowledge)

### Tertiary (LOW confidence)
- WebSearch results were unavailable due to service issues; verification needed for:
  - EEVEE Next shadow catcher specifics
  - Latest Blender 5.x API changes

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - bmesh and shader nodes are stable Blender APIs
- Architecture: HIGH - Based on existing codebase patterns and design document
- Pitfalls: MEDIUM - Based on general Blender knowledge, some specifics need testing

**Research date:** 2026-02-18
**Valid until:** 30 days (Blender API stable, but verify EEVEE specifics)
