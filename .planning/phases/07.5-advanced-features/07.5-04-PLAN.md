---
phase: 07.5-advanced-features
plan: 04
type: execute
wave: 4
depends_on: []
files_modified:
  - lib/cinematic/tracking/mocap.py
  - lib/cinematic/tracking/types.py
autonomous: true

must_haves:
  truths:
    - "BVH/FBX mocap files import with skeleton hierarchy"
    - "Hand animation can be extracted for finger motion"
    - "Mocap data retargets to MorphEngine for control surfaces"
    - "Button press detection from finger tip proximity"
  artifacts:
    - path: "lib/cinematic/tracking/mocap.py"
      provides: "Motion capture import and retargeting to MorphEngine"
      exports: ["MocapData", "HandData", "MocapRetargeter", "MocapImporter"]
  key_links:
    - from: "MocapRetargeter"
      to: "MorphEngine"
      via: "retarget_to_morph()"
      pattern: "retargeting"
---

<objective>
Implement motion capture import system with hand animation extraction and retargeting to MorphEngine.

Purpose: Import mocap from iPhone apps (Move.ai, Rokoko) and professional systems, extract hand animation for control surface interaction.
Output: `lib/cinematic/tracking/mocap.py` with BVH/FBX import, hand tracking, and MorphEngine retargeting.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Research reference
@.planning/phases/07.5-advanced-features/07.5-RESEARCH.md

# Existing import/export with BVHParser
@lib/cinematic/tracking/import_export.py

# Morphing engine for retargeting
@lib/control_system/morphing.py

# Existing types to extend
@lib/cinematic/tracking/types.py
</context>

<tasks>

<task type="auto">
  <name>Add Mocap Types to tracking/types.py</name>
  <files>lib/cinematic/tracking/types.py</files>
  <action>
    Add the following dataclasses to types.py (after ScanData class):

    ```python
    @dataclass
    class JointTransform:
        """
        Single joint transform at a frame.

        Attributes:
            frame: Frame number
            position: Joint position (x, y, z)
            rotation_euler: Euler rotation in degrees (x, y, z)
            rotation_quaternion: Quaternion rotation (w, x, y, z)
            scale: Scale factor (usually 1.0, 1.0, 1.0)
        """
        frame: int
        position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
        rotation_euler: Tuple[float, float, float] = (0.0, 0.0, 0.0)
        rotation_quaternion: Tuple[float, float, float, float] = (1.0, 0.0, 0.0, 0.0)
        scale: Tuple[float, float, float] = (1.0, 1.0, 1.0)

        def to_dict(self) -> Dict[str, Any]:
            return {
                "frame": self.frame,
                "position": list(self.position),
                "rotation_euler": list(self.rotation_euler),
                "rotation_quaternion": list(self.rotation_quaternion),
                "scale": list(self.scale),
            }

        @classmethod
        def from_dict(cls, data: Dict[str, Any]) -> "JointTransform":
            return cls(
                frame=data.get("frame", 0),
                position=tuple(data.get("position", (0.0, 0.0, 0.0))),
                rotation_euler=tuple(data.get("rotation_euler", (0.0, 0.0, 0.0))),
                rotation_quaternion=tuple(data.get("rotation_quaternion", (1.0, 0.0, 0.0, 0.0))),
                scale=tuple(data.get("scale", (1.0, 1.0, 1.0))),
            )


    @dataclass
    class BoneChannel:
        """
        Animation channel for a single bone/joint.

        Attributes:
            name: Bone name
            parent: Parent bone name (empty for root)
            transforms: Transform data per frame
            offset: Rest position offset from parent
            channels: Available channels (Xposition, Yposition, Zrotation, etc.)
        """
        name: str = ""
        parent: str = ""
        transforms: List[JointTransform] = field(default_factory=list)
        offset: Tuple[float, float, float] = (0.0, 0.0, 0.0)
        channels: List[str] = field(default_factory=list)

        def get_transform_at_frame(self, frame: int) -> Optional[JointTransform]:
            """Get transform at specific frame."""
            for t in self.transforms:
                if t.frame == frame:
                    return t
            return None

        def to_dict(self) -> Dict[str, Any]:
            return {
                "name": self.name,
                "parent": self.parent,
                "transforms": [t.to_dict() for t in self.transforms],
                "offset": list(self.offset),
                "channels": self.channels,
            }

        @classmethod
        def from_dict(cls, data: Dict[str, Any]) -> "BoneChannel":
            transforms_data = data.get("transforms", [])
            transforms = [JointTransform.from_dict(t) for t in transforms_data]
            return cls(
                name=data.get("name", ""),
                parent=data.get("parent", ""),
                transforms=transforms,
                offset=tuple(data.get("offset", (0.0, 0.0, 0.0))),
                channels=data.get("channels", []),
            )


    @dataclass
    class MocapData:
        """
        Complete motion capture data.

        Attributes:
            id: Unique mocap identifier
            name: Human-readable mocap name
            source_path: Original file path
            source_format: File format (bvh, fbx)
            frame_start: First frame
            frame_end: Last frame
            fps: Frames per second
            duration_seconds: Total duration
            bones: Animation channels per bone
            hierarchy: Bone hierarchy (bone -> children)
        """
        id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
        name: str = "mocap"
        source_path: str = ""
        source_format: str = ""
        frame_start: int = 1
        frame_end: int = 1
        fps: float = 30.0
        duration_seconds: float = 0.0
        bones: List[BoneChannel] = field(default_factory=list)
        hierarchy: Dict[str, List[str]] = field(default_factory=dict)

        def get_bone(self, name: str) -> Optional[BoneChannel]:
            """Get bone channel by name."""
            for bone in self.bones:
                if bone.name == name:
                    return bone
            return None

        def get_bone_names(self) -> List[str]:
            """Get list of all bone names."""
            return [b.name for b in self.bones]

        def to_dict(self) -> Dict[str, Any]:
            return {
                "id": self.id,
                "name": self.name,
                "source_path": self.source_path,
                "source_format": self.source_format,
                "frame_start": self.frame_start,
                "frame_end": self.frame_end,
                "fps": self.fps,
                "duration_seconds": self.duration_seconds,
                "bones": [b.to_dict() for b in self.bones],
                "hierarchy": self.hierarchy,
            }

        @classmethod
        def from_dict(cls, data: Dict[str, Any]) -> "MocapData":
            bones_data = data.get("bones", [])
            bones = [BoneChannel.from_dict(b) for b in bones_data]
            return cls(
                id=data.get("id", str(uuid.uuid4())[:8]),
                name=data.get("name", "mocap"),
                source_path=data.get("source_path", ""),
                source_format=data.get("source_format", ""),
                frame_start=data.get("frame_start", 1),
                frame_end=data.get("frame_end", 1),
                fps=data.get("fps", 30.0),
                duration_seconds=data.get("duration_seconds", 0.0),
                bones=bones,
                hierarchy=data.get("hierarchy", {}),
            )


    @dataclass
    class FingerData:
        """
        Finger joint data for hand tracking.

        Attributes:
            finger_name: Finger identifier (thumb, index, middle, ring, pinky)
            joint_name: Joint identifier (metacarpal, proximal, intermediate, distal)
            rotation: Joint rotation (euler degrees)
            position: Joint position (world space)
        """
        finger_name: str = ""
        joint_name: str = ""
        rotation: Tuple[float, float, float] = (0.0, 0.0, 0.0)
        position: Tuple[float, float, float] = (0.0, 0.0, 0.0)

        def to_dict(self) -> Dict[str, Any]:
            return {
                "finger_name": self.finger_name,
                "joint_name": self.joint_name,
                "rotation": list(self.rotation),
                "position": list(self.position),
            }


    @dataclass
    class HandFrame:
        """
        Complete hand data for a single frame.

        Attributes:
            frame: Frame number
            wrist_position: Wrist world position
            wrist_rotation: Wrist rotation (euler)
            fingers: List of finger joint data
            finger_tips: Dict of finger_name -> tip_position
        """
        frame: int
        wrist_position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
        wrist_rotation: Tuple[float, float, float] = (0.0, 0.0, 0.0)
        fingers: List[FingerData] = field(default_factory=list)
        finger_tips: Dict[str, Tuple[float, float, float]] = field(default_factory=dict)

        def get_finger_tip(self, finger: str) -> Optional[Tuple[float, float, float]]:
            """Get fingertip position for a finger."""
            return self.finger_tips.get(finger)

        def to_dict(self) -> Dict[str, Any]:
            return {
                "frame": self.frame,
                "wrist_position": list(self.wrist_position),
                "wrist_rotation": list(self.wrist_rotation),
                "fingers": [f.to_dict() for f in self.fingers],
                "finger_tips": {k: list(v) for k, v in self.finger_tips.items()},
            }


    @dataclass
    class HandAnimation:
        """
        Complete hand animation extracted from mocap.

        Attributes:
            name: Hand identifier (left, right)
            frames: Hand data per frame
            frame_start: First frame
            frame_end: Last frame
        """
        name: str = "hand"
        frames: List[HandFrame] = field(default_factory=list)
        frame_start: int = 1
        frame_end: int = 1

        def get_frame(self, frame: int) -> Optional[HandFrame]:
            """Get hand data at specific frame."""
            for f in self.frames:
                if f.frame == frame:
                    return f
            return None

        def to_dict(self) -> Dict[str, Any]:
            return {
                "name": self.name,
                "frames": [f.to_dict() for f in self.frames],
                "frame_start": self.frame_start,
                "frame_end": self.frame_end,
            }
    ```
  </action>
  <verify>python -c "from lib.cinematic.tracking.types import MocapData, HandAnimation, BoneChannel; print('OK')"</verify>
  <done>Mocap types added and importable</done>
</task>

<task type="auto">
  <name>Create Mocap Import Module</name>
  <files>lib/cinematic/tracking/mocap.py</files>
  <action>
    Create `lib/cinematic/tracking/mocap.py`:

    ```python
    """
    Motion Capture Import and Retargeting System

    Provides:
    - BVH/FBX mocap import
    - Hand animation extraction
    - Retargeting to MorphEngine for control surfaces
    - Button press detection from finger proximity

    Supported Sources:
    - Move.ai (FBX, BVH)
    - Rokoko Video (FBX, BVH)
    - DeepMotion (FBX)
    - Vicon (C3D, FBX, BVH)
    - OptiTrack (C3D, FBX)

    Usage:
        from lib.cinematic.tracking.mocap import MocapImporter, MocapRetargeter

        # Import mocap
        importer = MocapImporter()
        mocap = importer.import_mocap("mocap/hand_animation.bvh")

        # Extract hand animation
        hand = importer.extract_hand_animation(mocap, side="right")

        # Retarget to morph engine
        retargeter = MocapRetargeter()
        morph_curves = retargeter.retarget_to_morph(hand, control_type="knob")
    """

    from __future__ import annotations
    import math
    import re
    from dataclasses import dataclass, field
    from pathlib import Path
    from typing import Any, Dict, List, Optional, Tuple

    from .types import (
        MocapData,
        BoneChannel,
        JointTransform,
        HandAnimation,
        HandFrame,
        FingerData,
    )
    from .import_export import BVHParser


    # Standard hand bone names (for mapping)
    HAND_BONE_NAMES = {
        "wrist": ["wrist", "Hand", "hand", "Wrist"],
        "thumb": {
            "metacarpal": ["Thumb1", "thumb_01", "thumb_metacarpal"],
            "proximal": ["Thumb2", "thumb_02", "thumb_proximal"],
            "distal": ["Thumb3", "thumb_03", "thumb_distal", "ThumbEnd"],
        },
        "index": {
            "metacarpal": ["Index1", "index_01", "index_metacarpal"],
            "proximal": ["Index2", "index_02", "index_proximal"],
            "intermediate": ["Index3", "index_03", "index_intermediate"],
            "distal": ["Index4", "index_04", "index_distal", "IndexEnd"],
        },
        "middle": {
            "metacarpal": ["Middle1", "middle_01", "middle_metacarpal"],
            "proximal": ["Middle2", "middle_02", "middle_proximal"],
            "intermediate": ["Middle3", "middle_03", "middle_intermediate"],
            "distal": ["Middle4", "middle_04", "middle_distal", "MiddleEnd"],
        },
        "ring": {
            "metacarpal": ["Ring1", "ring_01", "ring_metacarpal"],
            "proximal": ["Ring2", "ring_02", "ring_proximal"],
            "intermediate": ["Ring3", "ring_03", "ring_intermediate"],
            "distal": ["Ring4", "ring_04", "ring_distal", "RingEnd"],
        },
        "pinky": {
            "metacarpal": ["Pinky1", "pinky_01", "pinky_metacarpal"],
            "proximal": ["Pinky2", "pinky_02", "pinky_proximal"],
            "intermediate": ["Pinky3", "pinky_03", "pinky_intermediate"],
            "distal": ["Pinky4", "pinky_04", "pinky_distal", "PinkyEnd"],
        },
    }


    class MocapImporter:
        """
        Main mocap import interface.

        Handles BVH and FBX import with hand animation extraction.
        """

        def __init__(self):
            """Initialize mocap importer."""
            pass

        def import_mocap(
            self,
            filepath: str,
            fps: Optional[float] = None
        ) -> MocapData:
            """
            Import mocap from file.

            Args:
                filepath: Path to mocap file (BVH or FBX)
                fps: Override frame rate (None = use file fps)

            Returns:
                MocapData with animation
            """
            path = Path(filepath)
            ext = path.suffix.lower()

            mocap = MocapData(
                name=path.stem,
                source_path=str(path),
                source_format=ext,
            )

            if ext == ".bvh":
                return self._import_bvh(filepath, mocap, fps)
            elif ext == ".fbx":
                return self._import_fbx(filepath, mocap, fps)
            else:
                raise ValueError(f"Unsupported mocap format: {ext}")

        def _import_bvh(
            self,
            filepath: str,
            mocap: MocapData,
            fps: Optional[float]
        ) -> MocapData:
            """Import from BVH file."""
            with open(filepath, "r") as f:
                content = f.read()

            # Parse hierarchy and motion
            bones, hierarchy = self._parse_bvh_hierarchy(content)
            motion_data, frame_time = self._parse_bvh_motion(content)

            mocap.bones = bones
            mocap.hierarchy = hierarchy

            # Set frame info
            if motion_data:
                mocap.frame_start = 1
                mocap.frame_end = len(motion_data)
                mocap.fps = fps or (1.0 / frame_time if frame_time > 0 else 30.0)
                mocap.duration_seconds = len(motion_data) * frame_time

                # Populate bone transforms
                for bone in mocap.bones:
                    for i, frame_values in enumerate(motion_data):
                        # This is simplified - real impl needs proper channel mapping
                        transform = JointTransform(
                            frame=i + 1,
                            position=(0.0, 0.0, 0.0),
                            rotation_euler=(0.0, 0.0, 0.0),
                        )
                        bone.transforms.append(transform)

            return mocap

        def _parse_bvh_hierarchy(
            self,
            content: str
        ) -> Tuple[List[BoneChannel], Dict[str, List[str]]]:
            """Parse BVH hierarchy section."""
            bones = []
            hierarchy = {}

            # Simplified parsing - real impl needs recursive descent
            # Just detect bone names for now
            bone_pattern = r'ROOT\s+(\w+)|JOINT\s+(\w+)'
            matches = re.findall(bone_pattern, content)

            for match in matches:
                name = match[0] or match[1]
                bone = BoneChannel(name=name)
                bones.append(bone)
                hierarchy[name] = []

            return bones, hierarchy

        def _parse_bvh_motion(
            self,
            content: str
        ) -> Tuple[List[List[float]], float]:
            """Parse BVH motion section."""
            motion = []
            frame_time = 0.0333  # Default 30fps

            motion_match = re.search(
                r'MOTION\s+Frames:\s+(\d+)\s+Frame Time:\s+([\d.]+)\s+((?:[\d.\-\s]+)+)',
                content
            )

            if motion_match:
                frame_count = int(motion_match.group(1))
                frame_time = float(motion_match.group(2))
                frame_data_str = motion_match.group(3)

                for line in frame_data_str.strip().split('\n'):
                    values = [float(v) for v in line.split()]
                    motion.append(values)

            return motion, frame_time

        def _import_fbx(
            self,
            filepath: str,
            mocap: MocapData,
            fps: Optional[float]
        ) -> MocapData:
            """Import from FBX file."""
            # FBX import would use Blender or fbx library
            # For now, return empty mocap
            mocap.fps = fps or 30.0
            return mocap

        def extract_hand_animation(
            self,
            mocap: MocapData,
            side: str = "right"
        ) -> Optional[HandAnimation]:
            """
            Extract hand animation from mocap data.

            Args:
                mocap: MocapData with full body animation
                side: "left" or "right" hand

            Returns:
                HandAnimation if hand bones found
            """
            # Find hand bone names in mocap
            hand_bones = self._find_hand_bones(mocap, side)

            if not hand_bones:
                return None

            hand = HandAnimation(
                name=f"{side}_hand",
                frame_start=mocap.frame_start,
                frame_end=mocap.frame_end,
            )

            # Extract hand frames
            for frame in range(mocap.frame_start, mocap.frame_end + 1):
                hand_frame = self._extract_hand_frame(mocap, hand_bones, frame)
                hand.frames.append(hand_frame)

            return hand

        def _find_hand_bones(
            self,
            mocap: MocapData,
            side: str
        ) -> Dict[str, str]:
            """Find hand bone names in mocap."""
            hand_bones = {}
            side_prefix = "R" if side == "right" else "L"

            bone_names = mocap.get_bone_names()

            for standard_name, aliases in HAND_BONE_NAMES.items():
                if isinstance(aliases, list):
                    # Wrist
                    for alias in aliases:
                        for bone_name in bone_names:
                            if alias.lower() in bone_name.lower():
                                hand_bones[standard_name] = bone_name
                                break
                else:
                    # Finger joints
                    hand_bones[standard_name] = {}
                    for joint_name, joint_aliases in aliases.items():
                        for alias in joint_aliases:
                            for bone_name in bone_names:
                                # Check with side prefix
                                if f"{side_prefix}{alias}".lower() in bone_name.lower():
                                    hand_bones[standard_name][joint_name] = bone_name
                                    break

            return hand_bones

        def _extract_hand_frame(
            self,
            mocap: MocapData,
            hand_bones: Dict[str, str],
            frame: int
        ) -> HandFrame:
            """Extract hand data for a single frame."""
            hand_frame = HandFrame(frame=frame)

            # Get wrist position/rotation
            if "wrist" in hand_bones:
                wrist_bone = mocap.get_bone(hand_bones["wrist"])
                if wrist_bone:
                    transform = wrist_bone.get_transform_at_frame(frame)
                    if transform:
                        hand_frame.wrist_position = transform.position
                        hand_frame.wrist_rotation = transform.rotation_euler

            # Extract finger data
            finger_names = ["thumb", "index", "middle", "ring", "pinky"]
            for finger in finger_names:
                if finger in hand_bones:
                    finger_data = hand_bones[finger]
                    if isinstance(finger_data, dict) and "distal" in finger_data:
                        distal_bone = mocap.get_bone(finger_data["distal"])
                        if distal_bone:
                            transform = distal_bone.get_transform_at_frame(frame)
                            if transform:
                                hand_frame.finger_tips[finger] = transform.position

            return hand_frame


    class MocapRetargeter:
        """
        Retarget mocap data to MorphEngine for control surface animation.

        Converts hand motion to morph factors for knobs, faders, and buttons.
        """

        def __init__(self):
            """Initialize retargeter."""
            pass

        def retarget_to_morph(
            self,
            hand: HandAnimation,
            control_type: str = "knob",
            control_center: Tuple[float, float, float] = (0.0, 0.0, 0.0),
            rotation_range: Tuple[float, float] = (0.0, 300.0)
        ) -> Dict[int, float]:
            """
            Retarget hand animation to morph factors.

            Args:
                hand: HandAnimation to retarget
                control_type: "knob", "fader", or "button"
                control_center: Control center position for proximity
                rotation_range: (min, max) rotation in degrees for knobs

            Returns:
                Dict mapping frame -> morph factor (0.0 to 1.0)
            """
            if control_type == "knob":
                return self._retarget_knob(hand, rotation_range)
            elif control_type == "fader":
                return self._retarget_fader(hand, control_center)
            elif control_type == "button":
                return self._retarget_button(hand, control_center)
            else:
                return {}

        def _retarget_knob(
            self,
            hand: HandAnimation,
            rotation_range: Tuple[float, float]
        ) -> Dict[int, float]:
            """
            Retarget to knob rotation.

            Uses index finger rotation around knob center.
            """
            morph_factors = {}

            for hand_frame in hand.frames:
                # Use index finger rotation as proxy for knob turning
                # Real impl would calculate rotation from finger arc
                # Simplified: use wrist rotation Y as rotation proxy
                wrist_ry = hand_frame.wrist_rotation[1]

                # Normalize to morph factor
                min_deg, max_deg = rotation_range
                t = (wrist_ry - min_deg) / (max_deg - min_deg)
                t = max(0.0, min(1.0, t))

                morph_factors[hand_frame.frame] = t

            return morph_factors

        def _retarget_fader(
            self,
            hand: HandAnimation,
            control_center: Tuple[float, float, float]
        ) -> Dict[int, float]:
            """
            Retarget to fader position.

            Uses hand Y position relative to fader track.
            """
            morph_factors = {}

            # Find min/max hand Y for normalization
            y_positions = [f.wrist_position[1] for f in hand.frames]
            if not y_positions:
                return morph_factors

            min_y = min(y_positions)
            max_y = max(y_positions)
            y_range = max_y - min_y if max_y != min_y else 1.0

            for hand_frame in hand.frames:
                # Normalize Y position to morph factor
                y = hand_frame.wrist_position[1]
                t = (y - min_y) / y_range

                morph_factors[hand_frame.frame] = t

            return morph_factors

        def _retarget_button(
            self,
            hand: HandAnimation,
            control_center: Tuple[float, float, float],
            press_threshold: float = 0.005
        ) -> Dict[int, float]:
            """
            Retarget to button press.

            Detects finger proximity to button center.
            Returns 1.0 for pressed, 0.0 for released.
            """
            morph_factors = {}

            for hand_frame in hand.frames:
                # Use index finger tip position
                index_tip = hand_frame.get_finger_tip("index")
                if index_tip:
                    # Calculate distance to button center
                    dx = index_tip[0] - control_center[0]
                    dy = index_tip[1] - control_center[1]
                    dz = index_tip[2] - control_center[2]
                    distance = math.sqrt(dx * dx + dy * dy + dz * dz)

                    # Press if close enough
                    morph_factors[hand_frame.frame] = 1.0 if distance < press_threshold else 0.0
                else:
                    morph_factors[hand_frame.frame] = 0.0

            return morph_factors

        def create_morph_animation(
            self,
            morph_factors: Dict[int, float],
            duration_seconds: float = 1.0,
            fps: float = 30.0
        ) -> Dict[str, Any]:
            """
            Create MorphAnimation-compatible data.

            Args:
                morph_factors: Frame -> morph factor mapping
                duration_seconds: Animation duration
                fps: Frames per second

            Returns:
                Dict with animation data
            """
            frames = sorted(morph_factors.keys())
            if not frames:
                return {}

            return {
                "duration": duration_seconds,
                "fps": fps,
                "keyframes": [
                    {"frame": f, "value": v}
                    for f, v in zip(frames, [morph_factors[f] for f in frames])
                ],
            }


    class ButtonPressDetector:
        """
        Detect button presses from finger proximity.

        Useful for creating boolean animation curves from mocap.
        """

        def __init__(
            self,
            press_threshold: float = 0.005,
            release_threshold: float = 0.010
        ):
            """
            Initialize detector.

            Args:
                press_threshold: Distance to trigger press
                release_threshold: Distance to trigger release (hysteresis)
            """
            self.press_threshold = press_threshold
            self.release_threshold = release_threshold

        def detect_presses(
            self,
            hand: HandAnimation,
            button_center: Tuple[float, float, float],
            finger: str = "index"
        ) -> List[Dict[str, Any]]:
            """
            Detect button press events.

            Args:
                hand: HandAnimation to analyze
                button_center: Button center position
                finger: Which finger to track

            Returns:
                List of press events with frame ranges
            """
            events = []
            is_pressed = False
            press_start = None

            for hand_frame in hand.frames:
                finger_tip = hand_frame.get_finger_tip(finger)
                if not finger_tip:
                    continue

                # Calculate distance
                dx = finger_tip[0] - button_center[0]
                dy = finger_tip[1] - button_center[1]
                dz = finger_tip[2] - button_center[2]
                distance = math.sqrt(dx * dx + dy * dy + dz * dz)

                # State machine with hysteresis
                if not is_pressed and distance < self.press_threshold:
                    is_pressed = True
                    press_start = hand_frame.frame
                elif is_pressed and distance > self.release_threshold:
                    is_pressed = False
                    events.append({
                        "start_frame": press_start,
                        "end_frame": hand_frame.frame - 1,
                        "duration_frames": hand_frame.frame - press_start,
                    })
                    press_start = None

            # Close open press event
            if is_pressed and press_start is not None:
                events.append({
                    "start_frame": press_start,
                    "end_frame": hand.frames[-1].frame,
                    "duration_frames": hand.frames[-1].frame - press_start + 1,
                })

            return events


    def import_move_ai(filepath: str) -> MocapData:
        """
        Convenience function for Move.ai mocap import.

        Args:
            filepath: Path to Move.ai FBX or BVH export

        Returns:
            MocapData with animation
        """
        importer = MocapImporter()
        return importer.import_mocap(filepath)


    def import_rokoko(filepath: str) -> MocapData:
        """
        Convenience function for Rokoko Video mocap import.

        Args:
            filepath: Path to Rokoko FBX or BVH export

        Returns:
            MocapData with animation
        """
        importer = MocapImporter()
        return importer.import_mocap(filepath)


    __all__ = [
        "MocapData",
        "BoneChannel",
        "JointTransform",
        "HandAnimation",
        "HandFrame",
        "FingerData",
        "MocapImporter",
        "MocapRetargeter",
        "ButtonPressDetector",
        "import_move_ai",
        "import_rokoko",
        "HAND_BONE_NAMES",
    ]
    ```
  </action>
  <verify>python -c "from lib.cinematic.tracking.mocap import MocapImporter, MocapRetargeter, ButtonPressDetector; print('OK')"</verify>
  <done>Mocap import module with BVH/FBX import, hand extraction, and MorphEngine retargeting</done>
</task>

<task type="auto">
  <name>Update tracking/__init__.py exports for mocap</name>
  <files>lib/cinematic/tracking/__init__.py</files>
  <action>
    Add imports for mocap module to `lib/cinematic/tracking/__init__.py`:

    Add to imports section:
    ```python
    from .mocap import (
        MocapData,
        BoneChannel,
        JointTransform,
        HandAnimation,
        HandFrame,
        FingerData,
        MocapImporter,
        MocapRetargeter,
        ButtonPressDetector,
        import_move_ai,
        import_rokoko,
    )
    ```

    Add to __all__ list:
    ```python
        # Motion Capture
        "MocapData",
        "BoneChannel",
        "JointTransform",
        "HandAnimation",
        "HandFrame",
        "FingerData",
        "MocapImporter",
        "MocapRetargeter",
        "ButtonPressDetector",
        "import_move_ai",
        "import_rokoko",
    ```
  </action>
  <verify>python -c "from lib.cinematic.tracking import MocapImporter, MocapRetargeter; print('OK')"</verify>
  <done>Mocap exports added to tracking package</done>
</task>

</tasks>

<verification>
- BVH import creates MocapData with bone channels
- Hand animation extraction finds finger bones
- MocapRetargeter converts hand motion to morph factors
- ButtonPressDetector detects press events from proximity
</verification>

<success_criteria>
- BVH/FBX mocap imports with skeleton hierarchy
- Hand animation extractable for control surfaces
- Mocap data retargets to MorphEngine for knobs/faders/buttons
- Button press detection from finger proximity works
</success_criteria>

<output>
After completion, create `.planning/phases/07.5-advanced-features/07.5-04-SUMMARY.md`
</output>
