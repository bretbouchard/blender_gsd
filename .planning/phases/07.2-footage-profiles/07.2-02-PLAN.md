---
phase: 07.2-footage-profiles
plan: 02
type: execute
wave: 2
depends_on: ["07.2-01"]
files_modified:
  - lib/cinematic/tracking/rolling_shutter.py
  - lib/cinematic/tracking/types.py
autonomous: true

must_haves:
  truths:
    - "Rolling shutter detection analyzes row-wise motion differences"
    - "Rolling shutter compensation reduces skew in footage"
    - "Device read times are stored in camera profiles"
  artifacts:
    - path: "lib/cinematic/tracking/rolling_shutter.py"
      provides: "Rolling shutter detection and compensation"
      exports: ["RollingShutterDetector", "RollingShutterCompensator", "detect_rolling_shutter", "compensate_rolling_shutter"]
    - path: "lib/cinematic/tracking/types.py"
      provides: "RollingShutterConfig dataclass"
      contains: "class RollingShutterConfig"
  key_links:
    - from: "RollingShutterDetector"
      to: "RollingShutterConfig"
      via: "detect() returns config"
      pattern: "def detect.*RollingShutterConfig"
---

<objective>
Create rolling_shutter.py module with detection and compensation for rolling shutter artifacts.

Purpose: Detect rolling shutter skew from footage and provide compensation to improve tracking accuracy. Rolling shutter causes each row to be captured at a different time, creating skew during fast motion.
Output: New rolling_shutter.py with RollingShutterDetector and RollingShutterCompensator classes.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-footage-profiles/07.2-RESEARCH.md
@.planning/phases/07.2-footage-profiles/07.2-01-PLAN.md

# Reference existing modules
@lib/cinematic/tracking/types.py
@lib/cinematic/tracking/footage.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RollingShutterConfig dataclass to types.py</name>
  <files>lib/cinematic/tracking/types.py</files>
  <action>
    Add RollingShutterConfig dataclass after StabilizationResult:

    ```python
    @dataclass
    class RollingShutterConfig:
        """
        Rolling shutter detection/compensation configuration.

        Attributes:
            detected: Whether rolling shutter was detected
            severity: "none", "low", "medium", "high"
            read_time: Sensor read time in seconds (typical: 7-16ms phones, 3-5ms cinema)
            skew_angle: Detected skew angle in degrees
            method: "row_rolling", "global_shutter"
            row_count: Number of sensor rows
            compensation_enabled: Whether to apply compensation
        """
        detected: bool = False
        severity: str = "none"
        read_time: float = 0.0
        skew_angle: float = 0.0
        method: str = "row_rolling"
        row_count: int = 1080
        compensation_enabled: bool = True

        def to_dict(self) -> Dict[str, Any]:
            return {
                "detected": self.detected,
                "severity": self.severity,
                "read_time": self.read_time,
                "skew_angle": self.skew_angle,
                "method": self.method,
                "row_count": self.row_count,
                "compensation_enabled": self.compensation_enabled,
            }

        @classmethod
        def from_dict(cls, data: Dict[str, Any]) -> RollingShutterConfig:
            return cls(
                detected=data.get("detected", False),
                severity=data.get("severity", "none"),
                read_time=data.get("read_time", 0.0),
                skew_angle=data.get("skew_angle", 0.0),
                method=data.get("method", "row_rolling"),
                row_count=data.get("row_count", 1080),
                compensation_enabled=data.get("compensation_enabled", True),
            )
    ```

    Also add to __all__ list in the same file.
  </action>
  <verify>grep -q "class RollingShutterConfig" lib/cinematic/tracking/types.py && echo "RollingShutterConfig found"</verify>
  <done>RollingShutterConfig dataclass exists with to_dict/from_dict methods</done>
</task>

<task type="auto">
  <name>Task 2: Create rolling_shutter.py with detection class</name>
  <files>lib/cinematic/tracking/rolling_shutter.py</files>
  <action>
    Create new module with RollingShutterDetector class:

    ```python
    """
    Rolling Shutter Detection and Compensation

    Detects and compensates for rolling shutter artifacts in video footage.
    Rolling shutter causes each row to be captured at a different time,
    creating skew during fast horizontal camera motion.
    """

    from __future__ import annotations
    from dataclasses import dataclass, field
    from typing import Dict, Any, Optional, Tuple, List
    from pathlib import Path
    import math

    from .types import RollingShutterConfig

    # Rolling shutter read times by device type (seconds)
    DEVICE_READ_TIMES = {
        # Smartphones
        "iphone_14_pro": 0.007,  # ~7ms
        "iphone_15_pro": 0.007,
        "pixel_8_pro": 0.008,
        # Cinema cameras
        "red_komodo": 0.004,  # ~4ms
        "arri_alexa": 0.003,  # Global shutter option
        "blackmagic_pocket": 0.005,
        # Action cameras
        "gopro_hero12": 0.016,  # ~16ms - very noticeable
        "dji_osmo": 0.014,
        # Drones
        "dji_mavic_3": 0.010,
        "dji_mini_4": 0.012,
        # Default
        "default": 0.010,
    }


    class RollingShutterDetector:
        """
        Detect rolling shutter artifacts from video analysis.

        Analyzes row-wise motion patterns to detect skew caused by
        rolling shutter during horizontal camera motion.
        """

        def __init__(self):
            self._use_opencv = self._check_opencv()

        def _check_opencv(self) -> bool:
            try:
                import cv2
                return True
            except ImportError:
                return False

        def detect(
            self,
            source_path: str,
            sample_frames: int = 30,
        ) -> RollingShutterConfig:
            """
            Detect rolling shutter from video file.

            Args:
                source_path: Path to video file
                sample_frames: Number of frames to analyze

            Returns:
                RollingShutterConfig with detection results
            """
            if not self._use_opencv:
                return RollingShutterConfig(detected=False, severity="none")

            return self._detect_opencv(source_path, sample_frames)

        def _detect_opencv(
            self,
            source_path: str,
            sample_frames: int,
        ) -> RollingShutterConfig:
            """OpenCV-based rolling shutter detection."""
            import cv2
            import numpy as np

            cap = cv2.VideoCapture(str(source_path))
            if not cap.isOpened():
                return RollingShutterConfig(detected=False)

            total_frames = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
            height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
            width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))

            # Sample frames throughout video
            frame_indices = np.linspace(0, max(0, total_frames - 1), sample_frames, dtype=int)

            row_displacements = []
            prev_frame = None

            for idx in frame_indices:
                cap.set(cv2.CAP_PROP_POS_FRAMES, idx)
                ret, frame = cap.read()
                if not ret:
                    continue

                gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

                if prev_frame is not None:
                    # Analyze motion in horizontal strips
                    num_strips = 10
                    strip_height = height // num_strips
                    row_motions = []

                    for i in range(num_strips):
                        y1 = i * strip_height
                        y2 = (i + 1) * strip_height

                        # Calculate optical flow for this strip
                        flow = cv2.calcOpticalFlowFarneback(
                            prev_frame[y1:y2, :],
                            gray[y1:y2, :],
                            None,
                            pyr_scale=0.5,
                            levels=3,
                            winsize=15,
                            iterations=3,
                            poly_n=5,
                            poly_sigma=1.2,
                            flags=0,
                        )
                        mean_dx = np.mean(flow[:, :, 0])
                        row_motions.append(mean_dx)

                    row_displacements.append(row_motions)

                prev_frame = gray

            cap.release()

            if not row_displacements:
                return RollingShutterConfig(detected=False, row_count=height)

            # Analyze displacement patterns
            displacements = np.array(row_displacements)
            row_indices = np.arange(displacements.shape[1])
            slopes = []

            for frame_disps in displacements:
                if np.std(frame_disps) > 0.1:  # Only analyze frames with motion
                    slope, _ = np.polyfit(row_indices, frame_disps, 1)
                    slopes.append(slope)

            if not slopes:
                return RollingShutterConfig(detected=False, severity="none", row_count=height)

            mean_slope = np.mean(np.abs(slopes))
            skew_angle = math.degrees(math.atan(mean_slope))

            # Classify severity
            if mean_slope > 0.5:
                severity = "high"
            elif mean_slope > 0.2:
                severity = "medium"
            elif mean_slope > 0.05:
                severity = "low"
            else:
                severity = "none"

            return RollingShutterConfig(
                detected=severity != "none",
                severity=severity,
                skew_angle=skew_angle,
                row_count=height,
                read_time=self._estimate_read_time(mean_slope),
            )

        def _estimate_read_time(self, slope: float) -> float:
            """Estimate sensor read time from skew slope."""
            # Rough estimation based on typical values
            # Higher slope = longer read time
            if slope < 0.1:
                return 0.005
            elif slope < 0.3:
                return 0.010
            else:
                return 0.015

        def get_read_time_for_device(self, device_key: str) -> float:
            """Get read time from device preset."""
            return DEVICE_READ_TIMES.get(device_key, DEVICE_READ_TIMES["default"])


    def detect_rolling_shutter(
        source_path: str,
        sample_frames: int = 30,
    ) -> RollingShutterConfig:
        """
        Convenience function to detect rolling shutter.

        Args:
            source_path: Path to video file
            sample_frames: Number of frames to analyze

        Returns:
            RollingShutterConfig with detection results
        """
        detector = RollingShutterDetector()
        return detector.detect(source_path, sample_frames)
    ```

    Include Blender API guards at top of file similar to footage.py.
  </action>
  <verify>grep -q "class RollingShutterDetector" lib/cinematic/tracking/rolling_shutter.py && grep -q "def detect_rolling_shutter" lib/cinematic/tracking/rolling_shutter.py && echo "RollingShutterDetector and detect_rolling_shutter found"</verify>
  <done>RollingShutterDetector class with detect() method and convenience function exist</done>
</task>

<task type="auto">
  <name>Task 3: Add RollingShutterCompensator class</name>
  <files>lib/cinematic/tracking/rolling_shutter.py</files>
  <action>
    Add RollingShutterCompensator class to rolling_shutter.py after the detector:

    ```python
    class RollingShutterCompensator:
        """
        Compensate for rolling shutter artifacts.

        Uses row-by-row time shifting to correct skew caused by
        rolling shutter during camera motion.
        """

        def __init__(self, config: RollingShutterConfig):
            self.config = config

        def compensate_frame(
            self,
            frame: Any,  # numpy array
            camera_velocity: Tuple[float, float] = (0.0, 0.0),
        ) -> Any:
            """
            Compensate rolling shutter in a single frame.

            Args:
                frame: Input frame (H, W, C) numpy array
                camera_velocity: Camera velocity in pixels/frame (vx, vy)

            Returns:
                Compensated frame
            """
            if not self.config.detected or not self.config.compensation_enabled:
                return frame

            import numpy as np

            height, width = frame.shape[:2]
            compensated = frame.copy()

            # Calculate time offset per row
            row_time = self.config.read_time / self.config.row_count

            for y in range(height):
                # Time offset for this row
                time_offset = (y - height / 2) * row_time

                # Pixel shift based on velocity and time offset
                shift_x = int(camera_velocity[0] * time_offset * 24)  # Assuming 24fps
                shift_y = int(camera_velocity[1] * time_offset * 24)

                # Apply horizontal shift (rolling shutter primarily affects horizontal)
                if shift_x != 0:
                    compensated[y, :] = np.roll(frame[y, :], shift_x, axis=0)

            return compensated

        def get_compensation_matrix(
            self,
            height: int,
            camera_velocity: Tuple[float, float],
        ) -> List[Tuple[int, int]]:
            """
            Get row-wise compensation shifts for a frame.

            Returns list of (row_index, shift_x) tuples.
            """
            if not self.config.detected:
                return [(y, 0) for y in range(height)]

            row_time = self.config.read_time / self.config.row_count
            shifts = []

            for y in range(height):
                time_offset = (y - height / 2) * row_time
                shift_x = int(camera_velocity[0] * time_offset * 24)
                shifts.append((y, shift_x))

            return shifts


    def compensate_rolling_shutter(
        frame: Any,
        config: RollingShutterConfig,
        camera_velocity: Tuple[float, float] = (0.0, 0.0),
    ) -> Any:
        """
        Convenience function to compensate rolling shutter.

        Args:
            frame: Input frame (numpy array)
            config: Rolling shutter configuration
            camera_velocity: Camera velocity in pixels/frame

        Returns:
            Compensated frame
        """
        compensator = RollingShutterCompensator(config)
        return compensator.compensate_frame(frame, camera_velocity)
    ```

    The compensator provides both per-frame compensation and a method to get compensation matrices for pre-computation.
  </action>
  <verify>grep -q "class RollingShutterCompensator" lib/cinematic/tracking/rolling_shutter.py && grep -q "def compensate_rolling_shutter" lib/cinematic/tracking/rolling_shutter.py && echo "RollingShutterCompensator and compensate_rolling_shutter found"</verify>
  <done>RollingShutterCompensator class with compensate_frame() and get_compensation_matrix() methods exist</done>
</task>

</tasks>

<verification>
- RollingShutterConfig dataclass exists in types.py
- RollingShutterDetector class in rolling_shutter.py
- RollingShutterCompensator class in rolling_shutter.py
- DEVICE_READ_TIMES dictionary provides device-specific read times
- Code handles missing OpenCV gracefully
</verification>

<success_criteria>
- RollingShutterDetector.detect() returns RollingShutterConfig
- Detection analyzes row-wise motion patterns
- Compensation reduces skew in footage with rolling shutter
- Device read time presets available for common cameras
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-footage-profiles/07.2-02-SUMMARY.md`
</output>
