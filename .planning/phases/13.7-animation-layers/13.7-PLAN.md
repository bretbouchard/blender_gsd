# Phase 13.7: Animation Layers

**Goal**: Non-destructive animation editing with multiple layers.

**Requirements**: `.planning/REQUIREMENTS_ANIMATION.md` (REQ-ANIM-09)

**Depends On**: Phase 13.0 (Rigging), Phase 13.1 (IK/FK)

**Duration**: 4-5 days

---

## Overview

Build an animation layer system that supports:
- Multiple animation layers
- Layer opacity/mixing
- Layer masking (affect only some bones)
- Solo/mute layers
- Non-destructive editing

**Philosophy**: Animation is built in layers. Base motion + details + polish = final.

---

## Architecture

```
lib/animation/
├── layers/
│   ├── __init__.py
│   ├── layer_system.py     # Core layer management
│   ├── layer_blend.py      # Blending operations
│   └── layer_mask.py       # Bone masking

configs/animation/
└── layers/
    └── layer_presets.yaml   # Common layer setups

.gsd-state/
└── layers/
    └── {rig_id}/
        ├── base_layer.yaml
        ├── detail_layer.yaml
        └── blend_result.yaml
```

---

## Data Model

### Layer Structure
```yaml
# .gsd-state/layers/hero_rig/layers.yaml
rig: hero_rig

layers:
  - id: base
    name: "Base Animation"
    type: base
    opacity: 1.0
    mute: false
    solo: false
    bones: []  # Empty = all bones
    keyframes:
      - frame: 1
        bones:
          root: {loc: [0, 0, 0], rot: [0, 0, 0]}
      - frame: 24
        bones:
          root: {loc: [0, 0, 0], rot: [0, 15, 0]}

  - id: detail
    name: "Detail Motion"
    type: additive
    opacity: 0.7
    mute: false
    solo: false
    bones: [spine_01, spine_02, spine_03]
    keyframes:
      - frame: 1
        bones:
          spine_01: {rot: [0, 0, 2]}
      - frame: 12
        bones:
          spine_01: {rot: [0, 0, -2]}

  - id: secondary
    name: "Secondary Motion"
    type: additive
    opacity: 0.5
    mute: false
    solo: false
    bones: [head, hand_L, hand_R]
```

### Types
```python
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Optional, Set
from enum import Enum

class LayerType(Enum):
    BASE = "base"           # Foundation layer (only one)
    OVERRIDE = "override"   # Replace values
    ADDITIVE = "additive"   # Add to values
    MIX = "mix"            # Blend with previous

@dataclass
class BoneKeyframe:
    location: Tuple[float, float, float] = (0, 0, 0)
    rotation: Tuple[float, float, float] = (0, 0, 0)  # Euler degrees
    scale: Tuple[float, float, float] = (1, 1, 1)

@dataclass
class LayerKeyframe:
    frame: int
    bones: Dict[str, BoneKeyframe] = field(default_factory=dict)

@dataclass
class AnimationLayer:
    id: str
    name: str
    layer_type: LayerType = LayerType.ADDITIVE
    opacity: float = 1.0
    mute: bool = False
    solo: bool = False
    bone_mask: Set[str] = field(default_factory=set)  # Empty = all bones
    keyframes: List[LayerKeyframe] = field(default_factory=list)
    order: int = 0

@dataclass
class LayerStack:
    rig_id: str
    layers: List[AnimationLayer] = field(default_factory=list)
    active_layer: Optional[str] = None

    def get_layer(self, layer_id: str) -> Optional[AnimationLayer]:
        for layer in self.layers:
            if layer.id == layer_id:
                return layer
        return None

    def get_visible_layers(self) -> List[AnimationLayer]:
        """Get layers that contribute to final animation."""
        # If any layer is soloed, only show solo layers
        solo_layers = [l for l in self.layers if l.solo and not l.mute]
        if solo_layers:
            return solo_layers

        # Otherwise, show non-muted layers
        return [l for l in self.layers if not l.mute]
```

---

## Tasks

### Task 1: Layer System Core
**File**: `lib/animation/layers/layer_system.py`

```python
import bpy
from typing import List, Dict, Optional, Set
from pathlib import Path
import yaml
from .types import AnimationLayer, LayerStack, LayerType, LayerKeyframe, BoneKeyframe

class AnimationLayerSystem:
    """Manage animation layers for non-destructive editing."""

    def __init__(self, armature: bpy.types.Object):
        self.armature = armature
        self.stack = LayerStack(rig_id=armature.name)

    def create_layer(
        self,
        name: str,
        layer_type: LayerType = LayerType.ADDITIVE,
        bone_mask: Set[str] = None
    ) -> AnimationLayer:
        """Create a new animation layer."""
        layer_id = name.lower().replace(' ', '_')

        # Check for duplicate
        if self.stack.get_layer(layer_id):
            raise ValueError(f"Layer already exists: {layer_id}")

        layer = AnimationLayer(
            id=layer_id,
            name=name,
            layer_type=layer_type,
            bone_mask=bone_mask or set(),
            order=len(self.stack.layers)
        )

        self.stack.layers.append(layer)
        return layer

    def delete_layer(self, layer_id: str) -> bool:
        """Delete a layer."""
        layer = self.stack.get_layer(layer_id)
        if layer and layer.layer_type != LayerType.BASE:
            self.stack.layers.remove(layer)
            return True
        return False

    def set_layer_opacity(self, layer_id: str, opacity: float) -> None:
        """Set layer opacity (0-1)."""
        layer = self.stack.get_layer(layer_id)
        if layer:
            layer.opacity = max(0, min(1, opacity))

    def mute_layer(self, layer_id: str, mute: bool = True) -> None:
        """Mute/unmute a layer."""
        layer = self.stack.get_layer(layer_id)
        if layer:
            layer.mute = mute

    def solo_layer(self, layer_id: str, solo: bool = True) -> None:
        """Solo/unsolo a layer."""
        layer = self.stack.get_layer(layer_id)
        if layer:
            layer.solo = solo

    def set_layer_bone_mask(self, layer_id: str, bones: Set[str]) -> None:
        """Set which bones this layer affects."""
        layer = self.stack.get_layer(layer_id)
        if layer:
            layer.bone_mask = bones

    def add_keyframe_to_layer(
        self,
        layer_id: str,
        frame: int,
        bone_name: str,
        location: tuple = None,
        rotation: tuple = None,
        scale: tuple = None
    ) -> None:
        """Add a keyframe to a layer."""
        layer = self.stack.get_layer(layer_id)
        if not layer:
            return

        # Find or create keyframe at frame
        kf = None
        for k in layer.keyframes:
            if k.frame == frame:
                kf = k
                break

        if not kf:
            kf = LayerKeyframe(frame=frame)
            layer.keyframes.append(kf)
            layer.keyframes.sort(key=lambda x: x.frame)

        # Add bone data
        bone_kf = kf.bones.get(bone_name, BoneKeyframe())
        if location:
            bone_kf.location = location
        if rotation:
            bone_kf.rotation = rotation
        if scale:
            bone_kf.scale = scale

        kf.bones[bone_name] = bone_kf

    def capture_to_layer(self, layer_id: str, frame: int, bones: List[str] = None) -> None:
        """Capture current pose to a layer at frame."""
        layer = self.stack.get_layer(layer_id)
        if not layer:
            return

        target_bones = bones or list(self.armature.pose.bones.keys())

        for bone_name in target_bones:
            if bone_name not in self.armature.pose.bones:
                continue

            pb = self.armature.pose.bones[bone_name]

            from math import degrees
            rotation = tuple(degrees(a) for a in pb.rotation_euler)

            self.add_keyframe_to_layer(
                layer_id,
                frame,
                bone_name,
                location=tuple(pb.location),
                rotation=rotation,
                scale=tuple(pb.scale)
            )

    def get_layers(self) -> List[AnimationLayer]:
        """Get all layers."""
        return self.stack.layers

    def get_active_layer(self) -> Optional[AnimationLayer]:
        """Get the currently active layer."""
        if self.stack.active_layer:
            return self.stack.get_layer(self.stack.active_layer)
        return None

    def set_active_layer(self, layer_id: str) -> None:
        """Set the active layer."""
        if self.stack.get_layer(layer_id):
            self.stack.active_layer = layer_id


def create_layer_system(armature: bpy.types.Object) -> AnimationLayerSystem:
    """Create an animation layer system for an armature."""
    system = AnimationLayerSystem(armature)

    # Create base layer
    system.create_layer("Base", LayerType.BASE)

    return system
```

**Acceptance**: Can create and manage layers

---

### Task 2: Layer Blending
**File**: `lib/animation/layers/layer_blend.py`

```python
import bpy
from typing import List, Dict, Tuple
from math import radians, degrees
from .types import AnimationLayer, LayerType, LayerStack, BoneKeyframe
from .layer_system import AnimationLayerSystem

class LayerBlender:
    """Blend animation layers together."""

    def __init__(self, system: AnimationLayerSystem):
        self.system = system
        self.armature = system.armature

    def evaluate(self, frame: int) -> Dict[str, BoneKeyframe]:
        """Evaluate all layers at a frame and return blended result."""
        visible_layers = self.system.stack.get_visible_layers()

        if not visible_layers:
            return {}

        # Start with identity (rest pose)
        result: Dict[str, BoneKeyframe] = {}

        # Get all bone names
        bone_names = list(self.armature.pose.bones.keys())

        # Initialize with rest pose
        for name in bone_names:
            result[name] = BoneKeyframe()

        # Apply each layer in order
        for layer in sorted(visible_layers, key=lambda l: l.order):
            layer_data = self._get_layer_data_at_frame(layer, frame)

            if layer.layer_type == LayerType.BASE:
                result = self._blend_base(result, layer_data, layer)

            elif layer.layer_type == LayerType.OVERRIDE:
                result = self._blend_override(result, layer_data, layer)

            elif layer.layer_type == LayerType.ADDITIVE:
                result = self._blend_additive(result, layer_data, layer)

            elif layer.layer_type == LayerType.MIX:
                result = self._blend_mix(result, layer_data, layer)

        return result

    def _get_layer_data_at_frame(self, layer: AnimationLayer, frame: int) -> Dict[str, BoneKeyframe]:
        """Get interpolated bone data for layer at frame."""
        # Find surrounding keyframes
        prev_kf = None
        next_kf = None

        for kf in layer.keyframes:
            if kf.frame <= frame:
                prev_kf = kf
            if kf.frame >= frame and next_kf is None:
                next_kf = kf

        # If no keyframes, return empty
        if prev_kf is None and next_kf is None:
            return {}

        # If exact frame, return that
        if prev_kf and prev_kf.frame == frame:
            return prev_kf.bones

        # Interpolate between keyframes
        if prev_kf and next_kf and prev_kf != next_kf:
            t = (frame - prev_kf.frame) / (next_kf.frame - prev_kf.frame)
            return self._interpolate_bones(prev_kf.bones, next_kf.bones, t)

        # Hold last/next keyframe
        if prev_kf:
            return prev_kf.bones
        if next_kf:
            return next_kf.bones

        return {}

    def _interpolate_bones(
        self,
        prev: Dict[str, BoneKeyframe],
        next: Dict[str, BoneKeyframe],
        t: float
    ) -> Dict[str, BoneKeyframe]:
        """Linear interpolation between two bone states."""
        result = {}

        all_bones = set(prev.keys()) | set(next.keys())

        for bone_name in all_bones:
            prev_bone = prev.get(bone_name, BoneKeyframe())
            next_bone = next.get(bone_name, BoneKeyframe())

            result[bone_name] = BoneKeyframe(
                location=tuple(prev_bone.location[i] * (1 - t) + next_bone.location[i] * t for i in range(3)),
                rotation=tuple(prev_bone.rotation[i] * (1 - t) + next_bone.rotation[i] * t for i in range(3)),
                scale=tuple(prev_bone.scale[i] * (1 - t) + next_bone.scale[i] * t for i in range(3))
            )

        return result

    def _blend_base(
        self,
        current: Dict[str, BoneKeyframe],
        layer_data: Dict[str, BoneKeyframe],
        layer: AnimationLayer
    ) -> Dict[str, BoneKeyframe]:
        """Base layer replaces everything."""
        result = current.copy()

        for bone_name, bone_kf in layer_data.items():
            if layer.bone_mask and bone_name not in layer.bone_mask:
                continue

            result[bone_name] = BoneKeyframe(
                location=bone_kf.location,
                rotation=bone_kf.rotation,
                scale=bone_kf.scale
            )

        return result

    def _blend_override(
        self,
        current: Dict[str, BoneKeyframe],
        layer_data: Dict[str, BoneKeyframe],
        layer: AnimationLayer
    ) -> Dict[str, BoneKeyframe]:
        """Override layer replaces specific bones."""
        result = current.copy()

        for bone_name, bone_kf in layer_data.items():
            if layer.bone_mask and bone_name not in layer.bone_mask:
                continue

            # Blend by opacity
            current_bone = current.get(bone_name, BoneKeyframe())
            opacity = layer.opacity

            result[bone_name] = BoneKeyframe(
                location=tuple(current_bone.location[i] * (1 - opacity) + bone_kf.location[i] * opacity for i in range(3)),
                rotation=tuple(current_bone.rotation[i] * (1 - opacity) + bone_kf.rotation[i] * opacity for i in range(3)),
                scale=tuple(current_bone.scale[i] * (1 - opacity) + bone_kf.scale[i] * opacity for i in range(3))
            )

        return result

    def _blend_additive(
        self,
        current: Dict[str, BoneKeyframe],
        layer_data: Dict[str, BoneKeyframe],
        layer: AnimationLayer
    ) -> Dict[str, BoneKeyframe]:
        """Additive layer adds to current values."""
        result = current.copy()

        for bone_name, bone_kf in layer_data.items():
            if layer.bone_mask and bone_name not in layer.bone_mask:
                continue

            current_bone = current.get(bone_name, BoneKeyframe())
            opacity = layer.opacity

            result[bone_name] = BoneKeyframe(
                location=tuple(current_bone.location[i] + bone_kf.location[i] * opacity for i in range(3)),
                rotation=tuple(current_bone.rotation[i] + bone_kf.rotation[i] * opacity for i in range(3)),
                scale=tuple(current_bone.scale[i] * bone_kf.scale[i] ** opacity for i in range(3))
            )

        return result

    def _blend_mix(
        self,
        current: Dict[str, BoneKeyframe],
        layer_data: Dict[str, BoneKeyframe],
        layer: AnimationLayer
    ) -> Dict[str, BoneKeyframe]:
        """Mix layer blends with current."""
        return self._blend_override(current, layer_data, layer)

    def apply_to_armature(self, frame: int) -> None:
        """Apply blended result to armature at frame."""
        blended = self.evaluate(frame)

        for bone_name, bone_kf in blended.items():
            if bone_name not in self.armature.pose.bones:
                continue

            pb = self.armature.pose.bones[bone_name]

            pb.location = bone_kf.location
            pb.rotation_euler = [radians(a) for a in bone_kf.rotation]
            pb.scale = bone_kf.scale

    def bake_to_action(self, start_frame: int, end_frame: int, action_name: str = "Baked") -> bpy.types.Action:
        """Bake all layers to a single action."""
        # Create new action
        action = bpy.data.actions.new(action_name)

        # Store original action
        original_action = self.armature.animation_data.action if self.armature.animation_data else None

        # Assign new action
        if not self.armature.animation_data:
            self.armature.animation_data_create()
        self.armature.animation_data.action = action

        # Bake each frame
        for frame in range(start_frame, end_frame + 1):
            self.apply_to_armature(frame)

            # Keyframe all bones
            for pb in self.armature.pose.bones:
                pb.keyframe_insert(data_path="location", frame=frame)
                pb.keyframe_insert(data_path="rotation_euler", frame=frame)
                pb.keyframe_insert(data_path="scale", frame=frame)

        # Restore original action
        self.armature.animation_data.action = original_action

        return action


def blend_layers(system: AnimationLayerSystem, frame: int) -> Dict[str, BoneKeyframe]:
    """Convenience function to blend layers at frame."""
    blender = LayerBlender(system)
    return blender.evaluate(frame)
```

**Acceptance**: Layer blending works

---

### Task 3: Layer Masking
**File**: `lib/animation/layers/layer_mask.py`

```python
import bpy
from typing import Set, List, Dict
from .layer_system import AnimationLayerSystem

class LayerMaskManager:
    """Manage bone masks for animation layers."""

    @staticmethod
    def create_bone_mask_from_group(
        armature: bpy.types.Object,
        group_name: str
    ) -> Set[str]:
        """Create a bone mask from a bone group."""
        mask = set()

        if group_name in armature.pose.bone_groups:
            group = armature.pose.bone_groups[group_name]
            for pb in armature.pose.bones:
                if pb.bone_group == group:
                    mask.add(pb.name)

        return mask

    @staticmethod
    def create_bone_mask_from_pattern(
        armature: bpy.types.Object,
        pattern: str
    ) -> Set[str]:
        """Create a bone mask from a name pattern (e.g., 'hand_*')."""
        import fnmatch

        mask = set()
        for pb in armature.pose.bones:
            if fnmatch.fnmatch(pb.name, pattern):
                mask.add(pb.name)

        return mask

    @staticmethod
    def create_bone_mask_from_side(
        armature: bpy.types.Object,
        side: str  # 'left', 'right', 'center'
    ) -> Set[str]:
        """Create a bone mask for one side of the body."""
        mask = set()

        for pb in armature.pose.bones:
            name = pb.name.lower()

            if side == 'left':
                if '_l' in name or name.endswith('l') or '.l' in name:
                    mask.add(pb.name)
            elif side == 'right':
                if '_r' in name or name.endswith('r') or '.r' in name:
                    mask.add(pb.name)
            elif side == 'center':
                if not ('_l' in name or '_r' in name or '.l' in name or '.r' in name):
                    mask.add(pb.name)

        return mask

    @staticmethod
    def invert_mask(armature: bpy.types.Object, mask: Set[str]) -> Set[str]:
        """Invert a bone mask."""
        all_bones = set(armature.pose.bones.keys())
        return all_bones - mask

    @staticmethod
    def combine_masks(masks: List[Set[str]], operation: str = 'union') -> Set[str]:
        """Combine multiple masks."""
        if not masks:
            return set()

        if operation == 'union':
            result = set()
            for m in masks:
                result |= m
            return result

        elif operation == 'intersection':
            result = masks[0].copy()
            for m in masks[1:]:
                result &= m
            return result

        elif operation == 'difference':
            result = masks[0].copy()
            for m in masks[1:]:
                result -= m
            return result

        return set()

    @staticmethod
    def get_preset_masks(armature: bpy.types.Object) -> Dict[str, Set[str]]:
        """Get common preset bone masks."""
        return {
            'all': set(armature.pose.bones.keys()),
            'left_arm': LayerMaskManager.create_bone_mask_from_pattern(armature, '*arm*L') |
                        LayerMaskManager.create_bone_mask_from_pattern(armature, '*arm_L'),
            'right_arm': LayerMaskManager.create_bone_mask_from_pattern(armature, '*arm*R') |
                         LayerMaskManager.create_bone_mask_from_pattern(armature, '*arm_R'),
            'left_leg': LayerMaskManager.create_bone_mask_from_pattern(armature, '*leg*L') |
                        LayerMaskManager.create_bone_mask_from_pattern(armature, '*leg_L'),
            'right_leg': LayerMaskManager.create_bone_mask_from_pattern(armature, '*leg*R') |
                         LayerMaskManager.create_bone_mask_from_pattern(armature, '*leg_R'),
            'spine': LayerMaskManager.create_bone_mask_from_pattern(armature, 'spine*'),
            'head': LayerMaskManager.create_bone_mask_from_pattern(armature, 'head*') |
                    LayerMaskManager.create_bone_mask_from_pattern(armature, 'neck*'),
            'hands': LayerMaskManager.create_bone_mask_from_pattern(armature, 'hand*') |
                     LayerMaskManager.create_bone_mask_from_pattern(armature, 'finger*'),
        }


def apply_mask_to_layer(system: AnimationLayerSystem, layer_id: str, mask_name: str) -> None:
    """Apply a preset mask to a layer."""
    masks = LayerMaskManager.get_preset_masks(system.armature)

    if mask_name in masks:
        layer = system.stack.get_layer(layer_id)
        if layer:
            layer.bone_mask = masks[mask_name]
```

**Acceptance**: Bone masking works

---

## Acceptance Criteria

### Must Have
- [ ] Create/delete layers
- [ ] Layer types (base, override, additive, mix)
- [ ] Layer opacity
- [ ] Mute/solo layers
- [ ] Blend layers together
- [ ] Apply to armature

### Nice to Have
- [ ] Bone masking
- [ ] Bake to action
- [ ] Layer presets
- [ ] Visual layer stack

---

## Commands

```python
# Create layer system
from lib.animation.layers import create_layer_system
system = create_layer_system(armature)

# Create layers
system.create_layer("Base", LayerType.BASE)
system.create_layer("Detail", LayerType.ADDITIVE)
system.create_layer("Hand Animation", LayerType.OVERRIDE)

# Capture to layer
system.capture_to_layer("Detail", frame=24, bones=["spine_01", "spine_02"])

# Set opacity
system.set_layer_opacity("Detail", 0.5)

# Blend and apply
from lib.animation.layers import LayerBlender
blender = LayerBlender(system)
blender.apply_to_armature(frame=24)

# Bake to action
blender.bake_to_action(start_frame=1, end_frame=100, action_name="Final")
```

---

## AI Commands Reference

```
# Create layer
"Create an additive layer called 'breathing' for the spine bones"

# Capture to layer
"Capture the current pose to the 'detail' layer at frame 24"

# Set opacity
"Set the 'detail' layer opacity to 50%"

# Bake layers
"Bake all layers to a new action from frame 1 to 100"
```

---

## Council of Ricks Review Notes

**Review Date**: 2026-02-19
**Status**: APPROVED with recommendations

### Geometry Rick - Animation Data

1. **Rotation Interpolation**
   - Linear interpolation between Euler angles can cause gimbal lock artifacts
   - Recommendation: Use quaternion slerp for rotation interpolation

2. **Scale Blending in Additive Mode**
   - Current: `scale[i] * bone_kf.scale[i] ** opacity`
   - Issue: Power function behaves unexpectedly for negative values
   - Recommendation: Use multiplicative blend: `scale[i] * (1 + (bone_kf.scale[i] - 1) * opacity)`

3. **Layer Order Dependency**
   - Layer order significantly affects result but isn't clearly visualized
   - Recommendation: Add visual layer stack UI mockup or order documentation

### Automation Rick - Data Persistence

4. **Layer State Serialization**
   - No save/load methods for LayerStack
   - Risk: Layer work lost on session end
   - Recommendation: Add `save_layers()` and `load_layers()` methods with YAML export

### Dufus Rick - Testing Recommendations

5. **Test Tasks to Add**
   - Task: Test layer blend with 100 layers (performance)
   - Task: Verify solo layer behavior with multiple soloed layers
   - Task: Test bone mask with non-existent bone names
   - Task: Verify bake_to_action preserves interpolation
   - Task: Test layer opacity at exactly 0.0 and 1.0

6. **Acceptance Criteria Improvements**
   - Add: "Layer evaluation completes in <10ms for 100 bones, 10 layers"
   - Add: "Bake operation shows progress for long frame ranges"
