# Phase 8.1: Script Parser

**Phase**: 8.1
**Priority**: P1
**Dependencies**: Phase 6.x (Core Cinematic)
**Est. Duration**: 5-6 days

---

## Goal

Parse screenplay formats (Fountain, Final Draft) into structured data that can drive automated production.

---

## Requirements

- REQ-SCRIPT-01: Parse Fountain format
- REQ-SCRIPT-02: Parse Final Draft (.fdx)
- REQ-SCRIPT-03: Extract scenes, characters, dialogue
- REQ-SCRIPT-04: Generate beat sheets
- REQ-SCRIPT-05: Calculate timing estimates

---

## Plans

### Plan 8.1-01: Script Types

**Deliverable**: `lib/development/script_types.py`

```python
@dataclass
class Script:
    """Parsed screenplay."""
    title: str
    author: str
    draft: str
    date: str
    scenes: List[Scene]
    characters: List[Character]
    locations: List[Location]
    total_pages: float
    estimated_runtime: float  # minutes (1 page ≈ 1 minute)

@dataclass
class Scene:
    """Single scene from script."""
    number: int
    heading: str  # "INT. WAREHOUSE - NIGHT"
    location: str  # Extracted location name
    interior: bool
    time_of_day: str  # DAY, NIGHT, DAWN, DUSK, CONTINUOUS
    action: List[ActionBlock]
    dialogue: List[DialogueLine]
    transitions: List[Transition]
    page_start: float
    page_end: float
    estimated_duration: float  # seconds

@dataclass
class Character:
    """Character from script."""
    name: str
    aliases: List[str]  # (V.O.), (O.S.), etc.
    dialogue_count: int
    dialogue_word_count: int
    first_appearance: int  # scene number
    last_appearance: int
    scenes_appearing: List[int]

@dataclass
class Location:
    """Location from script."""
    name: str
    scene_count: int
    scenes: List[int]
    interior: bool
    time_variants: List[str]  # DAY, NIGHT, etc.

@dataclass
class ActionBlock:
    """Action/description block."""
    text: str
    page: float

@dataclass
class DialogueLine:
    """Single line of dialogue."""
    character: str
    extension: str  # (V.O.), (O.S.), (CONT'D)
    parenthetical: str
    text: str
    page: float

@dataclass
class Transition:
    """Scene transition."""
    type: str  # CUT TO:, FADE OUT., DISSOLVE TO:
    page: float

@dataclass
class BeatSheet:
    """Generated beat sheet."""
    beats: List[Beat]
    act_breaks: List[int]  # Scene numbers

@dataclass
class Beat:
    """Single story beat."""
    scene_number: int
    beat_type: str  # setup, catalyst, debate, etc.
    description: str
    emotional_value: float  # -1 to 1
    pages: float
```

**Tasks**:
1. Create all dataclasses
2. Add serialization methods
3. Add helper methods (get_scene_by_number, etc.)

---

### Plan 8.1-02: Fountain Parser

**Deliverable**: `lib/development/fountain_parser.py`

Fountain is a plain text markup language for screenwriting.

```python
class FountainParser:
    """Parse Fountain format scripts."""

    def parse(self, text: str) -> Script:
        """Parse Fountain text into Script object."""
        pass

    def parse_file(self, path: str) -> Script:
        """Parse Fountain file."""
        pass

    def _parse_heading(self, line: str) -> Tuple[bool, str, str, str]:
        """Parse scene heading: INT./EXT., LOCATION, TIME."""
        pass

    def _parse_action(self, lines: List[str]) -> ActionBlock:
        """Parse action/description block."""
        pass

    def _parse_dialogue(self, lines: List[str]) -> DialogueLine:
        """Parse dialogue block."""
        pass

    def _parse_character(self, line: str) -> Tuple[str, str]:
        """Parse character name and extension."""
        pass

    def _parse_transition(self, line: str) -> Transition:
        """Parse transition."""
        pass

    def _extract_characters(self, script: Script) -> List[Character]:
        """Extract all characters from parsed script."""
        pass

    def _extract_locations(self, script: Script) -> List[Location]:
        """Extract all locations from parsed script."""
        pass
```

**Tasks**:
1. Implement scene heading parser
2. Implement action parser
3. Implement dialogue parser (with parentheticals)
4. Implement character/extension parsing
5. Implement transition parsing
6. Implement character extraction
7. Implement location extraction
8. Test with sample Fountain files

---

### Plan 8.1-03: Final Draft Parser

**Deliverable**: `lib/development/fdx_parser.py`

```python
class FdxParser:
    """Parse Final Draft .fdx files (XML format)."""

    def parse(self, xml_content: str) -> Script:
        """Parse FDX XML content."""
        pass

    def parse_file(self, path: str) -> Script:
        """Parse FDX file."""
        pass

    def _extract_paragraphs(self, root) -> List[Dict]:
        """Extract all paragraphs from FDX."""
        pass

    def _paragraph_to_element(self, para: Dict) -> Union[Scene, ActionBlock, DialogueLine, Transition]:
        """Convert FDX paragraph to script element."""
        pass
```

**Tasks**:
1. Understand FDX XML structure
2. Implement XML parsing
3. Map FDX types to our types
4. Test with sample FDX files

---

### Plan 8.1-04: Beat Sheet Generator

**Deliverable**: `lib/development/beat_generator.py`

```python
def generate_beat_sheet(script: Script, structure: str = "save_the_cat") -> BeatSheet:
    """Generate beat sheet from parsed script."""
    pass

def identify_act_breaks(script: Script) -> List[int]:
    """Identify act break scene numbers."""
    pass

def calculate_pacing(script: Script) -> List[float]:
    """Calculate pacing curve (tension over time)."""
    pass

def identify_emotional_peaks(script: Script) -> List[int]:
    """Identify emotional peak scenes."""
    pass

# Blake Snyder's Save the Cat structure
SAVE_THE_CAT_BEATS = {
    "opening_image": 0.0,      # 0%
    "setup": 0.0,              # 0-10%
    "theme_stated": 0.05,      # 5%
    "catalyst": 0.10,          # 10%
    "debate": 0.10,            # 10-20%
    "break_into_two": 0.25,    # 25%
    "b_story": 0.27,           # 27%
    "fun_and_games": 0.30,     # 30-50%
    "midpoint": 0.50,          # 50%
    "bad_guys_close_in": 0.50, # 50-62%
    "all_is_lost": 0.62,       # 62%
    "dark_night_of_soul": 0.75,# 75%
    "break_into_three": 0.80,  # 80%
    "finale": 0.80,            # 80-100%
    "final_image": 1.0,        # 100%
}

# Three-act structure
THREE_ACT_BEATS = {
    "act_1_end": 0.25,
    "act_2_midpoint": 0.50,
    "act_2_end": 0.75,
    "climax": 0.90,
}
```

**Tasks**:
1. Implement Save the Cat beat detection
2. Implement three-act structure detection
3. Implement pacing calculation
4. Implement emotional peak detection
5. Create beat visualization

---

### Plan 8.1-05: Script Analysis

**Deliverable**: `lib/development/script_analysis.py`

```python
def analyze_script(script: Script) -> ScriptAnalysis:
    """Generate comprehensive script analysis."""
    pass

@dataclass
class ScriptAnalysis:
    """Analysis results."""
    total_scenes: int
    total_pages: float
    estimated_runtime: float
    character_count: int
    location_count: int
    dialogue_percentage: float
    action_percentage: float
    day_night_ratio: float
    interior_exterior_ratio: float
    longest_scene: int
    shortest_scene: int
    most_dialogue: str  # Character name
    pacing: List[float]
    recommendations: List[str]
```

**Tasks**:
1. Implement page/time calculations
2. Implement dialogue vs action analysis
3. Implement day/night breakdown
4. Implement interior/exterior breakdown
5. Generate recommendations
6. Create analysis report format

---

### Plan 8.1-06: Integration & Testing

**Deliverable**: Tests and examples

**Tasks**:
1. Create sample Fountain scripts
2. Create sample FDX files (or find open source ones)
3. Test parser edge cases
4. Test beat sheet generation
5. Document usage
6. Update __init__.py

---

## Files

```
lib/development/
├── __init__.py
├── script_types.py        # Data structures
├── fountain_parser.py     # Fountain format
├── fdx_parser.py          # Final Draft format
├── beat_generator.py      # Beat sheet creation
└── script_analysis.py     # Analysis tools

configs/development/
└── beat_structures.yaml   # Beat structure definitions
```

---

## Acceptance Criteria

- [ ] Fountain parser handles all element types
- [ ] FDX parser imports Final Draft files
- [ ] Characters extracted with dialogue counts
- [ ] Locations extracted with scene counts
- [ ] Beat sheet generated from structure templates
- [ ] Analysis provides useful insights
- [ ] Runtime estimate within 10% of actual
