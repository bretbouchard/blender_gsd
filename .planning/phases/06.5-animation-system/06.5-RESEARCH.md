# Phase 6.5: Animation System - Research

**Researched:** 2026-02-18
**Domain:** Blender Python API (bpy) animation, keyframes, motion paths
**Confidence:** HIGH

## Summary

This phase implements the animation system for the cinematic rendering pipeline, covering camera movements, procedural motion paths, turntable rotation, and audio synchronization. The research focused on Blender's bpy animation API, keyframe insertion patterns, motion path generation algorithms, and integration with the existing cinematic system architecture.

The animation system builds on the existing camera rigs (tripod, dolly, crane, steadicam, drone) and plumb bob targeting system. Animation presets are already defined in `configs/cinematic/animation/camera_moves.yaml` and `easing_curves.yaml`, requiring implementation of the animation.py and motion_path.py modules.

**Primary recommendation:** Use Blender's native keyframe API (`obj.keyframe_insert()`) with f-curve interpolation control, implement procedural orbit/dolly paths using trigonometry with the plumb bob as pivot, and leverage Follow Path constraints for Bezier curve following.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| bpy | Blender 5.x | Native Blender Python API | Official API, most stable |
| math | Python stdlib | Trigonometry for paths | Built-in, no dependencies |
| mathutils | Blender bundled | Vector/Quaternion math | Blender's vector library |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| aud | Blender bundled | Audio playback/analysis | Audio sync features |
| bmesh | Blender bundled | Mesh operations | Path visualization geometry |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual keyframe insertion | NLA tracks | NLA is more complex, keyframes are direct |
| Follow Path constraint | Manual position keyframes | Constraint is declarative, easier to configure |
| Procedural path generation | Manual path drawing | Procedural is reproducible and GSD-compliant |

**Installation:**
No external dependencies required. All modules are part of Blender's Python environment.

## Architecture Patterns

### Recommended Project Structure
```
lib/cinematic/
├── animation.py          # Camera moves, keyframes, unified timeline
├── motion_path.py        # Procedural path generation (Bezier, spline)
├── turntable.py          # Object rotation system (integrated or separate)
└── audio_sync.py         # Audio beat detection and timeline markers

configs/cinematic/animation/
├── camera_moves.yaml     # Pre-defined (already exists)
├── easing_curves.yaml    # Easing functions (already exists)
└── turntable_presets.yaml # Turntable configurations (to create)
```

### Pattern 1: Keyframe Insertion Pattern
**What:** Standard approach for inserting animation keyframes in Blender via Python
**When to use:** All camera/object property animations
**Example:**
```python
# Source: Based on bpy API documentation
import bpy

def animate_camera_orbit(camera_name, center, radius, start_frame, end_frame):
    """Animate camera orbiting around a center point."""
    import math

    camera = bpy.data.objects[camera_name]
    total_frames = end_frame - start_frame

    for frame in range(start_frame, end_frame + 1):
        t = (frame - start_frame) / total_frames
        angle = 2 * math.pi * t  # Full rotation

        # Calculate position
        x = center[0] + radius * math.sin(angle)
        y = center[1] - radius * math.cos(angle)
        z = center[2]

        camera.location = (x, y, z)
        camera.keyframe_insert(data_path="location", frame=frame)

    # Set interpolation to LINEAR for smooth constant speed
    for fcurve in camera.animation_data.action.fcurves:
        for kp in fcurve.keyframe_points:
            kp.interpolation = 'LINEAR'
```

### Pattern 2: Procedural Orbit Path Generation
**What:** Generate camera path points around plumb bob center with easing
**When to use:** Orbit camera animations (orbit_90, orbit_180, orbit_360 presets)
**Example:**
```python
# Source: CINEMATIC_SYSTEM_DESIGN.md Section 13.11
def generate_orbit_path(config: dict) -> list:
    """
    Generate procedural orbit camera path.

    ALGORITHM:
    1. Calculate orbit points around plumb bob
    2. Apply height variation if elevation range specified
    3. Generate quaternion look-at for each point
    4. Return list of (position, rotation, easing) tuples
    """
    import math
    from mathutils import Vector, Quaternion

    center = Vector(config['center'])
    radius = config['radius']
    angle_start, angle_end = config['angle_range']
    elevation = config.get('elevation', 0)
    duration = config['duration']
    easing = config.get('easing', 'linear')

    points = []

    for frame in range(duration + 1):
        t = frame / duration
        t = apply_easing(t, easing)  # Apply easing function

        angle = math.radians(angle_start + (angle_end - angle_start) * t)

        x = center.x + radius * math.sin(angle)
        y = center.y - radius * math.cos(angle)
        z = center.z + elevation if isinstance(elevation, (int, float)) \
            else center.z + elevation[0] + (elevation[1] - elevation[0]) * t

        position = Vector((x, y, z))
        direction = (center - position).normalized()
        rotation = direction.to_track_quat('-Z', 'Y')

        points.append((position, rotation, easing))

    return points


def apply_easing(t: float, easing: str) -> float:
    """Apply easing function to normalized time 0-1."""
    if easing == 'linear':
        return t
    elif easing == 'ease_in':
        return t * t
    elif easing == 'ease_out':
        return 1 - (1 - t) * (1 - t)
    elif easing == 'ease_in_out':
        if t < 0.5:
            return 2 * t * t
        else:
            return 1 - pow(-2 * t + 2, 2) / 2
    return t
```

### Pattern 3: Turntable Animation (Subject Rotation)
**What:** Rotate the subject object instead of the camera for product showcase
**When to use:** Product turntable shots where camera stays static
**Example:**
```python
# Source: Based on turntable animation best practices
def create_turntable_animation(obj_name, start_frame=1, end_frame=120, axis='Z'):
    """Create 360-degree turntable animation for an object."""
    import math

    obj = bpy.data.objects.get(obj_name)
    if obj is None:
        return False

    # Set rotation mode to Euler for easier keyframing
    obj.rotation_mode = 'XYZ'

    # Start keyframe (0 degrees)
    obj.rotation_euler = [0, 0, 0]
    obj.keyframe_insert(data_path="rotation_euler", frame=start_frame)

    # End keyframe (360 degrees = 2 * pi radians)
    radians_360 = math.radians(360)
    if axis == 'Z':
        obj.rotation_euler = [0, 0, radians_360]
    elif axis == 'Y':
        obj.rotation_euler = [0, radians_360, 0]
    else:
        obj.rotation_euler = [radians_360, 0, 0]

    obj.keyframe_insert(data_path="rotation_euler", frame=end_frame)

    # Set interpolation to LINEAR for constant speed rotation
    for fcurve in obj.animation_data.action.fcurves:
        for kp in fcurve.keyframe_points:
            kp.interpolation = 'LINEAR'

    return True
```

### Pattern 4: Follow Path Constraint for Bezier Curves
**What:** Use Blender's Follow Path constraint for complex curved camera movements
**When to use:** Custom Bezier paths, dolly_curved movements
**Example:**
```python
# Source: Blender Python API patterns
def setup_camera_follow_path(camera_name, curve_name, duration=120):
    """Setup camera to follow a Bezier curve path."""

    camera = bpy.data.objects[camera_name]
    curve = bpy.data.objects[curve_name]

    # Add Follow Path constraint
    follow = camera.constraints.new(type='FOLLOW_PATH')
    follow.target = curve
    follow.use_fixed_location = False
    follow.use_curve_follow = True  # Camera rotates with curve

    # Animate the offset factor (0 to 100)
    scene = bpy.context.scene
    start_frame = scene.frame_start

    follow.offset_factor = 0.0
    follow.keyframe_insert(data_path='constraints["Follow Path"].offset_factor',
                          frame=start_frame)

    follow.offset_factor = 100.0
    follow.keyframe_insert(data_path='constraints["Follow Path"].offset_factor',
                          frame=start_frame + duration)
```

### Pattern 5: FCurve Interpolation Control
**What:** Control easing via f-curve interpolation settings
**When to use:** Fine-grained animation curve control
**Example:**
```python
# Source: bpy f-curve API
def set_keyframe_interpolation(obj, data_path, interpolation='BEZIER', easing='AUTO'):
    """Set interpolation mode for all keyframes on a data path."""
    if not obj.animation_data or not obj.animation_data.action:
        return

    for fcurve in obj.animation_data.action.fcurves:
        if fcurve.data_path == data_path:
            for kp in fcurve.keyframe_points:
                kp.interpolation = interpolation  # BEZIER, LINEAR, CONSTANT
                if interpolation == 'BEZIER':
                    kp.easing = easing  # AUTO, EASE_IN, EASE_OUT, EASE_IN_OUT
```

### Anti-Patterns to Avoid
- **Using bpy.ops for animation:** `bpy.ops.anim.keyframe_insert()` requires context; use `obj.keyframe_insert()` directly
- **Forgetting to set rotation_mode:** Objects default to QUATERNION; set to 'XYZ' for Euler keyframing
- **Not clearing existing keyframes:** Animation data accumulates; clear before creating new animations
- **Using degrees instead of radians:** Blender uses radians internally; convert with `math.radians()`

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Easing functions | Custom math | Blender f-curve interpolation | 18 built-in easing types, handles edge cases |
| Path following | Manual position calculation | Follow Path constraint | Declarative, handles complex curves |
| Look-at rotation | Quaternion math from scratch | `direction.to_track_quat('-Z', 'Y')` | mathutils handles edge cases |
| Timeline sync | Frame counting | Blender scene.frame_set() | Handles frame rate, sub-frames |

**Key insight:** Blender has robust built-in animation systems. Use native keyframes, f-curves, and constraints rather than implementing animation from scratch.

## Common Pitfalls

### Pitfall 1: Context-Dependent Animation
**What goes wrong:** Using `bpy.ops` functions that require specific context (selected object, active area)
**Why it happens:** `bpy.ops` is tempting because it mirrors UI actions
**How to avoid:** Always use direct property access and `obj.keyframe_insert(data_path=...)`
**Warning signs:** "Poll failed" errors, animations applied to wrong object

### Pitfall 2: Forgetting Interpolation Settings
**What goes wrong:** Camera movement is jerky or accelerates unexpectedly
**Why it happens:** Default interpolation is BEZIER which has ease-in/out
**How to avoid:** Always set `kp.interpolation = 'LINEAR'` for constant-speed motion
**Warning signs:** Non-uniform camera speed, ease-in/out on turntables

### Pitfall 3: Radian/Degree Confusion
**What goes wrong:** Rotation is wrong by factor of ~57 (180/pi)
**Why it happens:** UI shows degrees, API uses radians
**How to avoid:** Use `math.radians()` for all angle inputs, `math.degrees()` for display
**Warning signs:** Rotation is much smaller or larger than expected

### Pitfall 4: Animation Data Accumulation
**What goes wrong:** Multiple animation runs create conflicting keyframes
**Why it happens:** Animation data persists across script runs
**How to avoid:** Clear animation data before creating new: `obj.animation_data_clear()`
**Warning signs:** Keyframes at unexpected frames, erratic animation

### Pitfall 5: Timeline Frame Range Mismatch
**What goes wrong:** Animation doesn't play because scene frame range doesn't match
**Why it happens:** Animation keyframes created outside scene.frame_start/end
**How to avoid:** Set `scene.frame_start` and `scene.frame_end` before creating keyframes
**Warning signs:** Animation exists but doesn't play in timeline

## Code Examples

Verified patterns from official sources:

### Complete Orbit Animation Function
```python
# Source: Based on CINEMATIC_SYSTEM_DESIGN.md and existing types.py patterns
import bpy
import math
from typing import List, Tuple, Optional
from mathutils import Vector

def create_orbit_animation(
    camera_name: str,
    target_position: Tuple[float, float, float],
    radius: float = 1.0,
    angle_range: Tuple[float, float] = (0, 360),
    duration: int = 120,
    easing: str = "linear",
    start_frame: int = 1
) -> bool:
    """
    Create orbit animation around a target point.

    Args:
        camera_name: Name of the camera object
        target_position: Center point (plumb bob location)
        radius: Distance from target
        angle_range: (start_angle, end_angle) in degrees
        duration: Number of frames for animation
        easing: Easing type (linear, ease_in, ease_out, ease_in_out)
        start_frame: First frame of animation

    Returns:
        True on success, False on failure
    """
    if camera_name not in bpy.data.objects:
        return False

    camera = bpy.data.objects[camera_name]
    center = Vector(target_position)

    # Clear existing animation
    if camera.animation_data:
        camera.animation_data_clear()

    # Generate keyframes
    for frame_offset in range(duration + 1):
        t = frame_offset / duration
        t_eased = apply_easing(t, easing)

        angle_deg = angle_range[0] + (angle_range[1] - angle_range[0]) * t_eased
        angle_rad = math.radians(angle_deg)

        x = center.x + radius * math.sin(angle_rad)
        y = center.y - radius * math.cos(angle_rad)
        z = center.z

        camera.location = (x, y, z)
        camera.keyframe_insert(data_path="location", frame=start_frame + frame_offset)

    # Add Track To constraint to always face target
    # Create or reuse target empty
    target_empty = get_or_create_target_empty(target_position, f"{camera_name}_orbit_target")

    track = camera.constraints.new(type='TRACK_TO')
    track.target = target_empty
    track.track_axis = 'TRACK_NEGATIVE_Z'
    track.up_axis = 'UP_Y'

    # Set interpolation for smooth motion
    for fcurve in camera.animation_data.action.fcurves:
        for kp in fcurve.keyframe_points:
            kp.interpolation = 'LINEAR'

    return True


def apply_easing(t: float, easing: str) -> float:
    """Apply easing function to normalized time."""
    if easing == "linear":
        return t
    elif easing == "ease_in":
        return t * t
    elif easing == "ease_out":
        return 1 - (1 - t) ** 2
    elif easing == "ease_in_out":
        if t < 0.5:
            return 2 * t * t
        return 1 - (-2 * t + 2) ** 2 / 2
    return t
```

### Rack Focus Animation
```python
# Source: REQ-CINE-ANIM requirement
def create_rack_focus_animation(
    camera_name: str,
    from_distance: float,
    to_distance: float,
    duration: int = 30,
    start_frame: int = 1,
    easing: str = "ease_in_out"
) -> bool:
    """
    Animate focus distance (rack focus effect).
    """
    if camera_name not in bpy.data.objects:
        return False

    camera = bpy.data.objects[camera_name]
    cam_data = camera.data

    if not cam_data.dof.use_dof:
        cam_data.dof.use_dof = True

    for frame_offset in range(duration + 1):
        t = frame_offset / duration
        t_eased = apply_easing(t, easing)

        focus_dist = from_distance + (to_distance - from_distance) * t_eased
        cam_data.dof.focus_distance = focus_dist
        cam_data.keyframe_insert(data_path='dof.focus_distance',
                                frame=start_frame + frame_offset)

    return True
```

### Push-In Combined Animation (Dolly + Focal Length)
```python
# Source: camera_moves.yaml push_in preset
def create_push_in_animation(
    camera_name: str,
    dolly_distance: float = 0.3,
    focal_from: float = 35.0,
    focal_to: float = 50.0,
    duration: int = 120,
    start_frame: int = 1
) -> bool:
    """
    Combined dolly + focal length change for cinematic push-in.
    This creates the classic "dolly zoom" or "vertigo" effect.
    """
    if camera_name not in bpy.data.objects:
        return False

    camera = bpy.data.objects[camera_name]
    cam_data = camera.data

    # Get initial position
    start_loc = Vector(camera.location)

    # Calculate forward direction (camera's -Z axis)
    forward = -camera.matrix_world.col[2][:3]
    forward.normalize()

    for frame_offset in range(duration + 1):
        t = frame_offset / duration
        t_eased = apply_easing(t, "ease_out")  # Ease out for natural stop

        # Dolly: move camera forward
        movement = forward * dolly_distance * t_eased
        camera.location = (start_loc + movement)[:]
        camera.keyframe_insert(data_path="location", frame=start_frame + frame_offset)

        # Focal length: zoom in
        focal_length = focal_from + (focal_to - focal_from) * t_eased
        cam_data.lens = focal_length
        cam_data.keyframe_insert(data_path="lens", frame=start_frame + frame_offset)

    return True
```

### Bezier Path Generation
```python
# Source: REQ-CINE-PATH requirement
def generate_bezier_path(
    control_points: List[Tuple[float, float, float]],
    duration: int = 120,
    segments: int = 100
) -> List[Tuple[Vector, float]]:
    """
    Generate points along a cubic Bezier curve.

    Returns list of (position, t_value) tuples.
    """
    from mathutils import Vector

    if len(control_points) < 4:
        raise ValueError("Need at least 4 control points for cubic Bezier")

    points = []

    for i in range(segments + 1):
        t = i / segments

        # Cubic Bezier formula
        p0 = Vector(control_points[0])
        p1 = Vector(control_points[1])
        p2 = Vector(control_points[2])
        p3 = Vector(control_points[3])

        # B(t) = (1-t)^3 * P0 + 3(1-t)^2 * t * P1 + 3(1-t) * t^2 * P2 + t^3 * P3
        position = (
            (1 - t) ** 3 * p0 +
            3 * (1 - t) ** 2 * t * p1 +
            3 * (1 - t) * t ** 2 * p2 +
            t ** 3 * p3
        )

        points.append((position, t))

    return points
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual position keyframes | Procedural path generation | Design phase | Reproducible, GSD-compliant |
| Frame-by-frame animation | Eased animations | Design phase | Smooth motion, professional feel |
| Separate object animations | Unified timeline | REQ-CINE-ANIM | Camera/object sync possible |

**Deprecated/outdated:**
- `bpy.ops.anim.keyframe_insert_menu()`: Context-dependent, use direct API
- `bpy.ops.object.parent_set()`: For path following, use Follow Path constraint

## Integration Points

### Existing System Integration

| System | Module | Integration |
|--------|--------|-------------|
| Camera System | camera.py | Animate cameras created by create_camera() |
| Plumb Bob | plumb_bob.py | Use plumb bob position as orbit center |
| Camera Rigs | rigs.py | Animate rig controller objects |
| Preset System | preset_loader.py | Load animation presets from camera_moves.yaml |
| Types | types.py | Add AnimationConfig, MotionPathConfig dataclasses |

### Required New Types (types.py extension)
```python
@dataclass
class AnimationConfig:
    """Animation configuration for shots."""
    enabled: bool = False
    type: str = "static"  # static, orbit, dolly, crane, push_in, turntable, custom
    duration: int = 120
    start_frame: int = 1
    easing: str = "linear"
    loop: bool = False

    # For orbit type
    angle_range: Tuple[float, float] = (0, 360)
    radius: float = 1.0
    axis: str = "Z"

    # For dolly type
    distance: float = 0.5
    direction: str = "forward"

    # For turntable type
    subject_rotation: bool = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "enabled": self.enabled,
            "type": self.type,
            "duration": self.duration,
            "start_frame": self.start_frame,
            "easing": self.easing,
            "loop": self.loop,
            "angle_range": list(self.angle_range),
            "radius": self.radius,
            "axis": self.axis,
            "distance": self.distance,
            "direction": self.direction,
            "subject_rotation": self.subject_rotation,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AnimationConfig":
        return cls(
            enabled=data.get("enabled", False),
            type=data.get("type", "static"),
            duration=data.get("duration", 120),
            start_frame=data.get("start_frame", 1),
            easing=data.get("easing", "linear"),
            loop=data.get("loop", False),
            angle_range=tuple(data.get("angle_range", (0, 360))),
            radius=data.get("radius", 1.0),
            axis=data.get("axis", "Z"),
            distance=data.get("distance", 0.5),
            direction=data.get("direction", "forward"),
            subject_rotation=data.get("subject_rotation", False),
        )


@dataclass
class MotionPathConfig:
    """Motion path configuration for Bezier/spline paths."""
    path_type: str = "linear"  # linear, spline, bezier
    duration: int = 120
    look_at: str = "plumb_bob"  # plumb_bob, manual, object
    interpolation: str = "cubic"

    # Control points for bezier/spline
    points: List[Dict[str, Any]] = field(default_factory=list)

    # For preset usage
    preset: str = ""  # orbit_90, orbit_180, dolly_in, crane_up

    def to_dict(self) -> Dict[str, Any]:
        return {
            "path_type": self.path_type,
            "duration": self.duration,
            "look_at": self.look_at,
            "interpolation": self.interpolation,
            "points": self.points,
            "preset": self.preset,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "MotionPathConfig":
        return cls(
            path_type=data.get("path_type", "linear"),
            duration=data.get("duration", 120),
            look_at=data.get("look_at", "plumb_bob"),
            interpolation=data.get("interpolation", "cubic"),
            points=data.get("points", []),
            preset=data.get("preset", ""),
        )
```

## Audio Sync Implementation Notes

Per REQ-CINE-AUDIO, audio sync is P3 priority. Key points for future implementation:

1. **Beat Marker Support**: Use Blender's timeline markers at specific frames
2. **Audio Analysis**: External library (librosa) for BPM detection, or manual marker placement
3. **Timeline Integration**: Animation keyframes snap to beat markers
4. **Implementation Pattern**:
```python
# Add timeline marker at specific frame
marker = scene.timeline_markers.new("beat_01", frame=24)
marker.frame = 24
```

## Open Questions

1. **Turntable as Separate Module?**
   - What we know: Turntable can be integrated into animation.py or separate
   - What's unclear: Which provides cleaner API
   - Recommendation: Start in animation.py, extract if complexity grows

2. **Animation Blending/Transitions?**
   - What we know: REQ-CINE-ANIM mentions sequence moves (reveal shot)
   - What's unclear: How to handle transitions between animation segments
   - Recommendation: Use NLA tracks for complex sequences, simple concatenation for basic

3. **Path Visualization in Viewport?**
   - What we know: Motion paths help preview camera movement
   - What's unclear: Whether to create visual curve objects
   - Recommendation: Create temporary curve objects with "gsd_temp_" prefix, cleanup on render

## Sources

### Primary (HIGH confidence)
- CINEMATIC_SYSTEM_DESIGN.md - Part 7 Animation System Design, Section 13.11 Motion Path Specification
- REQUIREMENTS_CINEMATIC.md - REQ-CINE-ANIM, REQ-CINE-PATH requirements
- lib/cinematic/types.py - Dataclass patterns to follow
- lib/cinematic/rigs.py - Camera rig system to animate
- configs/cinematic/animation/camera_moves.yaml - Preset definitions (existing)
- configs/cinematic/animation/easing_curves.yaml - Easing function definitions (existing)

### Secondary (MEDIUM confidence)
- Blender Python API documentation patterns (keyframe_insert, f-curves)
- Existing cinematic system module patterns (camera.py, plumb_bob.py)

### Tertiary (LOW confidence)
- Web search results for Blender animation API (verified against official patterns)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Native Blender API, well-documented
- Architecture: HIGH - Design document specifies patterns, existing presets define structure
- Pitfalls: HIGH - Common Blender animation mistakes are well-known
- Audio sync: LOW - P3 priority, external library needed, not immediate

**Research date:** 2026-02-18
**Valid until:** 60 days (Blender API stable across minor versions)
