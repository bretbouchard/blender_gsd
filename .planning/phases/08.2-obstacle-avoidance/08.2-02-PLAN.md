---
phase: 08.2-obstacle-avoidance
plan: 02
type: execute
wave: 2
depends_on:
  - 08.2-01
files_modified:
  - lib/cinematic/follow_cam/collision.py
  - lib/cinematic/follow_cam/prediction.py
autonomous: true

must_haves:
  truths:
    - "Camera has human-like reaction delay before responding to obstacles"
    - "Camera prefers certain angles (horizontal: -45 to 45, vertical: 10 to 30)"
    - "Camera has subtle natural breathing movement"
    - "Avoidance decisions weight visibility > composition > smoothness > distance"
    - "No oscillation or jitter occurs during avoidance"
  artifacts:
    - path: "lib/cinematic/follow_cam/collision.py"
      provides: "Enhanced obstacle avoidance with operator behavior"
      contains: "OperatorBehavior, apply_operator_behavior"
    - path: "lib/cinematic/follow_cam/prediction.py"
      provides: "Enhanced prediction with oscillation prevention"
      contains: "OscillationPreventer"
  key_links:
    - from: "OperatorBehavior"
      to: "calculate_avoidance_position"
      via: "apply_operator_behavior wrapper"
      pattern: "operator_behavior"
---

<objective>
Implement camera "operator" behavior for human-like obstacle avoidance responses.

Purpose: Make camera movement feel like a skilled human operator with natural reactions, preferences, and decision-making rather than robotic instant responses.
Output: Enhanced collision.py and prediction.py with operator behavior and anti-oscillation logic.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS_FOLLOW_CAMERA.md

# Existing code to enhance
@lib/cinematic/follow_cam/types.py
@lib/cinematic/follow_cam/collision.py
@lib/cinematic/follow_cam/prediction.py

# Config files from plan 01
@configs/cinematic/follow_cam/avoidance_presets.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OperatorBehavior dataclass to types.py</name>
  <files>lib/cinematic/follow_cam/types.py</files>
  <action>
Add a new OperatorBehavior dataclass to types.py that encapsulates human-like camera operator behavior.

The dataclass must include:

```python
@dataclass
class OperatorBehavior:
    """
    Configuration for human-like camera operator behavior.

    Simulates skilled camera operator tendencies including:
    - Reaction delay (human response time)
    - Angle preferences (preferred shooting angles)
    - Natural breathing (subtle movement)
    - Decision weights (priority ranking)
    """

    # Human response simulation
    reaction_delay: float = 0.1  # Seconds - human reaction time
    avoid_jerky_motion: bool = True
    min_movement_time: float = 0.3  # Seconds for any adjustment

    # Angle preferences
    horizontal_angle_range: Tuple[float, float] = (-45.0, 45.0)
    vertical_angle_range: Tuple[float, float] = (10.0, 30.0)

    # Natural breathing
    breathing_enabled: bool = True
    breathing_amplitude: float = 0.01  # Meters
    breathing_frequency: float = 0.25  # Hz (breaths per second)

    # Decision weights (must sum to roughly 2.5 for normalization)
    weight_visibility: float = 1.0
    weight_composition: float = 0.7
    weight_smoothness: float = 0.5
    weight_distance: float = 0.3

    # Anti-oscillation
    oscillation_threshold: float = 0.1  # Min distance before response
    position_history_size: int = 10
    max_direction_changes: int = 3  # Per second before damping

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        ...

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> OperatorBehavior:
        """Create from dictionary."""
        ...
```

Also add to FollowCameraConfig:
```python
operator_behavior: OperatorBehavior = field(default_factory=OperatorBehavior)
```

Ensure proper imports (Tuple, Dict, Any, field from dataclasses).
  </action>
  <verify>
    - OperatorBehavior dataclass exists in types.py
    - FollowCameraConfig includes operator_behavior field
    - to_dict and from_dict methods work
    - Module still imports without errors: python -c "from lib.cinematic.follow_cam.types import OperatorBehavior; print('OK')"
  </verify>
  <done>
    OperatorBehavior dataclass added with reaction delay, angle preferences, breathing, decision weights, and anti-oscillation settings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add OscillationPreventer class to prediction.py</name>
  <files>lib/cinematic/follow_cam/prediction.py</files>
  <action>
Add an OscillationPreventer class to prediction.py that prevents camera jitter and oscillation.

The class must:

1. Track position history to detect oscillation patterns
2. Detect rapid direction changes (sign of velocity)
3. Apply damping when oscillation is detected
4. Provide smoothed output that avoids jitter

```python
@dataclass
class OscillationState:
    """Tracks oscillation detection state."""
    position_history: List[Tuple[float, float, float]] = field(default_factory=list)
    direction_change_count: int = 0
    last_direction: float = 0.0
    is_oscillating: bool = False
    damping_factor: float = 1.0


class OscillationPreventer:
    """
    Prevents camera oscillation and jitter.

    Detects rapid back-and-forth movement and applies damping
    to smooth out oscillations while preserving intentional movement.

    Usage:
        preventer = OscillationPreventer(threshold=0.1, max_changes=3)
        preventer.record_position(current_position, current_time)
        smoothed = preventer.get_smoothed_position(target_position)
    """

    def __init__(
        self,
        threshold: float = 0.1,
        max_direction_changes: int = 3,
        history_size: int = 10,
        damping_strength: float = 0.5,
    ):
        self._threshold = threshold
        self._max_changes = max_direction_changes
        self._history_size = history_size
        self._damping_strength = damping_strength
        self._state = OscillationState()

    def record_position(
        self,
        position: Tuple[float, float, float],
        time: float,
    ) -> None:
        """Record position and update oscillation state."""
        ...

    def is_oscillating(self) -> bool:
        """Check if oscillation is currently detected."""
        ...

    def get_smoothed_position(
        self,
        target_position: Tuple[float, float, float],
    ) -> Tuple[float, float, float]:
        """Get smoothed position with damping applied if oscillating."""
        ...

    def get_damping_factor(self) -> float:
        """Get current damping factor (1.0 = no damping, lower = more damping)."""
        ...

    def reset(self) -> None:
        """Reset oscillation state."""
        ...
```

The damping should:
- Reduce movement speed when oscillation detected
- Gradually return to normal when oscillation stops
- Never completely freeze the camera (minimum damping_factor of 0.3)
  </action>
  <verify>
    - OscillationPreventer class exists in prediction.py
    - record_position tracks history and detects direction changes
    - is_oscillating returns True when rapid direction changes detected
    - get_smoothed_position applies damping
    - Module still imports: python -c "from lib.cinematic.follow_cam.prediction import OscillationPreventer; print('OK')"
  </verify>
  <done>
    OscillationPreventer class added with position tracking, direction change detection, and damping.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance collision.py with operator behavior integration</name>
  <files>lib/cinematic/follow_cam/collision.py</files>
  <action>
Enhance collision.py to integrate operator behavior and anti-oscillation.

Add the following:

1. **apply_operator_behavior function**:
```python
def apply_operator_behavior(
    proposed_position: Tuple[float, float, float],
    current_position: Tuple[float, float, float],
    target_position: Tuple[float, float, float],
    operator_behavior: OperatorBehavior,
    delta_time: float,
    oscillation_preventer: Optional[OscillationPreventer] = None,
) -> Tuple[Tuple[float, float, float], Dict[str, Any]]:
    """
    Apply operator behavior to proposed camera position.

    Applies:
    - Reaction delay (deferred response)
    - Angle preference bias
    - Natural breathing
    - Oscillation prevention

    Returns:
        Tuple of (adjusted_position, debug_info)
    """
```

2. **calculate_breathing_offset function**:
```python
def calculate_breathing_offset(
    time: float,
    amplitude: float,
    frequency: float,
) -> Tuple[float, float, float]:
    """
    Calculate subtle breathing movement offset.

    Uses sine wave for smooth, natural breathing motion.
    """
```

3. **apply_angle_preference function**:
```python
def apply_angle_preference(
    position: Tuple[float, float, float],
    target: Tuple[float, float, float],
    preferred_horizontal: Tuple[float, float],
    preferred_vertical: Tuple[float, float],
    bias_strength: float = 0.3,
) -> Tuple[float, float, float]:
    """
    Bias camera position toward preferred angles.

    Gradually nudges camera toward preferred shooting angles
    while still allowing other positions when necessary.
    """
```

4. **Update calculate_avoidance_position** to optionally use operator behavior:
   - Add operator_behavior parameter
   - Add oscillation_preventer parameter
   - Apply operator behavior after calculating avoidance position

5. **Import the new types**:
   - Import OperatorBehavior from types
   - Import OscillationPreventer from prediction

Add these to __init__.py exports as well.
  </action>
  <verify>
    - apply_operator_behavior function exists
    - calculate_breathing_offset produces valid offsets
    - apply_angle_preference biases toward preferred angles
    - calculate_avoidance_position accepts operator_behavior parameter
    - Module imports: python -c "from lib.cinematic.follow_cam.collision import apply_operator_behavior; print('OK')"
  </verify>
  <done>
    collision.py enhanced with operator behavior integration, breathing, angle preferences, and oscillation prevention.
  </done>
</task>

</tasks>

<verification>
1. OperatorBehavior dataclass in types.py
2. OscillationPreventer class in prediction.py
3. apply_operator_behavior function in collision.py
4. All modules import without errors
5. Integration between components works
</verification>

<success_criteria>
- Camera has human-like reaction delay
- Camera prefers specific angle ranges
- Camera has subtle breathing movement
- No oscillation in avoidance responses
- Decision weights influence camera positioning
</success_criteria>

<output>
After completion, create `.planning/phases/08.2-obstacle-avoidance/08.2-02-SUMMARY.md`
</output>
