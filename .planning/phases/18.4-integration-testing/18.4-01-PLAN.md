# Phase 18.4-01: Shot YAML Integration

**Phase**: 18.4 - Integration & Testing
**Requirement**: REQ-PROJ-05
**Priority**: P1
**Est. Effort**: 1 day
**Depends on**: Phases 18.1, 18.2, 18.3

## Goal

Integrate physical projection system with cinematic shot YAML configuration.

## Tasks

### 1. Extend Shot YAML Schema

Add projection support to shot YAML files:

```yaml
# shot.yaml with projection support
name: "Reading Room Projection"
description: "Project content onto reading room surface"

# Camera configuration (standard cinematic)
camera:
  type: projection  # NEW: 'projection' type for physical projector
  projector_profile: "epson_home_cinema_2150"

  # Calibration (NEW section)
  calibration:
    type: three_point  # or four_point_dlt
    points:
      - label: "Bottom Left"
        world_position: [0, 0, 0]
        projector_uv: [0, 0]
      - label: "Bottom Right"
        world_position: [2, 0, 0]
        projector_uv: [1, 0]
      - label: "Top Left"
        world_position: [0, 1.5, 0]
        projector_uv: [0, 1]

  # Target preset (alternative to manual calibration)
  target_preset: "reading_room"  # Load from presets

# Content (NEW section for projection)
content:
  source: "//content/animation.mp4"
  blend_mode: mix  # mix, add, multiply
  intensity: 1.0

# Output (projector-specific settings)
output:
  resolution: [1920, 1080]  # Override projector native
  format: video
  codec: H264
  color_space: sRGB
```

### 2. Create Projection Shot Builder (`lib/cinematic/projection/physical/integration/shot.py`)

```python
from dataclasses import dataclass
from typing import Optional, List, Dict, Any
import bpy

from ..projector import ProjectorProfile, load_profile
from ..calibration import (
    CalibrationPoint,
    CalibrationType,
    SurfaceCalibration,
    CalibrationManager,
)
from ..shaders import ContentMapper
from ..output import ProjectionOutputConfig, ProjectionOutputRenderer
from ..targets import ProjectionTarget, load_target_preset

@dataclass
class ProjectionShotConfig:
    """Configuration for projection shot from YAML."""
    name: str
    description: str = ""

    # Projector configuration
    projector_profile: str = ""
    calibration_type: str = "three_point"
    calibration_points: List[Dict[str, Any]] = field(default_factory=list)
    target_preset: Optional[str] = None

    # Content
    content_source: str = ""
    blend_mode: str = "mix"
    intensity: float = 1.0

    # Output
    resolution: Optional[Tuple[int, int]] = None
    output_format: str = "video"
    output_path: str = "//output/"
    color_space: str = "sRGB"


class ProjectionShotBuilder:
    """Build complete projection setup from YAML configuration."""

    def __init__(self, config: ProjectionShotConfig):
        self.config = config
        self.profile: Optional[ProjectorProfile] = None
        self.calibration: Optional[SurfaceCalibration] = None
        self.projector_camera: Optional[bpy.types.Object] = None
        self.target: Optional[ProjectionTarget] = None

    def load_profile(self) -> 'ProjectionShotBuilder':
        """Load projector profile."""
        self.profile = load_profile(self.config.projector_profile)
        return self

    def setup_calibration(self) -> 'ProjectionShotBuilder':
        """Setup calibration from points or preset."""
        if self.config.target_preset:
            # Load from preset
            self.target = load_target_preset(self.config.target_preset)
            # Extract calibration from target
            # ...

        else:
            # Build from manual points
            cal_type = CalibrationType.THREE_POINT if self.config.calibration_type == "three_point" else CalibrationType.FOUR_POINT_DLT

            points = [
                CalibrationPoint(
                    world_position=tuple(p['world_position']),
                    projector_uv=tuple(p['projector_uv']),
                    label=p.get('label', f"Point {i+1}")
                )
                for i, p in enumerate(self.config.calibration_points)
            ]

            self.calibration = SurfaceCalibration(
                name=f"{self.config.name}_calibration",
                calibration_type=cal_type,
                points=points
            )

        return self

    def create_projector_camera(self) -> 'ProjectionShotBuilder':
        """Create projector camera from profile and calibration."""
        from ..projector import create_projector_camera

        self.projector_camera = create_projector_camera(
            self.profile,
            name=f"{self.config.name}_Projector"
        )

        # Apply calibration transform
        if self.calibration:
            from ..calibration import align_surface
            result = align_surface(self.calibration, self.profile)
            self.projector_camera.matrix_world = result.transform

        return self

    def map_content(self) -> 'ProjectionShotBuilder':
        """Map content to projection surface."""
        if not self.config.content_source:
            return self

        mapper = ContentMapper(self.profile)

        # Get or create target geometry
        if self.target:
            target_obj = self._create_target_geometry()
        else:
            target_obj = self._create_calibration_geometry()

        # Apply content
        self.content_material = mapper.map_content_to_surface(
            content_path=self.config.content_source,
            surface_object=target_obj,
            projector_object=self.projector_camera,
            calibration=self.calibration
        )

        return self

    def configure_output(self) -> 'ProjectionShotBuilder':
        """Configure output settings."""
        resolution = self.config.resolution or self.profile.native_resolution

        self.output_config = ProjectionOutputConfig(
            resolution=resolution,
            format=self.config.output_format,
            color_space=self.config.color_space,
            output_path=self.config.output_path,
        )

        return self

    def build(self) -> 'ProjectionShotBuilder':
        """Execute complete build pipeline."""
        return (self
            .load_profile()
            .setup_calibration()
            .create_projector_camera()
            .map_content()
            .configure_output())

    def render(self, frame_start: int = 1, frame_end: int = 250) -> List[Path]:
        """Render projection output."""
        self.output_config.frame_start = frame_start
        self.output_config.frame_end = frame_end

        renderer = ProjectionOutputRenderer(self.output_config)
        return renderer.render_animation(bpy.context.scene, self.output_config)


def build_projection_shot(yaml_path: str) -> ProjectionShotBuilder:
    """
    Build projection shot from YAML file.

    Example:
        >>> builder = build_projection_shot("shots/reading_room_shot.yaml")
        >>> builder.render(frame_start=1, frame_end=100)
    """
    import yaml

    with open(yaml_path) as f:
        data = yaml.safe_load(f)

    config = ProjectionShotConfig(
        name=data.get('name', 'Projection Shot'),
        description=data.get('description', ''),
        projector_profile=data.get('camera', {}).get('projector_profile', ''),
        calibration_type=data.get('camera', {}).get('calibration', {}).get('type', 'three_point'),
        calibration_points=data.get('camera', {}).get('calibration', {}).get('points', []),
        target_preset=data.get('camera', {}).get('target_preset'),
        content_source=data.get('content', {}).get('source', ''),
        blend_mode=data.get('content', {}).get('blend_mode', 'mix'),
        intensity=data.get('content', {}).get('intensity', 1.0),
        resolution=tuple(data.get('output', {}).get('resolution', [])) or None,
        output_format=data.get('output', {}).get('format', 'video'),
        output_path=data.get('output', {}).get('output_path', '//output/'),
        color_space=data.get('output', {}).get('color_space', 'sRGB'),
    )

    builder = ProjectionShotBuilder(config)
    return builder.build()
```

### 3. Create Integration Test (`tests/integration/test_projection_shot.py`)

```python
import pytest
import tempfile
from pathlib import Path

class TestProjectionShotIntegration:
    """Integration tests for projection shot building."""

    def test_simple_projection_shot(self, tmp_path):
        """Test building a simple projection shot."""
        # Create test YAML
        yaml_content = """
name: Test Projection
description: Simple test shot

camera:
  type: projection
  projector_profile: epson_home_cinema_2150
  calibration:
    type: three_point
    points:
      - label: Bottom Left
        world_position: [0, 0, 0]
        projector_uv: [0, 0]
      - label: Bottom Right
        world_position: [1, 0, 0]
        projector_uv: [1, 0]
      - label: Top Left
        world_position: [0, 1, 0]
        projector_uv: [0, 1]

content:
  source: tests/fixtures/test_pattern.png
  blend_mode: mix
  intensity: 1.0

output:
  format: image_sequence
  output_path: {output_path}
"""
        yaml_path = tmp_path / "test_shot.yaml"
        yaml_path.write_text(yaml_content.format(output_path=str(tmp_path) + "/"))

        # Build shot
        from lib.cinematic.projection.physical.integration import build_projection_shot

        builder = build_projection_shot(str(yaml_path))

        # Verify
        assert builder.profile is not None
        assert builder.calibration is not None
        assert builder.projector_camera is not None

    def test_projection_shot_with_target_preset(self, tmp_path):
        """Test building projection shot with target preset."""
        yaml_content = """
name: Garage Door Projection
camera:
  type: projection
  projector_profile: benq_tk700sti
  target_preset: garage_door

content:
  source: tests/fixtures/test_content.png

output:
  format: video
"""
        yaml_path = tmp_path / "garage_shot.yaml"
        yaml_path.write_text(yaml_content)

        builder = build_projection_shot(str(yaml_path))

        assert builder.target is not None
        assert builder.target.name == "garage_door"

    def test_render_projection_shot(self, tmp_path):
        """Test rendering a projection shot."""
        # Create minimal test shot
        yaml_content = """
name: Render Test
camera:
  type: projection
  projector_profile: epson_home_cinema_2150
  calibration:
    type: three_point
    points:
      - world_position: [0, 0, 0]
        projector_uv: [0, 0]
      - world_position: [1, 0, 0]
        projector_uv: [1, 0]
      - world_position: [0, 1, 0]
        projector_uv: [0, 1]

output:
  format: image_sequence
  output_path: {output_path}
"""
        yaml_path = tmp_path / "render_test.yaml"
        yaml_path.write_text(yaml_content.format(output_path=str(tmp_path) + "/"))

        builder = build_projection_shot(str(yaml_path))

        # Render single frame
        output_files = builder.render(frame_start=1, frame_end=1)

        assert len(output_files) == 1
        assert output_files[0].exists()
```

## Deliverables

```
lib/cinematic/projection/physical/integration/
├── __init__.py
└── shot.py               # ProjectionShotBuilder, build_projection_shot

tests/integration/
└── test_projection_shot.py
```

## Acceptance Criteria

- [ ] Shot YAML schema supports projection configuration
- [ ] ProjectionShotBuilder builds complete setup from YAML
- [ ] build_projection_shot() convenience function works
- [ ] Integration tests pass
- [ ] 10+ integration tests passing
