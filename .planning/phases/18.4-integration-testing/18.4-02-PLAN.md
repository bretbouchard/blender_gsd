# Phase 18.4-02: End-to-End Tests & Documentation

**Phase**: 18.4 - Integration & Testing
**Requirement**: REQ-PROJ-05
**Priority**: P1
**Est. Effort**: 1.5 days
**Depends on**: 18.4-01 (Shot YAML Integration)

## Goal

Create comprehensive end-to-end tests and document the complete projection mapping workflow.

## Tasks

### 1. Create E2E Test Suite (`tests/e2e/test_projection_mapping.py`)

```python
import pytest
import bpy
import tempfile
from pathlib import Path

class TestProjectionMappingE2E:
    """End-to-end tests for physical projection mapping."""

    def test_complete_workflow_simple(self, tmp_path):
        """Test complete workflow from profile to render."""
        from lib.cinematic.projection.physical import (
            load_profile,
            CalibrationPoint,
            CalibrationType,
            SurfaceCalibration,
            ContentMappingWorkflow,
            ProjectionOutputConfig,
        )

        # 1. Load projector profile
        profile = load_profile("epson_home_cinema_2150")
        assert profile is not None

        # 2. Create calibration
        calibration = SurfaceCalibration(
            name="test_calibration",
            calibration_type=CalibrationType.THREE_POINT,
            points=[
                CalibrationPoint((0, 0, 0), (0, 1), "BL"),
                CalibrationPoint((0.5, 0, 0), (0.5, 1), "BR"),
                CalibrationPoint((0, 0.5, 0), (0, 0.5, 1), "TL"),
            ]
        )

        # 3. Create workflow
        workflow = ContentMappingWorkflow(
            name="test_workflow",
            projector_profile=profile,
            calibration=calibration
        )

        # 4. Execute workflow
        workflow.setup()
        workflow.calibrate()
        workflow.create_proxy()

        # 5. Verify results
        assert workflow.projector_camera is not None
        assert workflow.proxy_geometry is not None

    def test_render_output_matches_resolution(self, tmp_path):
        """Test that output matches projector native resolution."""
        from lib.cinematic.projection.physical import (
            load_profile,
            CalibrationPoint,
            CalibrationType,
            SurfaceCalibration,
            render_for_projector,
        )

        profile = load_profile("epson_home_cinema_2150")

        # Create test content
        test_image = self._create_test_image(tmp_path)

        # Render for projector
        output_files = render_for_projector(
            content_path=str(test_image),
            projector_profile_name="epson_home_cinema_2150",
            calibration_points=[
                ((0, 0, 0), (0, 0)),
                ((1, 0, 0), (1, 0)),
                ((0, 1, 0), (0, 1)),
            ],
            output_dir=str(tmp_path) + "/output/"
        )

        # Verify resolution matches profile
        expected_resolution = profile.native_resolution
        for output_file in output_files:
            # Check image dimensions
            import PIL.Image as Image
            with Image.open(output_file) as img:
                assert img.size == expected_resolution

    def test_calibration_accuracy(self):
        """Test that calibration produces accurate alignment."""
        from lib.cinematic.projection.physical import (
            load_profile,
            CalibrationPoint,
            CalibrationType,
            SurfaceCalibration,
            align_surface,
        )

        profile = load_profile("benq_tk700sti")

        # Create perfect calibration (known transform)
        calibration = SurfaceCalibration(
            name="perfect_calibration",
            calibration_type=CalibrationType.THREE_POINT,
            points=[
                CalibrationPoint((0, 0, 0), (0, 0), "BL"),
                CalibrationPoint((2, 0, 0), (1, 0), "BR"),
                CalibrationPoint((1, 1, 0), (0.5, 0.5), "Center"),  # Center point
            ]
        )

        result = align_surface(calibration, profile)

        # Error should be very low for perfect calibration
        assert result.error < 0.001  # Less than 1mm error

    def _create_test_image(self, tmp_path) -> Path:
        """Create a simple test pattern image."""
        from PIL import Image

        img = Image.new('RGB', (1920, 1080), color='white')
        # Draw checkerboard
        for y in range(0, 1080, 135):
            for x in range(0, 1920, 240):
                for dy in range(135):
                    for dx in range(240):
                        if (x // 240 + y // 135) % 2 == 0:
                            img.putpixel((x + dx, y + dy), (255, 255, 255))
                        else:
                            img.putpixel((x + dx, y + dy), (0, 0, 0))

        path = Path(tmp_path) / "test_pattern.png"
        img.save(path)
        return path
```

### 2. Create Documentation (`docs/PROJECTION_MAPPING.md`)

```markdown
# Physical Projection Mapping

## Overview

The Physical Projection Mapping system enables you to map Blender content to real-world projection surfaces with accurate calibration.

## Quick Start

    ### 1. Basic Setup
    ```python
    from lib.cinematic.projection.physical import (
        load_profile,
        CalibrationPoint,
        CalibrationType,
        render_for_projector,
    )

    # Load projector profile
    profile = load_profile("epson_home_cinema_2150")

    # Define calibration points (3-point for planar surface)
    calibration_points = [
        ((0, 0, 0), (0, 0)),       # Bottom-left: world position, projector UV
        ((2, 0, 0), (1, 0)),       # Bottom-right
        ((0, 1.5, 0), (0, 1)),     # Top-left
    ]

    # Render for projector
    output_files = render_for_projector(
        content_path="//content/animation.mp4",
        projector_profile_name="epson_home_cinema_2150",
        calibration_points=calibration_points,
        output_dir="//projector_output/"
    )
    ```

    ### 2. Using Target Presets
    ```python
    from lib.cinematic.projection.physical import (
        load_target_preset,
        ContentMappingWorkflow,
    )

    # Load reading room preset
    target = load_target_preset("reading_room")

    # Create workflow
    workflow = ContentMappingWorkflow(
        name="reading_room_projection",
        projector_profile=load_profile("epson_home_cinema_2150"),
        calibration=target.calibration,
    )

    # Execute
    workflow.setup().calibrate().create_proxy().map_content("//content/video.mp4")
    workflow.render("//output/reading_room/")
    ```

    ### 3. Shot YAML Integration
    ```yaml
    # shot.yaml
    name: "Reading Room Projection"
    camera:
      type: projection
      projector_profile: epson_home_cinema_2150
      target_preset: reading_room

    content:
      source: //content/animation.mp4
    output:
      format: video
      output_path: //output/reading_room/
    ```

## Calibration

    ### 3-Point Alignment (Planar Surfaces)
    For flat surfaces like walls, screens, garage doors:
    - Point 1: Bottom-left corner
    - Point 2: Bottom-right corner
    - Point 3: Top-left corner

    ### 4-Point DLT (Non-Planar/Multi-Surface)
    For complex surfaces like reading rooms with cabinets:
    - Point 1-4: Four corners of projection area
    - Solves full projection matrix
    - Works with irregular surfaces

## Supported Projectors

    | Manufacturer | Model | Resolution | Throw Ratio |
    |-------------|-------|-----------|-------------|
    | Epson | Home Cinema 2150 | 1920x1080 | 1.32 |
    | Epson | Pro EX10000 | 1920x1200 | 1.0 |
    | BenQ | TK700STi | 3840x2160 | 1.13 |
    | BenQ | MH560 | 1920x1080 | 1.5 |
    | Optoma | UHD38 | 3840x2160 | 1.2 |
    | Sony | VPL-FHZ66 | 1920x1080 | 1.0 |

## API Reference

    See `docs/API_PROJECTION.md` for complete API documentation.
```

### 3. Create Final Package Exports Update (`lib/cinematic/projection/physical/__init__.py`)

Add Phase 18.1-18.4 exports to main physical package.

### 4. Create VERIFICATION.md (`lib/cinematic/projection/physical/VERIFICATION.md`)

```markdown
# Phase 18 Verification

## Phase 18.0: Projector Profile System
- [x] 12 projector profiles in database
- [x] throw_ratio_to_focal_length formula correct
- [x] create_projector_camera works
- [x] 77 tests passing (69 unit + 8 integration)

## Phase 18.1: Surface Calibration
- [ ] CalibrationPoint, SurfaceCalibration types
- [ ] 3-point alignment algorithm
- [ ] 4-point DLT alignment algorithm
- [ ] Calibration patterns generate correctly
- [ ] 60+ tests passing

## Phase 18.2: Content Mapping Workflow
- [ ] Projection shader nodes
- [ ] Proxy geometry generation
- [ ] Output renderer at native resolution
- [ ] 60+ tests passing

## Phase 18.3: Target Presets
- [ ] ReadingRoom, GarageDoor, BuildingFacade presets
- [ ] TargetBuilder classes
- [ ] Target preview visualization
- [ ] 35+ tests passing

## Phase 18.4: Integration & Testing
- [ ] Shot YAML integration
- [ ] E2E tests pass
- [ ] Documentation complete
- [ ] 30+ tests passing

## Total: 260+ tests for Phase 18
```

## Deliverables

```
lib/cinematic/projection/physical/
├── integration/
│   ├── __init__.py
│   └── shot.py           # ProjectionShotBuilder
├── VERIFICATION.md

tests/e2e/
└── test_projection_mapping.py

docs/
└── PROJECTION_MAPPING.md
```

## Tests

- E2E tests for complete workflow
- Calibration accuracy tests
- Resolution matching tests

## Acceptance Criteria

- [ ] E2E test suite passes
- [ ] Documentation complete
- [ ] VERIFICATION.md created
- [ ] Phase 18 complete with 260+ total tests
- [ ] Ready for production use
