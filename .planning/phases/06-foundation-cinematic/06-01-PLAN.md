---
phase: 06-foundation-cinematic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/__init__.py
  - lib/cinematic/types.py
  - lib/cinematic/enums.py
  - lib/cinematic/state_manager.py
autonomous: true

must_haves:
  truths:
    - "Cinematic module can be imported without errors"
    - "All core dataclasses (ShotState, CameraConfig, Transform3D, LightConfig, BackdropConfig, RenderSettings) are available"
    - "State can be serialized to YAML and deserialized back"
    - "Frame versioning works with max_versions cleanup"
  artifacts:
    - path: "lib/cinematic/__init__.py"
      provides: "Package exports and version"
      exports: ["ShotState", "CameraConfig", "Transform3D", "StateManager", "FrameStore"]
      min_lines: 50
    - path: "lib/cinematic/types.py"
      provides: "Core dataclass definitions"
      contains: "@dataclass"
    - path: "lib/cinematic/enums.py"
      provides: "Type-safe enumerations"
      contains: "class LensType(Enum)"
    - path: "lib/cinematic/state_manager.py"
      provides: "State persistence with YAML"
      contains: "class StateManager"
  key_links:
    - from: "lib/cinematic/__init__.py"
      to: "lib/cinematic/types.py"
      via: "from .types import"
      pattern: "from \.types import"
    - from: "lib/cinematic/state_manager.py"
      to: "lib/cinematic/types.py"
      via: "imports ShotState, CameraConfig"
      pattern: "from \.types import ShotState"
---

<objective>
Create the lib/cinematic/ Python package with core types, enums, and state persistence.

Purpose: Establish the foundational module structure that all subsequent cinematic phases will build upon. This package provides type-safe configuration dataclasses, enumerations for categorical values, and state persistence for resumable workflows.

Output: A fully functional Python package with 4 modules that can be imported without errors.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/bretbouchard/apps/blender_gsd/.planning/ROADMAP.md
@/Users/bretbouchard/apps/blender_gsd/.planning/phases/06-foundation-cinematic/06-RESEARCH.md

# Reference existing patterns
@/Users/bretbouchard/apps/blender_gsd/lib/control_system/profiles.py
@/Users/bretbouchard/apps/blender_gsd/lib/control_system/parameters.py
@/Users/bretbouchard/apps/blender_gsd/lib/gsd_io.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types.py with core dataclasses</name>
  <files>lib/cinematic/types.py</files>
  <action>
Create `lib/cinematic/types.py` with the following dataclasses. Follow the pattern from `lib/control_system/profiles.py` for dataclass structure.

Required dataclasses:

1. **Transform3D** - 3D transform with position, rotation, scale
   - position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
   - rotation: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # Euler degrees
   - scale: Tuple[float, float, float] = (1.0, 1.0, 1.0)
   - Method: to_blender() -> Dict for Blender-compatible format

2. **CameraConfig** - Complete camera configuration
   - name: str = "hero_camera"
   - focal_length: float = 50.0  # mm
   - focus_distance: float = 1.0  # meters (0 = auto)
   - sensor_width: float = 36.0  # mm
   - sensor_height: float = 24.0  # mm
   - f_stop: float = 4.0
   - aperture_blades: int = 9
   - transform: Transform3D = field(default_factory=Transform3D)
   - Method: to_params() -> Dict for parameter dictionary

3. **LightConfig** - Light configuration
   - name: str = "key_light"
   - light_type: str = "area"  # area, spot, point, sun
   - intensity: float = 1000.0  # watts
   - color: Tuple[float, float, float] = (1.0, 1.0, 1.0)
   - transform: Transform3D = field(default_factory=Transform3D)

4. **BackdropConfig** - Backdrop configuration
   - backdrop_type: str = "infinite_curve"  # infinite_curve, gradient, hdri, mesh
   - color_bottom: Tuple[float, float, float] = (0.95, 0.95, 0.95)
   - color_top: Tuple[float, float, float] = (1.0, 1.0, 1.0)
   - radius: float = 5.0
   - shadow_catcher: bool = True

5. **RenderSettings** - Render configuration
   - engine: str = "CYCLES"  # CYCLES, BLENDER_EEVEE_NEXT, BLENDER_WORKBENCH
   - resolution_x: int = 2048
   - resolution_y: int = 2048
   - samples: int = 64
   - quality_tier: str = "cycles_preview"

6. **ShotState** - Complete shot state for persistence (THE KEY CLASS)
   - shot_name: str
   - version: int = 1
   - timestamp: str = ""
   - camera: CameraConfig = field(default_factory=CameraConfig)
   - lights: Dict[str, Dict[str, Any]] = field(default_factory=dict)
   - backdrop: Dict[str, Any] = field(default_factory=dict)
   - render_settings: Dict[str, Any] = field(default_factory=dict)
   - Method: to_yaml_dict() -> Dict for YAML serialization
   - Class method: from_yaml_dict(data) -> ShotState for deserialization

CRITICAL: Use `field(default_factory=...)` for all mutable defaults (dicts, lists, nested dataclasses). This prevents shared state bugs.

Imports needed:
```python
from __future__ import annotations
from dataclasses import dataclass, field, asdict
from typing import Dict, Any, Optional, Tuple, List
```
  </action>
  <verify>
```bash
# Verify types.py can be imported and all classes exist
python3 -c "
from lib.cinematic.types import (
    Transform3D, CameraConfig, LightConfig,
    BackdropConfig, RenderSettings, ShotState
)
print('All 6 dataclasses imported successfully')

# Test instantiation
t = Transform3D(position=(1, 2, 3))
c = CameraConfig(name='test', transform=t)
s = ShotState(shot_name='test_shot', camera=c)
print(f'ShotState created: {s.shot_name}')

# Test YAML dict conversion
d = s.to_yaml_dict()
s2 = ShotState.from_yaml_dict(d)
print(f'Roundtrip: {s2.shot_name}')
"
```
  </verify>
  <done>All 6 dataclasses importable, ShotState can serialize/deserialize via to_yaml_dict/from_yaml_dict</done>
</task>

<task type="auto">
  <name>Task 2: Create enums.py with type-safe enumerations</name>
  <files>lib/cinematic/enums.py</files>
  <action>
Create `lib/cinematic/enums.py` with all enum types needed by the cinematic system.

Required enums:

1. **LensType** - Lens focal length presets
   - WIDE_14MM = "14mm_ultra_wide"
   - WIDE_24MM = "24mm_wide"
   - NORMAL_35MM = "35mm_documentary"
   - NORMAL_50MM = "50mm_normal"
   - PORTRAIT_85MM = "85mm_portrait"
   - TELEPHOTO_135MM = "135mm_telephoto"
   - MACRO_90MM = "90mm_macro"

2. **LightType** - Light types
   - AREA = "area"
   - SPOT = "spot"
   - POINT = "point"
   - SUN = "sun"

3. **QualityTier** - Render quality tiers
   - VIEWPORT_CAPTURE = "viewport_capture"
   - EEVEE_DRAFT = "eevee_draft"
   - CYCLES_PREVIEW = "cycles_preview"
   - CYCLES_PRODUCTION = "cycles_production"
   - CYCLES_ARCHIVE = "cycles_archive"

4. **ColorSpace** - Color space options
   - SRGB = "srgb"
   - AGX = "AgX"
   - ACESCG = "ACEScg"
   - FILMIC = "Filmic"

5. **EasingType** - Animation easing functions
   - LINEAR = "linear"
   - EASE_IN = "ease_in"
   - EASE_OUT = "ease_out"
   - EASE_IN_OUT = "ease_in_out"

Follow the pattern from `lib/control_system/profiles.py` where `KnobProfileType` enum is defined.
  </action>
  <verify>
```bash
# Verify all enums exist with correct values
python3 -c "
from lib.cinematic.enums import LensType, LightType, QualityTier, ColorSpace, EasingType

# Test enum values
assert LensType.PORTRAIT_85MM.value == '85mm_portrait'
assert LightType.AREA.value == 'area'
assert QualityTier.CYCLES_PRODUCTION.value == 'cycles_production'
assert ColorSpace.AGX.value == 'AgX'
assert EasingType.EASE_IN_OUT.value == 'ease_in_out'

print('All 5 enums validated successfully')
print(f'Lens types: {len(LensType)} values')
print(f'Quality tiers: {len(QualityTier)} values')
"
```
  </verify>
  <done>All 5 enums defined with correct values, importable without errors</done>
</task>

<task type="auto">
  <name>Task 3: Create state_manager.py with StateManager and FrameStore</name>
  <files>lib/cinematic/state_manager.py</files>
  <action>
Create `lib/cinematic/state_manager.py` with two classes for state persistence.

Follow the pattern from `lib/gsd_io.py` for YAML/JSON handling with fallback.

**StateManager class:**
- `__init__(self, state_root: Optional[Path] = None)` - Initialize with `.gsd-state/cinematic` default
- `save(self, state: ShotState, path: Path) -> None` - Save state to YAML file
  - Set timestamp on state before saving
  - Create parent directories if needed
  - Use yaml.dump with default_flow_style=False, sort_keys=False
  - Fall back to JSON if PyYAML not available
- `load(self, path: Path) -> ShotState` - Load state from YAML file
  - Use yaml.safe_load
  - Reconstruct nested dataclasses via ShotState.from_yaml_dict()
- `capture_current(self, shot_name: str) -> ShotState` - Capture current Blender state
  - Check bpy.context.scene exists before access
  - Get active camera from scene.camera
  - Build CameraConfig with Transform3D from camera object
- `restore(self, state: ShotState) -> None` - Restore Blender to captured state
  - Find or create camera object
  - Apply settings and transform
  - Set as scene.camera
- `diff(self, state_a: ShotState, state_b: ShotState) -> Dict` - Compare two states

**FrameStore class:**
- `__init__(self, base_path: Path, max_versions: int = 50)` - Initialize with path and max frames
- `save_frame(self, shot_name: str, state: ShotState) -> int` - Save as new frame, return frame number
  - Create shot directory if needed
  - Find next frame number (001, 002, etc.)
  - Save to frames/{shot_name}/{num:03d}/state.yaml
  - Call cleanup after save
- `load_frame(self, shot_name: str, frame_num: int) -> ShotState` - Load frame by number
- `list_frames(self, shot_name: str) -> List[int]` - List available frame numbers
- `cleanup_old_frames(self) -> int` - Public method to cleanup all shots (matches design doc Part 13.16)
  - Iterates all shot directories in frames/
  - Returns total frames deleted across all shots
- `_cleanup_shot_frames(self, shot_dir: Path) -> int` - Internal method to cleanup a single shot's frames

CRITICAL:
- Guard all bpy.context access with try/except or hasattr checks
- Use Path objects throughout, create parent directories with `mkdir(parents=True, exist_ok=True)`
- Handle PyYAML import gracefully with fallback to JSON
  </action>
  <verify>
```bash
# Verify state_manager works without Blender context
python3 -c "
import tempfile
from pathlib import Path
from lib.cinematic.state_manager import StateManager, FrameStore
from lib.cinematic.types import ShotState, CameraConfig

# Test StateManager save/load
with tempfile.TemporaryDirectory() as tmpdir:
    sm = StateManager(Path(tmpdir))
    state = ShotState(shot_name='test_shot', camera=CameraConfig(name='cam'))

    # Save and load
    path = Path(tmpdir) / 'test.yaml'
    sm.save(state, path)
    loaded = sm.load(path)

    assert loaded.shot_name == 'test_shot'
    assert loaded.camera.name == 'cam'
    assert loaded.timestamp != ''  # Auto-set on save
    print('StateManager save/load OK')

    # Test FrameStore
    fs = FrameStore(Path(tmpdir), max_versions=3)
    frame_num = fs.save_frame('test_shot', state)
    print(f'Frame saved: {frame_num:03d}')

    loaded_frame = fs.load_frame('test_shot', frame_num)
    assert loaded_frame.shot_name == 'test_shot'
    print('FrameStore save/load OK')

    frames = fs.list_frames('test_shot')
    assert len(frames) == 1
    print(f'FrameStore list_frames: {frames}')
"
```
  </verify>
  <done>StateManager can save/load ShotState to YAML, FrameStore can manage versioned frames with cleanup</done>
</task>

<task type="auto">
  <name>Task 4: Create __init__.py with package exports</name>
  <files>lib/cinematic/__init__.py</files>
  <action>
Create `lib/cinematic/__init__.py` that exports all public types.

Follow the pattern from research document Section "Package Initialization Pattern".

Content:
```python
"""
Cinematic Rendering System Package

A comprehensive system for cinematic camera, lighting, and rendering.

Modules:
- types: Core data structures (ShotState, CameraConfig, etc.)
- enums: Type-safe enumerations
- state_manager: State persistence

Quick Start:
    from lib.cinematic import (
        ShotState, CameraConfig, Transform3D,
        StateManager, FrameStore
    )

    # Create camera config
    camera = CameraConfig(
        name="hero_camera",
        focal_length=85.0,
        f_stop=4.0
    )

    # Create shot state
    state = ShotState(
        shot_name="hero_knob_01",
        camera=camera
    )

    # Save state
    manager = StateManager()
    manager.save(state, Path(".gsd-state/cinematic/sessions/hero.yaml"))
"""

from .types import (
    Transform3D,
    CameraConfig,
    LightConfig,
    BackdropConfig,
    RenderSettings,
    ShotState,
)
from .enums import (
    LensType,
    LightType,
    QualityTier,
    ColorSpace,
    EasingType,
)
from .state_manager import (
    StateManager,
    FrameStore,
)

__all__ = [
    # Core types
    "Transform3D",
    "CameraConfig",
    "LightConfig",
    "BackdropConfig",
    "RenderSettings",
    "ShotState",

    # Enums
    "LensType",
    "LightType",
    "QualityTier",
    "ColorSpace",
    "EasingType",

    # State management
    "StateManager",
    "FrameStore",
]

__version__ = "0.1.0"
```

CRITICAL: Only import leaf modules (types, enums) to avoid circular imports. Do NOT import camera.py, lighting.py etc. from __init__.py - those will be added in future phases.
  </action>
  <verify>
```bash
# Test 1: Import all types
python3 -c "from lib.cinematic.types import ShotState, CameraConfig, Transform3D, LightConfig, BackdropConfig, RenderSettings; print('Types OK')"

# Test 2: Import all enums
python3 -c "from lib.cinematic.enums import LensType, LightType, QualityTier, ColorSpace, EasingType; print('Enums OK')"

# Test 3: Import state manager
python3 -c "from lib.cinematic.state_manager import StateManager, FrameStore; print('State Manager OK')"

# Test 4: Full package import with __all__
python3 -c "from lib.cinematic import *; print(f'Full import OK - {len(__all__)} exports')"

# Test 5: Version check
python3 -c "import lib.cinematic; print(f'Version: {lib.cinematic.__version__}')"
```
  </verify>
  <done>Package imports all 14 exports, docstring present, __version__ = "0.1.0"</done>
</task>

</tasks>

<verification>
Verify the cinematic module is fully functional:

```bash
# Run all import tests
python3 -c "
# Test all imports
from lib.cinematic import (
    Transform3D, CameraConfig, LightConfig, BackdropConfig, RenderSettings, ShotState,
    LensType, LightType, QualityTier, ColorSpace, EasingType,
    StateManager, FrameStore
)

# Create sample objects
t = Transform3D(position=(0.5, -0.5, 0.3))
c = CameraConfig(name='hero_camera', focal_length=85.0, transform=t)
s = ShotState(shot_name='test', camera=c)

# Test serialization
d = s.to_yaml_dict()
s2 = ShotState.from_yaml_dict(d)
assert s2.camera.focal_length == 85.0

print('All 14 exports verified')
print(f'CameraConfig: {c.name}, focal_length={c.focal_length}')
print(f'ShotState: {s.shot_name}, camera={s.camera.name}')
"
```
</verification>

<success_criteria>
- lib/cinematic/ directory exists with 4 Python files
- All 6 dataclasses in types.py are importable and functional
- All 5 enums in enums.py are defined with correct values
- StateManager can save/load ShotState to YAML files
- FrameStore can manage versioned frames with cleanup
- Package __init__.py exports all 14 types via __all__
- No circular import errors when importing the package
- __version__ = "0.1.0" is defined
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation-cinematic/06-01-SUMMARY.md`
</output>
