# Phase 20.0-01: Quetzalcoatl Foundation

**Phase**: 20.0 - Quetzalcoatl Foundation
**Project**: Quetzalcoatl Feathered Serpent Generator
**Priority**: P1
**Est. Effort**: 1 day
**Depends on**: None

## Goal

Establish project structure, configuration system, and prove spine curve generation for the Quetzalcoatl procedural creature system.

## Background

From ARCHITECTURE.md, the Quetzalcoatl system follows the Universal Stage Order:
1. **STAGE 0: NORMALIZE** - Validate parameters, convert to canonical ranges
2. **STAGE 1: PRIMARY** - Spine curve, body cross-sections, head placement
3. **STAGE 2: SECONDARY** - Eye sockets, nostrils, limb geometry
4. **STAGE 3: DETAIL** - Scales, feathers, teeth, whiskers, colors
5. **STAGE 4: OUTPUT PREP** - UV mapping, rigging, export

This phase establishes the foundation with types, configuration, and spine curve prototype.

## Tasks

### 1. Create Types Module (`projects/quetzalcoatl/lib/types.py`)

```python
from dataclasses import dataclass, field
from typing import Tuple, List, Optional, Dict, Any
from enum import Enum

class WingType(Enum):
    NONE = "none"
    FEATHERED = "feathered"
    MEMBRANE = "membrane"

class ScaleShape(Enum):
    ROUND = "round"
    OVAL = "oval"
    HEXAGONAL = "hexagonal"
    DIAMOND = "diamond"

class TailType(Enum):
    POINTED = "pointed"
    FEATHER_TUFT = "feather_tuft"
    RATTLE = "rattle"
    FAN = "fan"

class CrestType(Enum):
    NONE = "none"
    RIDGE = "ridge"
    FRILL = "frill"
    HORNS = "horns"

@dataclass
class SpineConfig:
    """Spine curve configuration."""
    length: float = 10.0  # 1-100 meters
    segments: int = 64
    taper_head: float = 0.3
    taper_tail: float = 0.2
    wave_amplitude: float = 0.5
    wave_frequency: int = 3

@dataclass
class BodyConfig:
    """Body volume configuration."""
    radius: float = 0.5  # 0.1-5 meters
    compression: float = 0.8  # lateral/vertical ratio
    dorsal_flat: float = 0.0  # 0=circular, 1=flat

@dataclass
class LimbConfig:
    """Limb configuration."""
    leg_pairs: int = 2  # 0-4
    leg_positions: List[float] = field(default_factory=lambda: [0.3, 0.6])
    leg_length: float = 1.0
    leg_girth: float = 0.15
    toe_count: int = 4
    claw_length: float = 0.1

@dataclass
class WingConfig:
    """Wing configuration."""
    wing_type: WingType = WingType.NONE
    wing_span: float = 3.0
    wing_arm_length: float = 1.5
    finger_count: int = 4  # for membrane wings
    feather_layers: int = 3  # for feathered wings

@dataclass
class ScaleConfig:
    """Scale layer configuration."""
    size: float = 0.05
    shape: ScaleShape = ScaleShape.OVAL
    overlap: float = 0.3
    density: float = 1.0
    variation: float = 0.2

@dataclass
class FeatherConfig:
    """Feather layer configuration."""
    length: float = 0.3
    width: float = 0.02
    barb_density: int = 20
    iridescence: float = 0.5
    layer_count: int = 3

@dataclass
class HeadConfig:
    """Head configuration."""
    snout_length: float = 0.8
    snout_profile: float = 0.5
    jaw_depth: float = 0.3
    crest_type: CrestType = CrestType.NONE
    crest_size: float = 0.5

@dataclass
class ColorConfig:
    """Color system configuration."""
    base_color: Tuple[float, float, float] = (0.1, 0.3, 0.2)
    accent_color: Tuple[float, float, float] = (0.8, 0.6, 0.2)
    iridescent_colors: List[Tuple[float, float, float]] = field(
        default_factory=lambda: [(0.0, 0.8, 0.6), (0.8, 0.2, 0.8), (0.2, 0.4, 0.9)]
    )
    translucency: float = 0.3

@dataclass
class QuetzalcoatlConfig:
    """Complete creature configuration."""
    name: str = "Quetzalcoatl"
    seed: int = 42

    spine: SpineConfig = field(default_factory=SpineConfig)
    body: BodyConfig = field(default_factory=BodyConfig)
    limbs: LimbConfig = field(default_factory=LimbConfig)
    wings: WingConfig = field(default_factory=WingConfig)
    scales: ScaleConfig = field(default_factory=ScaleConfig)
    feathers: FeatherConfig = field(default_factory=FeatherConfig)
    head: HeadConfig = field(default_factory=HeadConfig)
    colors: ColorConfig = field(default_factory=ColorConfig)

    def validate(self) -> List[str]:
        """Validate configuration, return list of errors."""
        errors = []

        if not 1.0 <= self.spine.length <= 100.0:
            errors.append(f"spine.length must be 1-100, got {self.spine.length}")

        if not 0 <= self.limbs.leg_pairs <= 4:
            errors.append(f"limbs.leg_pairs must be 0-4, got {self.limbs.leg_pairs}")

        if len(self.limbs.leg_positions) < self.limbs.leg_pairs:
            errors.append(f"Need {self.limbs.leg_pairs} leg_positions, got {len(self.limbs.leg_positions)}")

        return errors
```

### 2. Create Configuration Loader (`projects/quetzalcoatl/lib/config.py`)

```python
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
from .types import QuetzalcoatlConfig

class ConfigLoader:
    """Load and manage creature configurations."""

    def __init__(self, config_dir: Optional[Path] = None):
        self.config_dir = config_dir or Path(__file__).parent.parent / "configs"
        self._preset_cache: Dict[str, QuetzalcoatlConfig] = {}

    def load_yaml(self, path: Path) -> QuetzalcoatlConfig:
        """Load configuration from YAML file."""
        with open(path) as f:
            data = yaml.safe_load(f)
        return self._dict_to_config(data)

    def load_preset(self, name: str) -> QuetzalcoatlConfig:
        """Load a named preset configuration."""
        if name in self._preset_cache:
            return self._preset_cache[name]

        preset_path = self.config_dir / "presets" / f"{name}.yaml"
        if not preset_path.exists():
            raise FileNotFoundError(f"Preset not found: {name}")

        config = self.load_yaml(preset_path)
        self._preset_cache[name] = config
        return config

    def list_presets(self) -> Dict[str, str]:
        """List available presets with descriptions."""
        presets_dir = self.config_dir / "presets"
        if not presets_dir.exists():
            return {}

        presets = {}
        for path in presets_dir.glob("*.yaml"):
            try:
                with open(path) as f:
                    data = yaml.safe_load(f)
                presets[path.stem] = data.get("description", "")
            except Exception:
                presets[path.stem] = "(error loading)"

        return presets

    def _dict_to_config(self, data: Dict[str, Any]) -> QuetzalcoatlConfig:
        """Convert dictionary to config dataclass."""
        # Implementation converts nested dicts to nested dataclasses
        pass
```

### 3. Create Spine Generator (`projects/quetzalcoatl/lib/spine.py`)

```python
import numpy as np
from typing import Tuple, List, Optional
from dataclasses import dataclass

from .types import SpineConfig

@dataclass
class SpineResult:
    """Result of spine generation."""
    points: np.ndarray  # (N, 3) array of spine points
    tangents: np.ndarray  # (N, 3) tangent vectors
    normals: np.ndarray  # (N, 3) normal vectors
    radii: np.ndarray  # (N,) radius at each point
    spine_positions: np.ndarray  # (N,) normalized position 0-1

class SpineGenerator:
    """Generate procedural spine curves."""

    def __init__(self, config: SpineConfig, seed: Optional[int] = None):
        self.config = config
        self.rng = np.random.default_rng(seed)

    def generate(self) -> SpineResult:
        """Generate spine curve with attributes."""
        n = self.config.segments
        length = self.config.length

        # Create base line along X axis
        t = np.linspace(0, 1, n)
        x = t * length

        # Apply wave deformation
        wave_amp = self.config.wave_amplitude
        wave_freq = self.config.wave_frequency
        y = wave_amp * np.sin(2 * np.pi * wave_freq * t)

        # Z variation for 3D wave
        z = wave_amp * 0.3 * np.cos(2 * np.pi * wave_freq * t + np.pi/4)

        # Combine into points
        points = np.column_stack([x, y, z])

        # Calculate tangents (derivatives)
        tangents = self._calculate_tangents(points)

        # Calculate normals (perpendicular to tangents)
        normals = self._calculate_normals(points, tangents)

        # Calculate radii with taper
        radii = self._calculate_radii(t)

        return SpineResult(
            points=points,
            tangents=tangents,
            normals=normals,
            radii=radii,
            spine_positions=t
        )

    def _calculate_tangents(self, points: np.ndarray) -> np.ndarray:
        """Calculate tangent vectors via finite differences."""
        n = len(points)
        tangents = np.zeros_like(points)

        # Central difference for interior points
        tangents[1:-1] = points[2:] - points[:-2]

        # Forward/backward difference for endpoints
        tangents[0] = points[1] - points[0]
        tangents[-1] = points[-1] - points[-2]

        # Normalize
        lengths = np.linalg.norm(tangents, axis=1, keepdims=True)
        tangents = tangents / np.maximum(lengths, 1e-8)

        return tangents

    def _calculate_normals(self, points: np.ndarray, tangents: np.ndarray) -> np.ndarray:
        """Calculate normal vectors perpendicular to tangents."""
        # Use up vector (Z) to create perpendicular
        up = np.array([0, 0, 1])
        normals = np.cross(tangents, up)

        # Normalize
        lengths = np.linalg.norm(normals, axis=1, keepdims=True)
        normals = normals / np.maximum(lengths, 1e-8)

        return normals

    def _calculate_radii(self, t: np.ndarray) -> np.ndarray:
        """Calculate radius along spine with head/tail taper."""
        base_radius = 1.0  # Normalized, will be scaled by body config

        # Head taper (first 20% of spine)
        head_mask = t < 0.2
        head_taper = np.ones_like(t)
        head_taper[head_mask] = t[head_mask] / 0.2
        head_taper = np.clip(head_taper * self.config.taper_head, 0.1, 1.0)

        # Tail taper (last 30% of spine)
        tail_mask = t > 0.7
        tail_taper = np.ones_like(t)
        tail_taper[tail_mask] = (1 - t[tail_mask]) / 0.3
        tail_taper = np.clip(tail_taper * self.config.taper_tail, 0.05, 1.0)

        return base_radius * np.minimum(head_taper, tail_taper)
```

### 4. Create Base Configuration YAML (`projects/quetzalcoatl/configs/base_creature.yaml`)

```yaml
name: Quetzalcoatl
description: Default feathered serpent configuration
seed: 42

spine:
  length: 10.0
  segments: 64
  taper_head: 0.3
  taper_tail: 0.2
  wave_amplitude: 0.5
  wave_frequency: 3

body:
  radius: 0.5
  compression: 0.8
  dorsal_flat: 0.0

limbs:
  leg_pairs: 2
  leg_positions: [0.3, 0.6]
  leg_length: 1.0
  leg_girth: 0.15
  toe_count: 4
  claw_length: 0.1

wings:
  wing_type: none
  wing_span: 3.0
  wing_arm_length: 1.5
  finger_count: 4
  feather_layers: 3

scales:
  size: 0.05
  shape: oval
  overlap: 0.3
  density: 1.0
  variation: 0.2

feathers:
  length: 0.3
  width: 0.02
  barb_density: 20
  iridescence: 0.5
  layer_count: 3

head:
  snout_length: 0.8
  snout_profile: 0.5
  jaw_depth: 0.3
  crest_type: none
  crest_size: 0.5

colors:
  base_color: [0.1, 0.3, 0.2]
  accent_color: [0.8, 0.6, 0.2]
  iridescent_colors:
    - [0.0, 0.8, 0.6]
    - [0.8, 0.2, 0.8]
    - [0.2, 0.4, 0.9]
  translucency: 0.3
```

### 5. Create Preset Configurations

**`configs/presets/serpent.yaml`:**
```yaml
name: Serpent
description: Legless serpent with no wings
extends: base_creature

limbs:
  leg_pairs: 0
  leg_positions: []

wings:
  wing_type: none
```

**`configs/presets/dragon.yaml`:**
```yaml
name: Dragon
description: Four-legged dragon with feathered wings
extends: base_creature

limbs:
  leg_pairs: 2
  leg_positions: [0.25, 0.55]

wings:
  wing_type: feathered
  wing_span: 5.0
  feather_layers: 4

head:
  crest_type: horns
  crest_size: 0.8
```

### 6. Create Package Init (`projects/quetzalcoatl/lib/__init__.py`)

```python
"""
Quetzalcoatl - Procedural Feathered Serpent Generator

A procedural creature generation system following the Universal Stage Order.
"""

from .types import (
    WingType,
    ScaleShape,
    TailType,
    CrestType,
    SpineConfig,
    BodyConfig,
    LimbConfig,
    WingConfig,
    ScaleConfig,
    FeatherConfig,
    HeadConfig,
    ColorConfig,
    QuetzalcoatlConfig,
)
from .config import ConfigLoader
from .spine import SpineGenerator, SpineResult

__all__ = [
    # Enums
    "WingType",
    "ScaleShape",
    "TailType",
    "CrestType",
    # Configs
    "SpineConfig",
    "BodyConfig",
    "LimbConfig",
    "WingConfig",
    "ScaleConfig",
    "FeatherConfig",
    "HeadConfig",
    "ColorConfig",
    "QuetzalcoatlConfig",
    # Loader
    "ConfigLoader",
    # Spine
    "SpineGenerator",
    "SpineResult",
]

__version__ = "0.1.0"
```

### 7. Create Unit Tests (`tests/unit/test_quetzalcoatl_foundation.py`)

```python
import pytest
import numpy as np
from pathlib import Path

# Tests for types, config loader, and spine generator
# ~30 tests covering:
# - Config validation
# - YAML loading
# - Spine generation
# - Tangent/normal calculation
# - Taper profile
# - Determinism (seed)
```

## Acceptance Criteria

- [ ] `projects/quetzalcoatl/lib/` structure created
- [ ] Types module with all config dataclasses
- [ ] ConfigLoader can load YAML configurations
- [ ] SpineGenerator produces valid spine curves
- [ ] Spine has proper tangents, normals, radii
- [ ] Generation is deterministic with seed
- [ ] 30+ unit tests passing
- [ ] 4 preset configurations (base, serpent, dragon, wyvern)

## File Structure After Completion

```
projects/quetzalcoatl/
├── REQUIREMENTS.md
├── ARCHITECTURE.md
├── lib/
│   ├── __init__.py
│   ├── types.py
│   ├── config.py
│   └── spine.py
├── configs/
│   ├── base_creature.yaml
│   └── presets/
│       ├── serpent.yaml
│       ├── dragon.yaml
│       ├── wyvern.yaml
│       └── ghost.yaml
├── assets/
├── inputs/
├── output/
└── scripts/

tests/unit/
└── test_quetzalcoatl_foundation.py
```
