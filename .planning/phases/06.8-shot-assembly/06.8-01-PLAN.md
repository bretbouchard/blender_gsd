---
phase: 06.8-shot-assembly
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cinematic/types.py
  - lib/cinematic/preset_loader.py
autonomous: true

must_haves:
  truths:
    - "ShotTemplateConfig supports extends/override pattern"
    - "CompleteShotConfig can be built from template hierarchy"
    - "Abstract templates cannot be rendered directly"
  artifacts:
    - path: "lib/cinematic/types.py"
      provides: "Extended CompleteShotConfig with template support"
      contains: "extends"
    - path: "lib/cinematic/preset_loader.py"
      provides: "Shot template loading with inheritance resolution"
      exports: ["get_shot_template", "list_shot_templates", "resolve_template_inheritance"]
  key_links:
    - from: "lib/cinematic/preset_loader.py"
      to: "configs/cinematic/shots/"
      via: "load_preset()"
      pattern: "SHOT_CONFIG_ROOT"
---

<objective>
Add shot template types and template loader functions with inheritance resolution.

Purpose: Provide complete shot template system with extends/override pattern for REQ-CINE-TEMPLATE.
Output: Extended CompleteShotConfig with template support, template loader with inheritance resolution.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow
@lib/cinematic/types.py
@lib/cinematic/preset_loader.py

# Requirements
@.planning/REQUIREMENTS_CINEMATIC.md (REQ-CINE-TEMPLATE, REQ-CINE-SHOT)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ShotTemplateConfig to types.py</name>
  <files>lib/cinematic/types.py</files>
  <action>
Add a new `ShotTemplateConfig` dataclass after `CompleteShotConfig` (around line 1585).

```python
@dataclass
class ShotTemplateConfig:
    """
    Shot template configuration with inheritance support (REQ-CINE-TEMPLATE).

    Templates can extend other templates using the 'extends' field.
    Abstract templates cannot be rendered directly.

    Attributes:
        name: Template name (unique identifier)
        extends: Parent template name for inheritance (empty = base template)
        abstract: If True, template cannot be rendered directly
        description: Human-readable description
        camera: Camera configuration overrides
        plumb_bob: Plumb bob configuration overrides
        rig: Camera rig configuration overrides
        lighting_rig: Lighting rig preset name
        lights: Custom light configurations
        backdrop: Backdrop configuration overrides
        environment_preset: Environment/HDRI preset name
        imperfections: Lens imperfection configuration
        animation: Animation configuration
        render: Render settings overrides
        color: Color management overrides
        composition: Composition rules overrides
        subject_name: Default subject object name
    """
    name: str = ""
    extends: str = ""  # Parent template name
    abstract: bool = False  # Cannot render directly if True
    description: str = ""
    # All other fields optional - override parent values
    camera: Optional[CameraConfig] = None
    plumb_bob: Optional[PlumbBobConfig] = None
    rig: Optional[RigConfig] = None
    lighting_rig: str = ""
    lights: Dict[str, LightConfig] = field(default_factory=dict)
    backdrop: Optional[BackdropConfig] = None
    environment_preset: str = ""
    imperfections: Optional[ImperfectionConfig] = None
    animation: Optional[AnimationConfig] = None
    render: Optional[CinematicRenderSettings] = None
    color: Optional[ColorConfig] = None
    composition: Optional[CompositionConfig] = None
    subject_name: str = ""

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "name": self.name,
            "extends": self.extends,
            "abstract": self.abstract,
            "description": self.description,
            "camera": self.camera.to_dict() if self.camera else None,
            "plumb_bob": self.plumb_bob.to_dict() if self.plumb_bob else None,
            "rig": self.rig.to_dict() if self.rig else None,
            "lighting_rig": self.lighting_rig,
            "lights": {k: v.to_dict() for k, v in self.lights.items()},
            "backdrop": self.backdrop.to_dict() if self.backdrop else None,
            "environment_preset": self.environment_preset,
            "imperfections": self.imperfections.to_dict() if self.imperfections else None,
            "animation": self.animation.to_dict() if self.animation else None,
            "render": self.render.to_dict() if self.render else None,
            "color": self.color.to_dict() if self.color else None,
            "composition": self.composition.to_dict() if self.composition else None,
            "subject_name": self.subject_name,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ShotTemplateConfig":
        """Create from dictionary."""
        lights_data = data.get("lights", {})
        lights = {k: LightConfig.from_dict(v) for k, v in lights_data.items()}

        return cls(
            name=data.get("name", ""),
            extends=data.get("extends", ""),
            abstract=data.get("abstract", False),
            description=data.get("description", ""),
            camera=CameraConfig.from_dict(data["camera"]) if data.get("camera") else None,
            plumb_bob=PlumbBobConfig.from_dict(data["plumb_bob"]) if data.get("plumb_bob") else None,
            rig=RigConfig.from_dict(data["rig"]) if data.get("rig") else None,
            lighting_rig=data.get("lighting_rig", ""),
            lights=lights,
            backdrop=BackdropConfig.from_dict(data["backdrop"]) if data.get("backdrop") else None,
            environment_preset=data.get("environment_preset", ""),
            imperfections=ImperfectionConfig.from_dict(data["imperfections"]) if data.get("imperfections") else None,
            animation=AnimationConfig.from_dict(data["animation"]) if data.get("animation") else None,
            render=CinematicRenderSettings.from_dict(data["render"]) if data.get("render") else None,
            color=ColorConfig.from_dict(data["color"]) if data.get("color") else None,
            composition=CompositionConfig.from_dict(data["composition"]) if data.get("composition") else None,
            subject_name=data.get("subject_name", ""),
        )
```

Also add a `ShotAssemblyConfig` dataclass for complete shot assembly:

```python
@dataclass
class ShotAssemblyConfig:
    """
    Complete shot assembly configuration (REQ-CINE-SHOT).

    Brings together all elements for a single shot:
    - Template reference (with inheritance resolution)
    - Subject specification
    - Camera configuration
    - Lighting configuration
    - Backdrop configuration
    - Color/render settings
    - Animation (optional)

    Supports resume/edit workflow via frame store integration.

    Attributes:
        name: Shot name (used for output files)
        template: Template name to use as base
        subject: Subject object name or specification
        camera: Camera config (overrides template)
        lighting_rig: Lighting rig preset name
        lights: Custom lights (overrides template)
        backdrop: Backdrop config (overrides template)
        color: Color management config
        render: Render settings
        animation: Animation config (optional)
        output_path: Output directory for renders
        metadata: Additional metadata
    """
    name: str = "shot_01"
    template: str = ""  # Template to use
    subject: str = ""  # Subject object name
    camera: Optional[CameraConfig] = None
    plumb_bob: Optional[PlumbBobConfig] = None
    lighting_rig: str = ""
    lights: Dict[str, LightConfig] = field(default_factory=dict)
    backdrop: Optional[BackdropConfig] = None
    color: Optional[ColorConfig] = None
    render: Optional[CinematicRenderSettings] = None
    animation: Optional[AnimationConfig] = None
    output_path: str = "//render/"
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "name": self.name,
            "template": self.template,
            "subject": self.subject,
            "camera": self.camera.to_dict() if self.camera else None,
            "plumb_bob": self.plumb_bob.to_dict() if self.plumb_bob else None,
            "lighting_rig": self.lighting_rig,
            "lights": {k: v.to_dict() for k, v in self.lights.items()},
            "backdrop": self.backdrop.to_dict() if self.backdrop else None,
            "color": self.color.to_dict() if self.color else None,
            "render": self.render.to_dict() if self.render else None,
            "animation": self.animation.to_dict() if self.animation else None,
            "output_path": self.output_path,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ShotAssemblyConfig":
        """Create from dictionary."""
        lights_data = data.get("lights", {})
        lights = {k: LightConfig.from_dict(v) for k, v in lights_data.items()}

        return cls(
            name=data.get("name", "shot_01"),
            template=data.get("template", ""),
            subject=data.get("subject", ""),
            camera=CameraConfig.from_dict(data["camera"]) if data.get("camera") else None,
            plumb_bob=PlumbBobConfig.from_dict(data["plumb_bob"]) if data.get("plumb_bob") else None,
            lighting_rig=data.get("lighting_rig", ""),
            lights=lights,
            backdrop=BackdropConfig.from_dict(data["backdrop"]) if data.get("backdrop") else None,
            color=ColorConfig.from_dict(data["color"]) if data.get("color") else None,
            render=CinematicRenderSettings.from_dict(data["render"]) if data.get("render") else None,
            animation=AnimationConfig.from_dict(data["animation"]) if data.get("animation") else None,
            output_path=data.get("output_path", "//render/"),
            metadata=data.get("metadata", {}),
        )
```
  </action>
  <verify>python3 -c "
from lib.cinematic.types import ShotTemplateConfig, ShotAssemblyConfig

# Test ShotTemplateConfig
t = ShotTemplateConfig(name='test', extends='base_template')
assert t.name == 'test', 'name failed'
assert t.extends == 'base_template', 'extends failed'
assert t.abstract == False, 'abstract default failed'

# Test ShotAssemblyConfig
a = ShotAssemblyConfig(name='my_shot', template='studio_white', subject='product')
assert a.name == 'my_shot', 'name failed'
assert a.template == 'studio_white', 'template failed'
assert a.subject == 'product', 'subject failed'

# Test round-trip
data = t.to_dict()
t2 = ShotTemplateConfig.from_dict(data)
assert t2.name == t.name, 'round-trip failed'

print('ShotTemplateConfig and ShotAssemblyConfig OK')
"</verify>
  <done>ShotTemplateConfig and ShotAssemblyConfig dataclasses with serialization</done>
</task>

<task type="auto">
  <name>Task 2: Add shot template loaders to preset_loader.py</name>
  <files>lib/cinematic/preset_loader.py</files>
  <action>
Add shot template loader functions following the exact pattern of existing loaders.

First, add constants near the top (after existing CONFIG_ROOT constants):

```python
# Shot template configuration
SHOT_CONFIG_ROOT = Path("configs/cinematic/shots")
```

Then add these loader functions:

1. `get_shot_template(name: str) -> Dict[str, Any]`
   - Load from SHOT_CONFIG_ROOT / "templates.yaml"
   - Access 'templates' key in YAML
   - Raise ValueError if not found

2. `resolve_template_inheritance(template_name: str, loaded_templates: Optional[Dict] = None) -> Dict[str, Any]`
   - Recursively resolve 'extends' chain
   - Merge parent values, child overrides parent
   - Detect circular inheritance
   - Raise ValueError if abstract template attempted

3. `list_shot_templates(include_abstract: bool = False) -> List[str]`
   - List all templates from templates.yaml
   - Optionally exclude abstract templates

4. `get_shot_assembly(name: str) -> Dict[str, Any]`
   - Load shot assembly from SHOT_CONFIG_ROOT / "assemblies.yaml"
   - Access 'assemblies' key

5. `list_shot_assemblies() -> List[str]`
   - List all shot assemblies

Pattern to follow:
```python
def get_shot_template(name: str) -> Dict[str, Any]:
    \"\"\"Load a shot template by name.\"\"\"
    path = SHOT_CONFIG_ROOT / "templates.yaml"
    if not path.exists():
        raise FileNotFoundError(f"Shot templates file not found: {path}")

    with open(path, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    templates = data.get("templates", {})
    if name not in templates:
        available = list(templates.keys())
        raise ValueError(f"Shot template '{name}' not found. Available: {available}")

    return templates[name]


def resolve_template_inheritance(
    template_name: str,
    loaded_templates: Optional[Dict[str, Any]] = None,
    _chain: Optional[List[str]] = None
) -> Dict[str, Any]:
    \"\"\"
    Resolve template inheritance chain, merging parent into child.

    Args:
        template_name: Template to resolve
        loaded_templates: Cache of already loaded templates
        _chain: Internal - tracks inheritance chain for circular detection

    Returns:
        Fully resolved template dictionary with all inherited values

    Raises:
        ValueError: If circular inheritance detected or abstract template used directly
    \"\"\"
    if loaded_templates is None:
        loaded_templates = {}
    if _chain is None:
        _chain = []

    # Circular inheritance detection
    if template_name in _chain:
        raise ValueError(f"Circular template inheritance detected: {' -> '.join(_chain + [template_name])}")

    _chain.append(template_name)

    # Load template
    if template_name not in loaded_templates:
        loaded_templates[template_name] = get_shot_template(template_name)

    template = loaded_templates[template_name].copy()

    # Check abstract
    if template.get("abstract", False) and len(_chain) == 1:
        raise ValueError(f"Cannot use abstract template '{template_name}' directly")

    # If no parent, return as-is
    parent_name = template.get("extends", "")
    if not parent_name:
        return template

    # Resolve parent recursively
    parent = resolve_template_inheritance(parent_name, loaded_templates, _chain)

    # Merge: parent as base, child overrides
    merged = parent.copy()
    for key, value in template.items():
        if key == "extends":
            continue
        if value is not None:
            # Deep merge for dicts
            if isinstance(value, dict) and key in merged and isinstance(merged[key], dict):
                merged[key] = {**merged[key], **value}
            else:
                merged[key] = value

    return merged
```
  </action>
  <verify>python3 -c "
# This test verifies the loader structure - actual templates may not exist yet
from lib.cinematic.preset_loader import SHOT_CONFIG_ROOT, resolve_template_inheritance
print('Shot template loader constants OK')
"</verify>
  <done>Shot template loader functions with inheritance resolution</done>
</task>

</tasks>

<verification>
1. ShotTemplateConfig and ShotAssemblyConfig can be instantiated
2. Both support to_dict/from_dict round-trip
3. Template loader functions exist
4. resolve_template_inheritance handles extends chain
</verification>

<success_criteria>
- ShotTemplateConfig with extends/abstract fields
- ShotAssemblyConfig with template reference
- get_shot_template(), list_shot_templates() functions
- resolve_template_inheritance() merges parent/child correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06.8-shot-assembly/06.8-01-SUMMARY.md`
</output>
