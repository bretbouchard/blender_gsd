# Phase 13.2: Dither Engine

**Phase**: 13.2
**Priority**: P0
**Dependencies**: Phase 13.1 (Pixel Converter)
**Est. Duration**: 3-4 days

---

## Goal

Implement professional dithering algorithms for color-limited output, enabling smooth gradients with limited palettes.

---

## Requirements

- REQ-RETRO-02: Ordered dithering (Bayer matrices)
- REQ-RETRO-02: Error diffusion dithering
- REQ-RETRO-02: Custom pattern support
- REQ-RETRO-02: Adjustable strength

---

## Plans

### Plan 13.2-01: Dither Types

**Deliverable**: `lib/retro/dither_types.py`

```python
@dataclass
class DitherConfig:
    """Dithering configuration."""
    mode: str = "none"  # none, ordered_2x2, ordered_4x4, bayer_8x8, error_diffusion, atkinson, sierra, checkerboard
    strength: float = 1.0  # 0.0 - 1.0
    color_space: str = "rgb"  # rgb, lab, luma

    # For error diffusion
    serpentine: bool = True  # Alternate direction each row

    # For ordered dither
    matrix_size: int = 4  # 2, 4, 8

    # Custom pattern
    custom_pattern: Optional[List[List[float]]] = None

@dataclass
class DitherMatrix:
    """Dither threshold matrix."""
    size: int
    matrix: List[List[float]]

    @classmethod
    def bayer(cls, size: int) -> "DitherMatrix":
        """Generate Bayer matrix."""
        pass

    @classmethod
    def from_image(cls, path: str) -> "DitherMatrix":
        """Load custom matrix from image."""
        pass
```

**Tasks**:
1. Create DitherConfig dataclass
2. Create DitherMatrix dataclass
3. Add matrix generation methods
4. Add validation

---

### Plan 13.2-02: Ordered Dithering

**Deliverable**: `lib/retro/dither_ordered.py`

```python
# Bayer matrices
BAYER_2X2 = [
    [0, 2],
    [3, 1]
]

BAYER_4X4 = [
    [ 0,  8,  2, 10],
    [12,  4, 14,  6],
    [ 3, 11,  1,  9],
    [15,  7, 13,  5]
]

def generate_bayer_matrix(size: int) -> List[List[int]]:
    """Generate Bayer matrix of any size (power of 2)."""
    pass

def ordered_dither(image: Any, matrix: DitherMatrix, levels: int, strength: float = 1.0) -> Any:
    """Apply ordered dithering."""
    pass

def bayer_dither(image: Any, size: int = 4, levels: int = 2, strength: float = 1.0) -> Any:
    """Apply Bayer dithering."""
    pass

def checkerboard_dither(image: Any, levels: int = 2) -> Any:
    """Apply checkerboard dithering."""
    pass

def halftone_dither(image: Any, dot_size: int = 2, angle: float = 45) -> Any:
    """Apply halftone pattern dithering."""
    pass
```

**Tasks**:
1. Implement Bayer matrix generation
2. Implement ordered dither algorithm
3. Implement Bayer dither convenience function
4. Implement checkerboard dither
5. Implement halftone (bonus)
6. Test with various images

---

### Plan 13.2-03: Error Diffusion Dithering

**Deliverable**: `lib/retro/dither_error.py`

```python
# Error diffusion kernels
FLOYD_STEINBERG = {
    "name": "Floyd-Steinberg",
    "kernel": [
        (1, 0, 7/16),
        (-1, 1, 3/16),
        (0, 1, 5/16),
        (1, 1, 1/16)
    ]
}

ATKINSON = {
    "name": "Atkinson (Macintosh)",
    "kernel": [
        (1, 0, 1/8),
        (2, 0, 1/8),
        (-1, 1, 1/8),
        (0, 1, 1/8),
        (1, 1, 1/8),
        (0, 2, 1/8)
    ]
}

SIERRA_LITE = {
    "name": "Sierra Lite",
    "kernel": [
        (1, 0, 2/4),
        (-1, 1, 1/4),
        (0, 1, 1/4)
    ]
}

JARVIS_JUDICE_NINKE = {
    "name": "Jarvis-Judice-Ninke",
    "kernel": [
        (1, 0, 7/48), (2, 0, 5/48),
        (-2, 1, 3/48), (-1, 1, 5/48), (0, 1, 7/48), (1, 1, 5/48), (2, 1, 3/48),
        (-2, 2, 1/48), (-1, 2, 3/48), (0, 2, 5/48), (1, 2, 3/48), (2, 2, 1/48)
    ]
}

def error_diffusion_dither(image: Any, kernel: Dict, palette: List[Tuple], serpentine: bool = True) -> Any:
    """Apply error diffusion dithering."""
    pass

def floyd_steinberg_dither(image: Any, palette: List[Tuple]) -> Any:
    """Apply Floyd-Steinberg dithering."""
    pass

def atkinson_dither(image: Any, palette: List[Tuple]) -> Any:
    """Apply Atkinson dithering (Macintosh style)."""
    pass

def sierra_dither(image: Any, palette: List[Tuple]) -> Any:
    """Apply Sierra Lite dithering."""
    pass

def find_nearest_color(color: Tuple, palette: List[Tuple]) -> Tuple:
    """Find nearest color in palette."""
    pass
```

**Tasks**:
1. Implement error diffusion algorithm
2. Implement Floyd-Steinberg
3. Implement Atkinson
4. Implement Sierra Lite
5. Implement Jarvis-Judice-Ninke (bonus)
6. Implement nearest color matching
7. Test with limited palettes

---

### Plan 13.2-04: Pattern Dithering

**Deliverable**: `lib/retro/dither_patterns.py`

```python
# Pre-defined patterns
PATTERNS = {
    "diagonal_lines": [...],
    "horizontal_lines": [...],
    "vertical_lines": [...],
    "crosshatch": [...],
    "dots": [...],
    "circles": [...],
}

def pattern_dither(image: Any, pattern: str, threshold: float = 0.5) -> Any:
    """Apply pattern-based dithering."""
    pass

def custom_pattern_dither(image: Any, pattern_image: Any, threshold: float = 0.5) -> Any:
    """Apply custom pattern dithering."""
    pass

def tile_pattern(pattern: List[List], width: int, height: int) -> List[List]:
    """Tile pattern to image size."""
    pass
```

**Tasks**:
1. Define pattern matrices
2. Implement pattern tiling
3. Implement pattern dithering
4. Implement custom pattern support
5. Test with various patterns

---

### Plan 13.2-05: Integration & Presets

**Deliverable**: `lib/retro/dither.py` (main module)

```python
def dither(image: Any, config: DitherConfig, palette: List[Tuple] = None) -> Any:
    """
    Main dithering function.

    Args:
        image: Input image (PIL Image or numpy array)
        config: Dither configuration
        palette: Target color palette (optional, auto-generated if None)

    Returns:
        Dithered image
    """
    if config.mode == "none":
        return image
    elif config.mode.startswith("ordered") or config.mode.startswith("bayer"):
        return ordered_dither(image, ...)
    elif config.mode == "error_diffusion":
        return floyd_steinberg_dither(image, palette)
    elif config.mode == "atkinson":
        return atkinson_dither(image, palette)
    # ... etc
```

**Deliverable**: `configs/cinematic/retro/dither_presets.yaml`

```yaml
presets:
  # Classic Macintosh
  macintosh_1bit:
    mode: "atkinson"
    strength: 1.0

  # SNES style
  snes_gradient:
    mode: "bayer_4x4"
    strength: 0.7

  # NES style
  nes_dither:
    mode: "checkerboard"
    strength: 1.0

  # Newspaper print
  newspaper:
    mode: "bayer_8x8"
    strength: 1.0

  # Smooth modern
  modern_smooth:
    mode: "error_diffusion"
    strength: 0.8
```

**Tasks**:
1. Create main dither() function
2. Create preset file
3. Implement preset loader
4. Test all modes
5. Update __init__.py

---

## Acceptance Criteria

- [ ] Bayer matrices generate correctly (2x2, 4x4, 8x8)
- [ ] Ordered dithering produces clean patterns
- [ ] Floyd-Steinberg produces smooth gradients
- [ ] Atkinson produces Mac-style output
- [ ] Custom patterns work
- [ ] Strength control affects output
- [ ] Presets load correctly

---

## Files

```
lib/retro/
├── dither_types.py        # Data structures
├── dither_ordered.py      # Bayer, ordered dither
├── dither_error.py        # Error diffusion
├── dither_patterns.py     # Pattern-based
└── dither.py              # Main module

configs/cinematic/retro/
├── dither_presets.yaml    # Dither presets
└── patterns/
    ├── bayer_4x4.png
    ├── bayer_8x8.png
    └── custom/
```
