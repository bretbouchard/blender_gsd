# Phase 6.6: Render System - Research

**Researched:** 2026-02-18
**Domain:** Blender bpy API for render settings, render passes, quality tiers, EXR output
**Confidence:** HIGH

## Summary

This research covers the Blender Python API for configuring render settings, enabling render passes, managing quality tier presets, and configuring EXR output with metadata. The project already has partial infrastructure in place (YAML configs for quality profiles and pass presets) that can be leveraged. The implementation will extend the existing `lib/exports.py` patterns and create a new `lib/cinematic/render.py` module following the established dataclass and preset loader patterns.

**Primary recommendation:** Create `lib/cinematic/render.py` with quality tier application, render pass configuration, and EXR output handling. Use the existing YAML configs in `configs/cinematic/render/` as the source of truth for presets.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| bpy | Blender 5.x | Render API | Official Blender Python API |
| bpy.context.scene.render | N/A | Render settings | Primary render configuration |
| bpy.context.scene.cycles | N/A | Cycles settings | Cycles-specific options |
| bpy.context.view_layer | N/A | Render passes | Pass enablement via use_pass_* |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| PyYAML | 6.x | Config loading | Already used in preset_loader.py |
| dataclasses | stdlib | Type-safe configs | Following types.py pattern |
| pathlib | stdlib | File paths | Project standard |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| YAML configs | JSON configs | YAML is more readable, already established |
| Custom render presets | Blender render presets | Project-specific needs not covered by defaults |
| Manual pass enabling | Pass presets | Presets encapsulate common workflows |

**Installation:**
```bash
# No additional installation needed - uses existing project dependencies
# Ensure PyYAML is available (already in preset_loader.py requirements)
```

## Architecture Patterns

### Recommended Project Structure
```
lib/cinematic/
├── render.py              # NEW: Render profile system
│   ├── RenderProfile class
│   ├── apply_quality_tier()
│   ├── configure_render_passes()
│   ├── configure_exr_output()
│   └── select_denoiser()
│
configs/cinematic/render/
├── quality_profiles.yaml  # EXISTS: Quality tier definitions
├── pass_presets.yaml      # EXISTS: Pass groupings and API mappings
```

### Pattern 1: Quality Tier Application
**What:** Apply render settings from quality_profiles.yaml preset
**When to use:** Setting up render for any quality level (viewport, draft, production, archive)
**Example:**
```python
# Source: configs/cinematic/render/quality_profiles.yaml + bpy API docs
import bpy

# Engine identifiers for Blender 5.x (CRITICAL: Use BLENDER_EEVEE_NEXT, not BLENDER_EEVEE)
ENGINES = {
    'CYCLES': 'CYCLES',
    'EEVEE_NEXT': 'BLENDER_EEVEE_NEXT',  # NOT 'BLENDER_EEVEE' (deprecated)
    'WORKBENCH': 'BLENDER_WORKBENCH'
}

def apply_quality_tier(profile_name: str) -> bool:
    """
    Apply render quality tier from quality_profiles.yaml.

    Supports: viewport_capture, eevee_draft, cycles_preview,
              cycles_production, cycles_archive
    """
    scene = bpy.context.scene

    # Load preset
    profile = get_quality_profile(profile_name)  # From preset_loader

    # Set engine
    engine_id = ENGINES.get(profile['engine'])
    if engine_id:
        scene.render.engine = engine_id

    # Set resolution
    resolution = profile.get('resolution', {})
    base = resolution.get('base', 2048)
    scale = resolution.get('scale', 100)
    scene.render.resolution_x = base
    scene.render.resolution_y = base
    scene.render.resolution_percentage = scale

    # Set samples (Cycles only)
    if profile['engine'] == 'CYCLES':
        scene.cycles.samples = profile.get('samples', 64)

        # Adaptive sampling
        adaptive = profile.get('adaptive_sampling', {})
        if adaptive.get('enabled', False):
            scene.cycles.use_adaptive_sampling = True
            scene.cycles.adaptive_threshold = adaptive.get('threshold', 0.01)
            scene.cycles.adaptive_min_samples = adaptive.get('min_samples', 8)

    # Denoiser (per denoiser_settings in quality_profiles.yaml)
    denoiser = profile.get('denoiser_settings', {})
    if denoiser.get('enabled', False):
        scene.cycles.use_denoising = True
        scene.cycles.denoiser = denoiser.get('denoiser', 'OPENIMAGEDENOISE')

    return True
```

### Pattern 2: Render Pass Configuration
**What:** Enable render passes via view_layer.use_pass_* attributes
**When to use:** Setting up multi-pass renders for compositing
**Example:**
```python
# Source: configs/cinematic/render/pass_presets.yaml + CINEMATIC_SYSTEM_DESIGN.md
import bpy

# Pass mapping: config name -> view_layer attribute
PASS_MAPPING = {
    # Core passes
    'combined': 'use_pass_combined',
    'depth': 'use_pass_z',
    'normal': 'use_pass_normal',
    'vector': 'use_pass_vector',

    # Material passes
    'diffuse_direct': 'use_pass_diffuse_direct',
    'diffuse_indirect': 'use_pass_diffuse_indirect',
    'diffuse_color': 'use_pass_diffuse_color',
    'glossy_direct': 'use_pass_glossy_direct',
    'glossy_indirect': 'use_pass_glossy_indirect',
    'glossy_color': 'use_pass_glossy_color',
    'transmission_direct': 'use_pass_transmission_direct',
    'transmission_indirect': 'use_pass_transmission_indirect',
    'transmission_color': 'use_pass_transmission_color',

    # Effect passes
    'emission': 'use_pass_emit',
    'environment': 'use_pass_environment',
    'shadow': 'use_pass_shadow',
    'ao': 'use_pass_ambient_occlusion',

    # Cryptomatte (CRITICAL: Must enable for object isolation)
    'cryptomatte_object': 'use_pass_cryptomatte_object',
    'cryptomatte_material': 'use_pass_cryptomatte_material',
    'cryptomatte_asset': 'use_pass_cryptomatte_asset',
}

def configure_render_passes(pass_group: str) -> bool:
    """
    Configure render passes from pass_presets.yaml group.

    Supports: beauty, data_passes, material_passes, cryptomatte,
              full_production, product_minimal
    """
    view_layer = bpy.context.view_layer

    # Load preset
    preset = get_pass_preset(pass_group)  # From preset_loader
    passes = preset.get('passes', [])

    # Disable all passes first (clean slate)
    for attr in dir(view_layer):
        if attr.startswith('use_pass_'):
            setattr(view_layer, attr, False)

    # Enable requested passes
    for pass_name in passes:
        attr = PASS_MAPPING.get(pass_name)
        if attr and hasattr(view_layer, attr):
            setattr(view_layer, attr, True)

    # CRITICAL: Cryptomatte requires additional setup
    if 'cryptomatte_object' in passes:
        view_layer.cryptomatte_levels = 6  # Standard levels
        view_layer.use_pass_cryptomatte_accurate = True

    if 'cryptomatte_material' in passes:
        view_layer.cryptomatte_levels = 6
        view_layer.use_pass_cryptomatte_accurate = True

    return True
```

### Pattern 3: EXR Output Configuration
**What:** Configure EXR multi-layer output with compression and depth
**When to use:** Production renders requiring compositing
**Example:**
```python
# Source: configs/cinematic/render/pass_presets.yaml exr_settings
import bpy

EXR_CODECS = {
    'DWAA': 'DWAA',  # Lossy but fast, good for color data
    'ZIP': 'ZIP',    # Lossless, good balance for passes
    'PIZ': 'PIZ',    # Best compression, lossless
    'NONE': 'NONE',  # Uncompressed
}

def configure_exr_output(preset_name: str = 'multi_layer_compositing') -> bool:
    """
    Configure EXR output settings from pass_presets.yaml.

    Presets: beauty_only, multi_layer_compositing, archive_storage
    """
    scene = bpy.context.scene

    # Load preset
    exr_settings = get_exr_settings(preset_name)  # From preset_loader

    # Set output format
    scene.render.image_settings.file_format = 'OPEN_EXR_MULTILAYER'
    scene.render.image_settings.exr_codec = EXR_CODECS.get(
        exr_settings.get('compression', 'ZIP'), 'ZIP'
    )
    scene.render.image_settings.color_depth = str(exr_settings.get('depth', 32))
    scene.render.image_settings.use_preview = True

    # Enable alpha for compositing
    scene.render.film_transparent = True

    return True
```

### Pattern 4: Denoiser Selection (Hardware-Aware)
**What:** Select optimal denoiser based on available hardware
**When to use:** Setting up Cycles render with denoising
**Example:**
```python
# Source: CINEMATIC_SYSTEM_DESIGN.md section 13.7
import bpy
import platform

def select_denoiser() -> str:
    """
    Select optimal denoiser based on hardware.

    Returns Blender denoiser identifier.
    """
    prefs = bpy.context.preferences

    # Check OptiX availability (NVIDIA + OptiX)
    if _has_optix():
        return 'OPTIX'

    # Check Metal on Apple Silicon
    if platform.system() == 'Darwin':
        if _is_apple_silicon():
            return 'OPENIMAGEDENOISE'  # Metal-accelerated

    # Default to OpenImageDenoise (CPU)
    return 'OPENIMAGEDENOISE'

def _has_optix() -> bool:
    """Check if OptiX is available."""
    cycles_prefs = bpy.context.preferences.addons.get('cycles')
    if cycles_prefs:
        return cycles_prefs.preferences.compute_device_type == 'OPTIX'
    return False

def _is_apple_silicon() -> bool:
    """Check if running on Apple Silicon."""
    import platform
    return platform.processor() == 'arm'
```

### Pattern 5: RenderSettings Dataclass Extension
**What:** Extend existing RenderSettings dataclass for cinematic profiles
**When to use:** Storing and serializing render configuration
**Example:**
```python
# Source: lib/cinematic/types.py RenderSettings pattern
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional

@dataclass
class CinematicRenderSettings:
    """
    Extended render configuration for cinematic profiles.

    Extends RenderSettings with pass and quality tier support.
    """
    # Base settings (from existing RenderSettings)
    engine: str = "CYCLES"
    resolution_x: int = 2048
    resolution_y: int = 2048
    samples: int = 64
    quality_tier: str = "cycles_preview"

    # Cinematic extensions
    pass_group: str = "product_minimal"
    exr_preset: str = "multi_layer_compositing"
    denoiser: str = "auto"  # auto, OPTIX, OPENIMAGEDENOISE, none
    film_transparent: bool = True
    color_depth: int = 32
    compression: str = "ZIP"

    # Animation support
    frame_start: int = 1
    frame_end: int = 1
    fps: int = 24

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "engine": self.engine,
            "resolution_x": self.resolution_x,
            "resolution_y": self.resolution_y,
            "samples": self.samples,
            "quality_tier": self.quality_tier,
            "pass_group": self.pass_group,
            "exr_preset": self.exr_preset,
            "denoiser": self.denoiser,
            "film_transparent": self.film_transparent,
            "color_depth": self.color_depth,
            "compression": self.compression,
            "frame_start": self.frame_start,
            "frame_end": self.frame_end,
            "fps": self.fps,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CinematicRenderSettings":
        """Create from dictionary."""
        return cls(
            engine=data.get("engine", "CYCLES"),
            resolution_x=data.get("resolution_x", 2048),
            resolution_y=data.get("resolution_y", 2048),
            samples=data.get("samples", 64),
            quality_tier=data.get("quality_tier", "cycles_preview"),
            pass_group=data.get("pass_group", "product_minimal"),
            exr_preset=data.get("exr_preset", "multi_layer_compositing"),
            denoiser=data.get("denoiser", "auto"),
            film_transparent=data.get("film_transparent", True),
            color_depth=data.get("color_depth", 32),
            compression=data.get("compression", "ZIP"),
            frame_start=data.get("frame_start", 1),
            frame_end=data.get("frame_end", 1),
            fps=data.get("fps", 24),
        )
```

### Anti-Patterns to Avoid
- **Using deprecated engine identifiers:** BLENDER_EEVEE is deprecated in Blender 5.x, use BLENDER_EEVEE_NEXT
- **Enabling passes on scene instead of view_layer:** Render passes are view_layer.use_pass_*, not scene attributes
- **Forgetting cryptomatte setup:** Cryptomatte requires levels and accurate mode settings beyond just enabling the pass
- **Wrong EXR codec:** Use OPEN_EXR_MULTILAYER for multi-pass, OPEN_EXR for single layer

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Quality tier presets | Custom preset system | quality_profiles.yaml | Already exists, well-structured |
| Pass configurations | Manual pass enabling | pass_presets.yaml | Pre-defined groupings with API mappings |
| EXR settings | Custom compression logic | pass_presets.yaml exr_settings | Documented presets for use cases |
| Denoiser selection | Hardware detection | select_denoiser() pattern | Handles NVIDIA/Apple/CPU correctly |

**Key insight:** The configuration files already exist with proper structure. The implementation should leverage these rather than creating new preset systems.

## Common Pitfalls

### Pitfall 1: Deprecated EEVEE Engine Identifier
**What goes wrong:** Using 'BLENDER_EEVEE' causes errors in Blender 5.x
**Why it happens:** EEVEE was replaced by EEVEE Next in Blender 4.2+
**How to avoid:** Always use 'BLENDER_EEVEE_NEXT' from the ENGINES constant
**Warning signs:** `TypeError: enum "BLENDER_EEVEE" not found`

### Pitfall 2: Pass Configuration on Wrong Object
**What goes wrong:** Enabling passes on scene instead of view_layer has no effect
**Why it happens:** Confusion between scene.render and view_layer attributes
**How to avoid:** Always use `bpy.context.view_layer.use_pass_*` for passes
**Warning signs:** EXR output missing expected pass layers

### Pitfall 3: Incomplete Cryptomatte Setup
**What goes wrong:** Cryptomatte passes enabled but not functional
**Why it happens:** Cryptomatte requires levels and accurate mode in addition to pass enablement
**How to avoid:** Set `view_layer.cryptomatte_levels = 6` and `view_layer.use_pass_cryptomatte_accurate = True`
**Warning signs:** Cryptomatte pass exists but objects not properly isolated

### Pitfall 4: Wrong EXR Format for Multi-Pass
**What goes wrong:** Using OPEN_EXR instead of OPEN_EXR_MULTILAYER produces single-layer output
**Why it happens:** Similar format names, different capabilities
**How to avoid:** Use `file_format = 'OPEN_EXR_MULTILAYER'` when enabling multiple passes
**Warning signs:** EXR file only contains combined beauty, no pass layers

### Pitfall 5: Denoiser Not Hardware-Compatible
**What goes wrong:** OPTIX denoiser fails on non-NVIDIA hardware
**Why it happens:** OPTIX requires NVIDIA GPU with proper drivers
**How to avoid:** Use select_denoiser() to auto-detect compatible denoiser
**Warning signs:** Render fails with "OptiX not available" or similar error

## Code Examples

Verified patterns from official sources:

### Apply Complete Render Configuration
```python
# Source: configs/cinematic/render/quality_profiles.yaml + bpy API
import bpy

def apply_render_config(
    quality_tier: str = "cycles_preview",
    pass_group: str = "product_minimal",
    exr_preset: str = "multi_layer_compositing"
) -> bool:
    """
    Apply complete render configuration from presets.

    Combines quality tier, passes, and EXR settings.
    """
    # Apply quality tier
    apply_quality_tier(quality_tier)

    # Configure passes
    configure_render_passes(pass_group)

    # Configure EXR output
    configure_exr_output(exr_preset)

    return True
```

### Render with Metadata
```python
# Source: CINEMATIC_SYSTEM_DESIGN.md section Q8
import bpy
from datetime import datetime

def render_with_metadata(
    output_path: str,
    shot_name: str,
    metadata: dict = None
) -> str:
    """
    Render to EXR with embedded metadata.

    Metadata includes shot info, settings, and timestamps.
    """
    scene = bpy.context.scene

    # Set output path
    scene.render.filepath = output_path

    # Prepare metadata (stored in EXR header)
    meta = {
        "shot_name": shot_name,
        "render_time": datetime.now().isoformat(),
        "engine": scene.render.engine,
        "samples": scene.cycles.samples if scene.render.engine == 'CYCLES' else 0,
        "resolution": f"{scene.render.resolution_x}x{scene.render.resolution_y}",
    }
    if metadata:
        meta.update(metadata)

    # Render
    bpy.ops.render.render(write_still=True)

    return output_path
```

### Batch Render with Dependencies
```python
# Source: CINEMATIC_SYSTEM_DESIGN.md section Q7
from typing import List, Dict
from pathlib import Path

def batch_render(
    shots: List[Dict],
    parallel_jobs: int = 1,
    resume_on_failure: bool = True
) -> Dict[str, bool]:
    """
    Batch render multiple shots with dependency management.

    Args:
        shots: List of shot configs with 'shot' and 'depends_on' keys
        parallel_jobs: Number of parallel renders (currently single-threaded)
        resume_on_failure: Skip completed renders if resuming

    Returns:
        Dict mapping shot names to success status
    """
    results = {}
    completed = set()

    for shot_config in shots:
        shot_name = shot_config['shot']
        dependencies = shot_config.get('depends_on', [])

        # Check dependencies
        deps_satisfied = all(d in completed for d in dependencies)
        if not deps_satisfied:
            results[shot_name] = False
            continue

        # Check if already rendered (resume)
        output_file = Path(f"renders/{shot_name}/render.exr")
        if resume_on_failure and output_file.exists():
            completed.add(shot_name)
            results[shot_name] = True
            continue

        # Render shot
        try:
            # Load and apply shot config
            # ... shot loading logic ...
            bpy.ops.render.render(write_still=True)
            results[shot_name] = True
            completed.add(shot_name)
        except Exception as e:
            results[shot_name] = False

    return results
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| BLENDER_EEVEE | BLENDER_EEVEE_NEXT | Blender 4.2+ | EEVEE Next has raytracing |
| Manual denoiser | Hardware-aware selection | Blender 3.0+ | Auto-selects OPTIX/OpenImageDenoise |
| Single EXR layer | OPEN_EXR_MULTILAYER | Always available | All passes in one file |
| Fixed pass set | Pass presets | Project convention | Reusable pass configurations |

**Deprecated/outdated:**
- `BLENDER_EEVEE`: Replaced by `BLENDER_EEVEE_NEXT` in Blender 4.2+
- `use_pass_diffuse`: Split into `use_pass_diffuse_direct/indirect/color`
- `use_pass_color`: Replaced by component passes

## Open Questions

Things that couldn't be fully resolved:

1. **EXR Metadata Embedding**
   - What we know: Blender can write basic metadata to EXR
   - What's unclear: How to embed custom metadata (shot_name, git_commit) via Python API
   - Recommendation: Use render.stamp() for basic metadata, investigate OpenEXR libraries for custom

2. **Parallel Batch Rendering**
   - What we know: bpy.render is blocking
   - What's unclear: Best approach for parallel renders (background Blender instances?)
   - Recommendation: Start with sequential rendering, add background process support later

3. **Render Progress Callbacks**
   - What we know: No direct Python callback for render progress
   - What's unclear: How to monitor render progress for UI feedback
   - Recommendation: Use render handlers (bpy.app.handlers.render_stats) for post-render info

## Sources

### Primary (HIGH confidence)
- Blender API documentation (RenderSettings, ImageFormatSettings, ViewLayer)
- configs/cinematic/render/quality_profiles.yaml - Quality tier definitions
- configs/cinematic/render/pass_presets.yaml - Pass mappings and EXR settings
- lib/cinematic/types.py - Dataclass pattern for RenderSettings
- lib/cinematic/preset_loader.py - YAML preset loading pattern
- lib/cinematic/color.py - Pattern for applying presets to Blender scenes

### Secondary (MEDIUM confidence)
- .planning/design/CINEMATIC_SYSTEM_DESIGN.md - Technical specifications section 13
- projects/neve_knobs/scripts/render_final.py - Practical Cycles render setup example
- lib/exports.py - Existing render_preview and mesh export patterns

### Tertiary (LOW confidence)
- None - all critical patterns verified from primary sources

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - bpy API is stable and documented
- Architecture: HIGH - Existing patterns in types.py and preset_loader.py are proven
- Pitfalls: HIGH - Based on documented API changes and common mistakes

**Research date:** 2026-02-18
**Valid until:** 30 days (stable API, but watch for Blender version changes)
