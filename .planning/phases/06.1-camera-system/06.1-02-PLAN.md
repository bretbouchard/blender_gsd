---
phase: 06.1-camera-system
plan: 02
type: execute
wave: 2
depends_on: ["06.1-01"]
enables: ["06.1-03", "06.1-04", "06.2-01"]
test_coverage: 80%
oracle_validators: ["compare_numbers", "compare_vectors", "compare_within_range", "exit_code_zero"]
universal_stages:
  normalize: "Import CameraConfig and validate aperture range"
  primary: "Create Blender camera object with create_camera()"
  secondary: "Apply DoF, lens presets, sensor presets"
  detail: "Handle focus_mode (auto/manual) and edge cases"
  output: "Return configured camera object"
files_modified:
  - lib/cinematic/camera.py
  - lib/cinematic/__init__.py
autonomous: true

must_haves:
  truths:
    - "Camera can be created from CameraConfig with all lens settings applied"
    - "Depth of field is configured when focus_distance > 0"
    - "Camera transform is applied correctly (degrees to radians conversion)"
    - "Camera becomes scene camera when set_active=True"
    - "Aperture f-stop is validated to f/0.95 - f/22 range"
    - "Focus mode (auto/manual) controls how focus distance is determined"
  artifacts:
    - path: "lib/cinematic/camera.py"
      provides: "Camera creation and management"
      exports: ["create_camera", "configure_dof", "apply_lens_preset", "apply_sensor_preset", "get_active_camera", "set_active_camera", "validate_aperture", "set_focus_mode"]
      min_lines: 180
  key_links:
    - from: "lib/cinematic/camera.py"
      to: "bpy.data.cameras"
      via: "Blender API"
      pattern: "bpy\\.data\\.cameras\\.new"
    - from: "lib/cinematic/camera.py"
      to: "lib/cinematic/types.py"
      via: "CameraConfig import"
      pattern: "from.*types import.*CameraConfig"
    - from: "lib/cinematic/camera.py"
      to: "lib/cinematic/preset_loader.py"
      via: "get_aperture_preset import"
      pattern: "from.*preset_loader import.*get_aperture_preset"
---

<objective>
Create camera.py module with camera creation and management functions.

Purpose: Provide Blender camera creation from CameraConfig, DoF configuration, lens/sensor preset application, and scene camera management. All bpy access must be guarded for testing outside Blender.

Output: camera.py module with 8+ exported functions, updated __init__.py exports.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6.1 Plan 01 Summary (will be created after execution)
@.planning/phases/06.1-camera-system/06.1-01-SUMMARY.md

# Existing codebase patterns
@lib/cinematic/types.py
@lib/cinematic/enums.py
@lib/cinematic/state_manager.py

# Research findings with code examples
@.planning/phases/06.1-camera-system/06.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create camera.py module</name>
  <files>lib/cinematic/camera.py</files>
  <action>
Create lib/cinematic/camera.py with camera management functions.

**CRITICAL:** All bpy access must be guarded with try/except to allow testing outside Blender. Follow the pattern from state_manager.py.

Module structure:

```python
"""
Camera System Module

Provides camera creation, configuration, and management functions.
All bpy access is guarded for testing outside Blender.
"""

from __future__ import annotations
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
import math

from .types import CameraConfig, Transform3D, PlumbBobConfig
from .preset_loader import get_lens_preset, get_sensor_preset, get_aperture_preset

# Guarded bpy import
try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False


# Aperture range constants (REQ-CINE-CAM)
APERTURE_MIN = 0.95  # f/0.95 - fastest practical lens
APERTURE_MAX = 22.0  # f/22 - smallest practical aperture


def validate_aperture(f_stop: float) -> bool:
    """
    Validate aperture f-stop is within valid range.

    Args:
        f_stop: F-stop value to validate

    Returns:
        True if valid

    Raises:
        ValueError: If f_stop is outside f/0.95 to f/22 range
    """
    if not (APERTURE_MIN <= f_stop <= APERTURE_MAX):
        raise ValueError(
            f"Invalid aperture f/{f_stop}. Must be between f/{APERTURE_MIN} and f/{APERTURE_MAX}"
        )
    return True


def create_camera(
    config: CameraConfig,
    collection: Optional[Any] = None,
    set_active: bool = False,
    plumb_bob_config: Optional[PlumbBobConfig] = None
) -> Optional[Any]:
    """
    Create a camera object from CameraConfig.

    Args:
        config: CameraConfig with all settings
        collection: Optional collection to link to (defaults to scene collection)
        set_active: If True, set as scene camera
        plumb_bob_config: Optional plumb bob config for focus mode handling

    Returns:
        Created camera object, or None if Blender not available

    Raises:
        RuntimeError: If Blender not available and strict=True
        ValueError: If aperture f_stop is outside valid range
    """
    # ... implementation following research examples
```

Functions to implement:

1. `validate_aperture(f_stop: float) -> bool`
   - Validate f_stop is in range 0.95 to 22.0
   - Raise ValueError if outside range
   - Return True if valid
   - Called by create_camera and configure_dof

2. `create_camera(config: CameraConfig, collection=None, set_active=False, plumb_bob_config=None) -> Optional[bpy.types.Object]`
   - Validate aperture using validate_aperture()
   - Create camera data with bpy.data.cameras.new()
   - Create object with bpy.data.objects.new()
   - Apply lens settings (focal_length, sensor_width/height)
   - Apply DoF if focus_distance > 0
   - Apply transform using config.transform.to_blender()
   - Link to collection
   - Set as scene camera if set_active=True
   - Return camera object or None

3. `configure_dof(camera: bpy.types.Camera, f_stop: float, focus_distance: float, blades: int = 9)`
   - Validate aperture using validate_aperture()
   - Set camera.dof.use_dof = True
   - Set camera.dof.aperture_fstop = f_stop
   - Set camera.dof.focus_distance = focus_distance
   - Set camera.dof.aperture_blades = blades
   - Guard all access

4. `set_focus_mode(camera_name: str, plumb_bob_config: PlumbBobConfig, target_position: Optional[Tuple[float, float, float]] = None) -> float`
   - Handle auto vs manual focus mode:
     - If focus_mode == "manual": Use plumb_bob_config.focus_distance directly
     - If focus_mode == "auto": Calculate from camera position to target_position
   - Set camera.dof.focus_distance to calculated value
   - Return the focus distance used
   - Guard all bpy access

5. `apply_lens_preset(camera: bpy.types.Camera, preset_name: str)`
   - Load preset using get_lens_preset()
   - Apply focal_length
   - Return preset dict for reference

6. `apply_sensor_preset(camera: bpy.types.Camera, preset_name: str)`
   - Load preset using get_sensor_preset()
   - Apply sensor_width, sensor_height
   - Return preset dict for reference

7. `get_active_camera() -> Optional[bpy.types.Object]`
   - Return bpy.context.scene.camera or None
   - Guard all access

8. `set_active_camera(camera: bpy.types.Object) -> bool`
   - Set bpy.context.scene.camera = camera
   - Return True on success, False if failed

9. `delete_camera(name: str) -> bool`
   - Delete camera object and its data
   - Return True if deleted, False if not found

10. `list_cameras() -> List[str]`
    - Return list of camera object names in scene

COMMON PITFALLS (from research):
- Use config.transform.to_blender() for degree-to-radian conversion
- Always validate aperture before setting DoF
- Always set scene.camera after creation if set_active=True
- Guard ALL bpy.context access with hasattr checks
- Return None gracefully when Blender not available
</action>
  <verify>
# Outside Blender test - verify module imports and guards work
python3 -c "
from lib.cinematic.camera import (
    create_camera, configure_dof, apply_lens_preset,
    apply_sensor_preset, get_active_camera, set_active_camera,
    delete_camera, list_cameras, validate_aperture, set_focus_mode,
    BLENDER_AVAILABLE, APERTURE_MIN, APERTURE_MAX
)
print(f'BLENDER_AVAILABLE: {BLENDER_AVAILABLE}')
print(f'APERTURE_MIN: {APERTURE_MIN}, APERTURE_MAX: {APERTURE_MAX}')
# Test aperture validation
assert validate_aperture(2.8) == True
assert validate_aperture(0.95) == True  # Edge case - minimum
assert validate_aperture(22.0) == True  # Edge case - maximum
print('Aperture validation works for valid values')
# Test invalid apertures
try:
    validate_aperture(0.5)  # Below minimum
    print('ERROR: Should have raised ValueError for f/0.5')
except ValueError as e:
    print(f'Correctly rejected f/0.5: {e}')
try:
    validate_aperture(32.0)  # Above maximum
    print('ERROR: Should have raised ValueError for f/32')
except ValueError as e:
    print(f'Correctly rejected f/32: {e}')
# Create a config (should work)
from lib.cinematic.types import CameraConfig, Transform3D, PlumbBobConfig
config = CameraConfig(
    name='test_camera',
    focal_length=85.0,
    transform=Transform3D(position=(0, -5, 2))
)
print(f'CameraConfig created: {config.name}')
# Test plumb bob config with focus_mode
plumb_config = PlumbBobConfig(focus_mode='manual', focus_distance=3.0)
print(f'PlumbBobConfig: focus_mode={plumb_config.focus_mode}, distance={plumb_config.focus_distance}')
# Functions should return None gracefully outside Blender
cam = create_camera(config)
print(f'create_camera returned: {cam} (expected None outside Blender)')
active = get_active_camera()
print(f'get_active_camera returned: {active} (expected None outside Blender)')
print('All functions importable and gracefully handle non-Blender context')
"
</verify>
  <done>Camera module with 10 functions created, aperture validation f/0.95-f/22, focus_mode handling, all bpy access guarded, works outside Blender</done>
</task>

<task type="auto">
  <name>Task 2: Update __init__.py with camera exports</name>
  <files>lib/cinematic/__init__.py</files>
  <action>
Update lib/cinematic/__init__.py to export camera module functions:

1. Add imports from .camera:
   - create_camera
   - configure_dof
   - apply_lens_preset
   - apply_sensor_preset
   - get_active_camera
   - set_active_camera
   - delete_camera
   - list_cameras
   - validate_aperture
   - set_focus_mode
   - APERTURE_MIN
   - APERTURE_MAX

2. Add to __all__ list

3. Update module docstring to mention camera module
</action>
  <verify>
python3 -c "
from lib.cinematic import (
    create_camera, configure_dof, apply_lens_preset,
    apply_sensor_preset, get_active_camera, set_active_camera,
    delete_camera, list_cameras, validate_aperture, set_focus_mode,
    APERTURE_MIN, APERTURE_MAX
)
print(f'APERTURE_MIN: {APERTURE_MIN}, APERTURE_MAX: {APERTURE_MAX}')
assert APERTURE_MIN == 0.95
assert APERTURE_MAX == 22.0
print('All camera functions exported from lib.cinematic')
"
</verify>
  <done>All camera functions including validate_aperture and set_focus_mode exported from lib.cinematic package</done>
</task>

</tasks>

<verification>
1. camera.py module exists with 10 exported functions
2. validate_aperture() enforces f/0.95 to f/22 range
3. set_focus_mode() handles auto and manual focus modes
4. All bpy access guarded with try/except and BLENDER_AVAILABLE check
5. Functions return None gracefully when Blender not available
6. create_camera() applies CameraConfig settings correctly and validates aperture
7. configure_dof() sets all DoF properties and validates aperture
8. Preset application functions use preset_loader
9. All functions exported from lib.cinematic
10. APERTURE_MIN and APERTURE_MAX constants exported
</verification>

<success_criteria>
- Camera module functional with guarded bpy access
- All 10 functions implemented and exported
- Aperture validation f/0.95 to f/22 implemented
- Focus mode (auto/manual) handling implemented
- Works outside Blender for testing
- Follows established patterns from state_manager.py
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-camera-system/06.1-02-SUMMARY.md`
</output>
