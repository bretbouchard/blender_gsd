---
phase: 06.1-camera-system
plan: 02
type: execute
wave: 2
depends_on: ["06.1-01"]
files_modified:
  - lib/cinematic/camera.py
  - lib/cinematic/__init__.py
autonomous: true

must_haves:
  truths:
    - "Camera can be created from CameraConfig with all lens settings applied"
    - "Depth of field is configured when focus_distance > 0"
    - "Camera transform is applied correctly (degrees to radians conversion)"
    - "Camera becomes scene camera when set_active=True"
  artifacts:
    - path: "lib/cinematic/camera.py"
      provides: "Camera creation and management"
      exports: ["create_camera", "configure_dof", "apply_lens_preset", "apply_sensor_preset", "get_active_camera", "set_active_camera"]
      min_lines: 150
  key_links:
    - from: "lib/cinematic/camera.py"
      to: "bpy.data.cameras"
      via: "Blender API"
      pattern: "bpy\\.data\\.cameras\\.new"
    - from: "lib/cinematic/camera.py"
      to: "lib/cinematic/types.py"
      via: "CameraConfig import"
      pattern: "from.*types import.*CameraConfig"
---

<objective>
Create camera.py module with camera creation and management functions.

Purpose: Provide Blender camera creation from CameraConfig, DoF configuration, lens/sensor preset application, and scene camera management. All bpy access must be guarded for testing outside Blender.

Output: camera.py module with 6+ exported functions, updated __init__.py exports.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6.1 Plan 01 Summary (will be created after execution)
@.planning/phases/06.1-camera-system/06.1-01-SUMMARY.md

# Existing codebase patterns
@lib/cinematic/types.py
@lib/cinematic/enums.py
@lib/cinematic/state_manager.py

# Research findings with code examples
@.planning/phases/06.1-camera-system/06.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create camera.py module</name>
  <files>lib/cinematic/camera.py</files>
  <action>
Create lib/cinematic/camera.py with camera management functions.

**CRITICAL:** All bpy access must be guarded with try/except to allow testing outside Blender. Follow the pattern from state_manager.py.

Module structure:

```python
"""
Camera System Module

Provides camera creation, configuration, and management functions.
All bpy access is guarded for testing outside Blender.
"""

from __future__ import annotations
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
import math

from .types import CameraConfig, Transform3D
from .preset_loader import get_lens_preset, get_sensor_preset

# Guarded bpy import
try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False


def create_camera(
    config: CameraConfig,
    collection: Optional[Any] = None,
    set_active: bool = False
) -> Optional[Any]:
    """
    Create a camera object from CameraConfig.

    Args:
        config: CameraConfig with all settings
        collection: Optional collection to link to (defaults to scene collection)
        set_active: If True, set as scene camera

    Returns:
        Created camera object, or None if Blender not available

    Raises:
        RuntimeError: If Blender not available and strict=True
    """
    if not BLENDER_AVAILABLE:
        return None

    # ... implementation following research examples
```

Functions to implement:

1. `create_camera(config: CameraConfig, collection=None, set_active=False) -> Optional[bpy.types.Object]`
   - Create camera data with bpy.data.cameras.new()
   - Create object with bpy.data.objects.new()
   - Apply lens settings (focal_length, sensor_width/height)
   - Apply DoF if focus_distance > 0
   - Apply transform using config.transform.to_blender()
   - Link to collection
   - Set as scene camera if set_active=True
   - Return camera object or None

2. `configure_dof(camera: bpy.types.Camera, f_stop: float, focus_distance: float, blades: int = 9)`
   - Set camera.dof.use_dof = True
   - Set camera.dof.aperture_fstop = f_stop
   - Set camera.dof.focus_distance = focus_distance
   - Set camera.dof.aperture_blades = blades
   - Guard all access

3. `apply_lens_preset(camera: bpy.types.Camera, preset_name: str)`
   - Load preset using get_lens_preset()
   - Apply focal_length
   - Return preset dict for reference

4. `apply_sensor_preset(camera: bpy.types.Camera, preset_name: str)`
   - Load preset using get_sensor_preset()
   - Apply sensor_width, sensor_height
   - Return preset dict for reference

5. `get_active_camera() -> Optional[bpy.types.Object]`
   - Return bpy.context.scene.camera or None
   - Guard all access

6. `set_active_camera(camera: bpy.types.Object) -> bool`
   - Set bpy.context.scene.camera = camera
   - Return True on success, False if failed

7. `delete_camera(name: str) -> bool`
   - Delete camera object and its data
   - Return True if deleted, False if not found

8. `list_cameras() -> List[str]`
   - Return list of camera object names in scene

COMMON PITFALLS (from research):
- Use config.transform.to_blender() for degree-to-radian conversion
- Always set scene.camera after creation if set_active=True
- Guard ALL bpy.context access with hasattr checks
- Return None gracefully when Blender not available
</action>
  <verify>
# Outside Blender test - verify module imports and guards work
python3 -c "
from lib.cinematic.camera import (
    create_camera, configure_dof, apply_lens_preset,
    apply_sensor_preset, get_active_camera, set_active_camera,
    delete_camera, list_cameras, BLENDER_AVAILABLE
)
print(f'BLENDER_AVAILABLE: {BLENDER_AVAILABLE}')
# Create a config (should work)
from lib.cinematic.types import CameraConfig, Transform3D
config = CameraConfig(
    name='test_camera',
    focal_length=85.0,
    transform=Transform3D(position=(0, -5, 2))
)
print(f'CameraConfig created: {config.name}')
# Functions should return None gracefully outside Blender
cam = create_camera(config)
print(f'create_camera returned: {cam} (expected None outside Blender)')
active = get_active_camera()
print(f'get_active_camera returned: {active} (expected None outside Blender)')
print('All functions importable and gracefully handle non-Blender context')
"
</verify>
  <done>Camera module with 8 functions created, all bpy access guarded, works outside Blender</done>
</task>

<task type="auto">
  <name>Task 2: Update __init__.py with camera exports</name>
  <files>lib/cinematic/__init__.py</files>
  <action>
Update lib/cinematic/__init__.py to export camera module functions:

1. Add imports from .camera:
   - create_camera
   - configure_dof
   - apply_lens_preset
   - apply_sensor_preset
   - get_active_camera
   - set_active_camera
   - delete_camera
   - list_cameras

2. Add to __all__ list

3. Update module docstring to mention camera module
</action>
  <verify>
python3 -c "
from lib.cinematic import (
    create_camera, configure_dof, apply_lens_preset,
    apply_sensor_preset, get_active_camera, set_active_camera,
    delete_camera, list_cameras
)
print('All camera functions exported from lib.cinematic')
"
</verify>
  <done>All camera functions exported from lib.cinematic package</done>
</task>

</tasks>

<verification>
1. camera.py module exists with 8 exported functions
2. All bpy access guarded with try/except and BLENDER_AVAILABLE check
3. Functions return None gracefully when Blender not available
4. create_camera() applies CameraConfig settings correctly
5. configure_dof() sets all DoF properties
6. Preset application functions use preset_loader
7. All functions exported from lib.cinematic
</verification>

<success_criteria>
- Camera module functional with guarded bpy access
- All 8 functions implemented and exported
- Works outside Blender for testing
- Follows established patterns from state_manager.py
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-camera-system/06.1-02-SUMMARY.md`
</output>
