# Phase 6.1: Camera System - Research Findings

**Research Date:** 2026-02-18
**Phase Goal:** Implement comprehensive camera system with lenses, sensor presets, camera rigs, and plumb bob targeting system
**Requirements Covered:** REQ-CINE-CAM, REQ-CINE-PLUMB

---

## Summary

This research covers the technical implementation details for Phase 6.1 Camera System. Key findings include:

1. **Blender Camera API** is well-documented with straightforward property access
2. **Existing codebase** provides solid patterns for dataclasses, YAML loading, and bpy interaction
3. **Plumb bob algorithm** is already specified in design document with clear implementation path
4. **Compositor pipeline order** is critical for lens imperfections (geometric → luminance → glow → color → film)
5. **Multi-camera layout** requires viewport calculation and composite node setup

---

## Standard Stack

### Core Libraries (Already in Project)

| Library | Purpose | Usage Pattern |
|---------|---------|---------------|
| `bpy` | Blender Python API | Camera creation, scene manipulation |
| `mathutils` | Vector/Matrix math | Position calculations, transforms |
| `PyYAML` | Configuration loading | Preset files with JSON fallback |
| `dataclasses` | Type-safe configs | CameraConfig, Transform3D patterns |

### Blender Camera API

```python
# Camera data access
bpy.data.cameras        # All camera data blocks
bpy.data.objects        # All objects (including camera objects)

# Scene camera
scene.camera            # Active camera object
scene.camera.data       # Camera data (lens, sensor, etc.)

# Camera properties
camera.lens             # Focal length (mm)
camera.sensor_width     # Sensor width (mm)
camera.sensor_height    # Sensor height (mm)
camera.clip_start       # Near clip distance
camera.clip_end         # Far clip distance
camera.type             # 'PERSP', 'ORTHO', 'PANO'

# Depth of Field
camera.dof.use_dof              # Enable/disable DoF
camera.dof.aperture_fstop       # F-stop value
camera.dof.focus_distance       # Focus distance (meters)
camera.dof.aperture_blades      # Bokeh blade count
camera.dof.focus_object         # Optional focus target object
```

---

## Architecture Patterns

### 1. Dataclass-Based Configuration

**Established Pattern** (from `lib/cinematic/types.py`):

```python
@dataclass
class Transform3D:
    position: Tuple[float, float, float] = (0.0, 0.0, 0.0)
    rotation: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # Euler degrees
    scale: Tuple[float, float, float] = (1.0, 1.0, 1.0)

    def to_blender(self) -> Dict[str, Any]:
        return {
            "location": list(self.position),
            "rotation_euler": [r * 0.017453292519943295 for r in self.rotation],
            "scale": list(self.scale),
        }

    def to_dict(self) -> Dict[str, Any]:
        return {
            "position": list(self.position),
            "rotation": list(self.rotation),
            "scale": list(self.scale),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> Transform3D:
        return cls(
            position=tuple(data.get("position", (0.0, 0.0, 0.0))),
            rotation=tuple(data.get("rotation", (0.0, 0.0, 0.0))),
            scale=tuple(data.get("scale", (1.0, 1.0, 1.0))),
        )
```

**Apply to Camera System:**
- Extend CameraConfig with lens imperfection settings
- Add PlumbBobConfig dataclass with modes (auto/manual/object)
- Add RigConfig dataclass for motion constraints

### 2. Safe bpy Access Pattern

**Established Pattern** (from `lib/cinematic/state_manager.py`):

```python
def capture_current(self, shot_name: str) -> ShotState:
    state = ShotState(shot_name=shot_name)
    try:
        import bpy

        # Guard: Check context exists
        if not hasattr(bpy, "context") or bpy.context.scene is None:
            return state

        scene = bpy.context.scene

        # Guard: Check camera exists
        if scene.camera is None:
            return state

        cam_obj = scene.camera
        # ... extract camera data

    except ImportError:
        # bpy not available, return default state
        pass
    except Exception:
        # Any Blender access error, return state with defaults
        pass

    return state
```

**Apply to Camera System:**
- All camera creation functions must use try/except guards
- Return default/empty configs when bpy unavailable
- Test state outside Blender

### 3. YAML Preset Loading Pattern

**Established Pattern** (from `lib/cinematic/state_manager.py`):

```python
try:
    import yaml
except ImportError:
    yaml = None

def load(self, path: Path) -> ShotState:
    path = Path(path)
    if not path.exists():
        raise FileNotFoundError(f"State file not found: {path}")

    with open(path, "r", encoding="utf-8") as f:
        data_raw = f.read()

    if path.suffix.lower() in [".yaml", ".yml"]:
        if not yaml:
            raise RuntimeError("PyYAML not available. Use JSON or install PyYAML.")
        data = yaml.safe_load(data_raw)
    else:
        import json
        data = json.loads(data_raw)

    return ShotState.from_yaml_dict(data)
```

**Apply to Camera System:**
- Load lens_presets.yaml, sensor_presets.yaml, rig_presets.yaml, imperfection_presets.yaml
- Use same YAML/JSON fallback pattern
- Convert to dataclass instances

---

## Don't Hand-Roll

### 1. Camera Creation - Use bpy.data.cameras

```python
# DON'T: Manually construct camera objects
# DO: Use Blender's camera data API

def create_camera(config: CameraConfig) -> bpy.types.Object:
    # Create camera data
    cam_data = bpy.data.cameras.new(name=config.name)

    # Create object with camera data
    cam_obj = bpy.data.objects.new(config.name, cam_data)

    # Link to scene
    bpy.context.scene.collection.objects.link(cam_obj)

    return cam_obj
```

### 2. DoF Setup - Use camera.dof Properties

```python
# DON'T: Try to implement DoF manually
# DO: Use Blender's built-in DoF system

def configure_dof(camera: bpy.types.Camera, f_stop: float, focus_distance: float, blades: int = 9):
    camera.dof.use_dof = True
    camera.dof.aperture_fstop = f_stop
    camera.dof.focus_distance = focus_distance
    camera.dof.aperture_blades = blades
```

### 3. Lens Imperfections - Use Compositor Nodes

```python
# DON'T: Try to implement vignette/chromatic aberration manually
# DO: Use compositor node tree

# Compositor Pipeline Order (CRITICAL):
# 1. Geometric distortions (chromatic aberration, lens distortion)
# 2. Luminance effects (glare, bloom)
# 3. Color grading
# 4. Film effects (grain, vignette)

def setup_lens_imperfections(config: ImperfectionConfig):
    scene = bpy.context.scene
    scene.use_nodes = True
    tree = scene.node_tree

    # Get or create compositor nodes
    # Order: Render Layers -> Color Correction -> Lens Distortion -> Vignette -> Composite
```

### 4. Rig Constraints - Use Blender Constraints

```python
# DON'T: Implement motion constraints manually
# DO: Use Blender's constraint system

def setup_tripod_rig(camera: bpy.types.Object, target: bpy.types.Object):
    # Track To constraint for orbit
    constraint = camera.constraints.new(type='TRACK_TO')
    constraint.target = target
    constraint.track_axis = 'TRACK_NEGATIVE_Z'
    constraint.up_axis = 'UP_Y'

    # Limit rotation for tripod behavior
    rot_limit = camera.constraints.new(type='LIMIT_ROTATION')
    rot_limit.use_limit_x = True
    rot_limit.use_limit_y = True
```

---

## Common Pitfalls

### 1. Rotation Units - Degrees vs Radians

```python
# WRONG: Direct assignment of degrees
cam_obj.rotation_euler = (90, 0, 0)  # Unexpected result!

# CORRECT: Convert degrees to radians
import math
cam_obj.rotation_euler = (
    90 * math.pi / 180,  # or use math.radians(90)
    0,
    0
)

# Or use the existing Transform3D.to_blender() helper
transform = Transform3D(rotation=(90, 0, 0))  # degrees in
blender_data = transform.to_blender()  # radians out
```

### 2. bpy Context Access

```python
# WRONG: Assume context always available
scene = bpy.context.scene  # Can fail if called from wrong context

# CORRECT: Guard all bpy access
try:
    import bpy
    if not hasattr(bpy, "context") or bpy.context.scene is None:
        return None  # Handle gracefully
    scene = bpy.context.scene
except ImportError:
    return None  # Running outside Blender
```

### 3. Compositor Pipeline Order

```python
# WRONG: Apply vignette before color correction
# Vignette applied first affects color grading calculation

# CORRECT: Follow pipeline order
# 1. Geometric (lens distortion, chromatic aberration)
# 2. Luminance (glare, bloom)
# 3. Color grading (curves, levels)
# 4. Film effects (grain, vignette)
```

### 4. Camera Active State

```python
# WRONG: Create camera but don't set as active
cam_obj = create_camera(config)
# Camera exists but scene.camera still points elsewhere

# CORRECT: Set as scene camera
cam_obj = create_camera(config)
bpy.context.scene.camera = cam_obj
```

### 5. Object Matrix World

```python
# WRONG: Use local coordinates for world calculations
local_pos = obj.location  # Local space

# CORRECT: Use matrix_world for world space
from mathutils import Vector
world_pos = obj.matrix_world @ Vector((0, 0, 0))
```

---

## Code Examples

### 1. Camera Creation with Full Configuration

```python
from mathutils import Vector
from typing import Optional

def create_camera_from_config(
    config: CameraConfig,
    collection: Optional[bpy.types.Collection] = None
) -> bpy.types.Object:
    """
    Create a camera object from CameraConfig.

    Args:
        config: CameraConfig with all settings
        collection: Optional collection to link to (defaults to scene collection)

    Returns:
        Created camera object
    """
    try:
        import bpy
    except ImportError:
        raise RuntimeError("This function requires Blender")

    # Create camera data
    cam_data = bpy.data.cameras.new(name=config.name)

    # Apply lens settings
    cam_data.lens = config.focal_length
    cam_data.sensor_width = config.sensor_width
    cam_data.sensor_height = config.sensor_height
    cam_data.type = 'PERSP'

    # Apply DoF if focus_distance specified
    if config.focus_distance > 0:
        cam_data.dof.use_dof = True
        cam_data.dof.focus_distance = config.focus_distance
        cam_data.dof.aperture_fstop = config.f_stop
        cam_data.dof.aperture_blades = config.aperture_blades

    # Create object
    cam_obj = bpy.data.objects.new(config.name, cam_data)

    # Apply transform
    blender_transform = config.transform.to_blender()
    cam_obj.location = blender_transform["location"]
    cam_obj.rotation_euler = blender_transform["rotation_euler"]
    cam_obj.scale = blender_transform["scale"]

    # Link to collection
    if collection is None:
        collection = bpy.context.scene.collection
    collection.objects.link(cam_obj)

    return cam_obj
```

### 2. Plumb Bob Calculation

```python
from mathutils import Vector
from typing import Literal

def calculate_plumb_bob(
    subject: bpy.types.Object,
    mode: Literal["auto", "manual", "object"] = "auto",
    offset: Vector = None,
    manual_position: Vector = None,
    target_object: bpy.types.Object = None
) -> Vector:
    """
    Calculate plumb bob target position.

    Args:
        subject: Primary subject object
        mode: Positioning mode
        offset: World space offset from calculated position
        manual_position: Explicit position for manual mode
        target_object: Target object for object mode

    Returns:
        World space position for plumb bob
    """
    if offset is None:
        offset = Vector((0, 0, 0))

    if mode == "manual":
        return manual_position + offset if manual_position else offset

    if mode == "object":
        if target_object is None:
            raise ValueError("target_object required for object mode")
        world_pos = target_object.matrix_world @ Vector((0, 0, 0))
        return world_pos + offset

    # Auto mode: Calculate bounding box center
    # Get local bounding box
    bbox = subject.bound_box  # 8 corners in local space

    # Calculate local center
    center = Vector((
        sum(v[0] for v in bbox) / 8,
        sum(v[1] for v in bbox) / 8,
        sum(v[2] for v in bbox) / 8
    ))

    # Convert to world space
    world_center = subject.matrix_world @ center

    return world_center + offset


def calculate_focus_distance(camera: bpy.types.Object, target: Vector) -> float:
    """
    Calculate focus distance from camera to target.

    Args:
        camera: Camera object
        target: Target position in world space

    Returns:
        Distance in meters
    """
    cam_pos = camera.matrix_world @ Vector((0, 0, 0))
    return (target - cam_pos).length
```

### 3. YAML Preset Loading

```python
from pathlib import Path
from typing import Dict, Any, Optional

try:
    import yaml
except ImportError:
    yaml = None


def load_preset(path: Path) -> Dict[str, Any]:
    """
    Load a preset YAML file with JSON fallback.

    Args:
        path: Path to preset file

    Returns:
        Parsed preset dictionary

    Raises:
        FileNotFoundError: If file doesn't exist
        RuntimeError: If YAML file but PyYAML not available
    """
    path = Path(path)

    if not path.exists():
        raise FileNotFoundError(f"Preset file not found: {path}")

    with open(path, "r", encoding="utf-8") as f:
        data_raw = f.read()

    if path.suffix.lower() in [".yaml", ".yml"]:
        if not yaml:
            raise RuntimeError(
                "PyYAML not available. Install with: pip install PyYAML"
            )
        return yaml.safe_load(data_raw)
    else:
        import json
        return json.loads(data_raw)


def get_lens_preset(preset_name: str) -> Dict[str, Any]:
    """
    Get a specific lens preset by name.

    Args:
        preset_name: Name of lens preset (e.g., "85mm_portrait")

    Returns:
        Lens preset configuration
    """
    preset_path = Path("configs/cinematic/cameras/lens_presets.yaml")
    data = load_preset(preset_path)

    if preset_name not in data.get("lenses", {}):
        raise ValueError(f"Unknown lens preset: {preset_name}")

    return data["lenses"][preset_name]
```

### 4. Camera Rig Setup

```python
def setup_camera_rig(
    camera: bpy.types.Object,
    rig_type: str,
    plumb_bob: bpy.types.Object,
    config: Dict[str, Any] = None
) -> bpy.types.Object:
    """
    Set up camera rig with appropriate constraints.

    Args:
        camera: Camera object to rig
        rig_type: Type of rig (tripod, dolly, crane, steadicam, drone)
        plumb_bob: Target object for camera to track
        config: Optional rig configuration

    Returns:
        Camera object with constraints applied
    """
    try:
        import bpy
    except ImportError:
        raise RuntimeError("This function requires Blender")

    config = config or {}

    # Clear existing constraints
    for constraint in camera.constraints:
        camera.constraints.remove(constraint)

    if rig_type == "tripod":
        # Track to plumb bob
        track = camera.constraints.new(type='TRACK_TO')
        track.target = plumb_bob
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'

        # Lock position (tripod doesn't move)
        camera.lock_location = (True, True, True)

    elif rig_type == "dolly":
        # Track to plumb bob
        track = camera.constraints.new(type='TRACK_TO')
        track.target = plumb_bob
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'

        # Limit to track/rail (typically X or Y axis)
        # Allow movement along one axis
        locked_axes = config.get("locked_axes", (False, True, True))
        camera.lock_location = locked_axes

    elif rig_type == "crane":
        # Track to plumb bob
        track = camera.constraints.new(type='TRACK_TO')
        track.target = plumb_bob
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'

        # Create armature for crane arm
        # (simplified - real implementation would create armature)
        pass

    elif rig_type == "steadicam":
        # Smooth follow with dampening
        # Use Copy Location with offset and softness
        copy_loc = camera.constraints.new(type='COPY_LOCATION')
        copy_loc.target = plumb_bob
        copy_loc.use_offset = True
        copy_loc.influence = 0.8  # Some lag for smoothness

    elif rig_type == "drone":
        # Free movement with stabilization
        # Minimal constraints, rely on animation
        track = camera.constraints.new(type='TRACK_TO')
        track.target = plumb_bob
        track.track_axis = 'TRACK_NEGATIVE_Z'
        track.up_axis = 'UP_Y'
        track.influence = 0.5  # Softer tracking

    return camera
```

### 5. Multi-Camera Layout

```python
def create_multi_camera_layout(
    configs: list[CameraConfig],
    layout: str = "grid",
    spacing: float = 2.0
) -> list[bpy.types.Object]:
    """
    Create multiple cameras in a layout pattern.

    Args:
        configs: List of camera configurations
        layout: Layout pattern (grid, circle, arc)
        spacing: Distance between cameras

    Returns:
        List of created camera objects
    """
    try:
        import bpy
        from math import sin, cos, pi
    except ImportError:
        raise RuntimeError("This function requires Blender")

    cameras = []
    n = len(configs)

    for i, config in enumerate(configs):
        # Calculate position based on layout
        if layout == "grid":
            cols = int(n ** 0.5) + 1
            row = i // cols
            col = i % cols
            x = col * spacing
            y = row * spacing
            z = 0

        elif layout == "circle":
            angle = (2 * pi * i) / n
            radius = spacing * n / (2 * pi)
            x = radius * cos(angle)
            y = radius * sin(angle)
            z = 0

        elif layout == "arc":
            # 180-degree arc
            angle = pi * (i + 1) / (n + 1)
            radius = spacing * n / 2
            x = -radius * cos(angle) + radius
            y = radius * sin(angle)
            z = 0

        else:
            raise ValueError(f"Unknown layout: {layout}")

        # Update config transform
        config.transform = Transform3D(
            position=(x, y, z + 2),  # Add height for viewing angle
            rotation=(90, 0, 0),  # Looking down
            scale=(1, 1, 1)
        )

        # Create camera
        cam = create_camera_from_config(config)
        cameras.append(cam)

    return cameras
```

---

## Sources

### High Confidence (Primary Sources)

| Source | URL/Path | Notes |
|--------|----------|-------|
| Blender Camera API | docs.blender.org/api/current/bpy.types.Camera.html | Official API reference |
| Blender CameraDOFSettings | docs.blender.org/api/current/bpy.types.CameraDOFSettings.html | DoF properties reference |
| Existing types.py | lib/cinematic/types.py | Established patterns for dataclasses |
| Existing state_manager.py | lib/cinematic/state_manager.py | Safe bpy access patterns |
| Design Document | .planning/design/CINEMATIC_SYSTEM_DESIGN.md | Complete design with algorithms |

### Medium Confidence (Secondary Sources)

| Source | URL/Path | Notes |
|--------|----------|-------|
| Lens Presets | configs/cinematic/cameras/lens_presets.yaml | Existing configuration format |
| Sensor Presets | configs/cinematic/cameras/sensor_presets.yaml | Existing configuration format |
| Rig Presets | configs/cinematic/cameras/rig_presets.yaml | Rig type definitions |
| Imperfection Presets | configs/cinematic/cameras/imperfection_presets.yaml | Lens character profiles |
| Requirements | .planning/REQUIREMENTS_CINEMATIC.md | REQ-CINE-CAM, REQ-CINE-PLUMB |

### Low Confidence (Needs Verification)

| Source | Notes | Action Required |
|--------|-------|-----------------|
| Compositor node names | May vary by Blender version | Test in target Blender version |
| Rig animation paths | Not fully specified | Clarify in planning phase |
| Multi-camera composite | Layout details sketchy | Verify with requirements |

---

## Files to Create

Based on research and requirements:

### Core Implementation Files

| File | Purpose | Key Classes/Functions |
|------|---------|----------------------|
| `lib/cinematic/camera.py` | Camera creation and management | `create_camera()`, `configure_dof()`, `apply_lens_preset()` |
| `lib/cinematic/lenses.py` | Lens system and presets | `LensManager`, `apply_imperfections()` |
| `lib/cinematic/plumb_bob.py` | Plumb bob targeting | `calculate_plumb_bob()`, `create_target_empty()` |
| `lib/cinematic/rigs.py` | Camera rig system | `setup_rig()`, `create_rig_controller()` |

### Extended Types

| File | Additions |
|------|-----------|
| `lib/cinematic/types.py` | Add `PlumbBobConfig`, `RigConfig`, `ImperfectionConfig` dataclasses |

### Configuration Files (Already Exist)

- `configs/cinematic/cameras/lens_presets.yaml`
- `configs/cinematic/cameras/sensor_presets.yaml`
- `configs/cinematic/cameras/rig_presets.yaml`
- `configs/cinematic/cameras/imperfection_presets.yaml`

---

## Verification Checklist

Before planning, verify:

- [ ] Target Blender version supports all camera properties
- [ ] Compositor node names match implementation
- [ ] Rig constraint types available in target Blender
- [ ] mathutils.Vector and Matrix available (standard in Blender)
- [ ] PyYAML installed or JSON fallback tested

---

## Research Complete

This research provides sufficient information to create detailed execution plans for Phase 6.1. Key implementation areas are well-understood with established patterns in the codebase to follow.
