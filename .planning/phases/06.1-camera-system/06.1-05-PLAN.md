---
phase: 06.1-camera-system
plan: 05
type: execute
wave: 3
depends_on: ["06.1-02", "06.1-03"]
enables: ["06.2-01", "07.1-01"]
test_coverage: 80%
oracle_validators: ["compare_numbers", "compare_vectors", "file_exists"]
universal_stages:
  normalize: "Load RigConfig/MultiCameraLayout and validate parameters"
  primary: "Create rig constraints (TRACK_TO, LOCK_LOCATION, etc.)"
  secondary: "Apply constraints based on rig type (tripod, dolly, crane, etc.)"
  detail: "Setup multi-camera composite via compositor nodes"
  output: "Return configured camera rig or camera names"
files_modified:
  - lib/cinematic/rigs.py
  - lib/cinematic/__init__.py
autonomous: true

must_haves:
  truths:
    - "Tripod rig locks position and allows only pan/tilt tracking"
    - "Dolly rig allows movement along one axis while tracking target"
    - "Crane rig allows 3D arc movement"
    - "Steadicam applies smoothing to camera movement"
    - "Rig constraints can be cleared and reconfigured"
    - "Multi-camera layouts create cameras at correct positions"
    - "Multi-camera composite rendering produces grid output via compositor"
  artifacts:
    - path: "lib/cinematic/rigs.py"
      provides: "Camera rig system and multi-camera composite"
      exports: ["setup_camera_rig", "create_rig_controller", "clear_rig_constraints", "get_rig_type", "apply_rig_preset", "create_multi_camera_layout", "setup_multi_camera_composite", "render_multi_camera_composite"]
      min_lines: 250
  key_links:
    - from: "lib/cinematic/rigs.py"
      to: "bpy.types.Object.constraints"
      via: "Blender constraint system"
      pattern: "constraints\\.new.*TRACK_TO|constraints\\.new.*LIMIT"
    - from: "lib/cinematic/rigs.py"
      to: "lib/cinematic/types.py"
      via: "RigConfig, MultiCameraLayout imports"
      pattern: "from.*types import.*RigConfig"
    - from: "lib/cinematic/rigs.py"
      to: "bpy.context.scene.node_tree"
      via: "Compositor for multi-camera composite"
      pattern: "scene\\.node_tree|CompositorNode"
---

<objective>
Create rigs.py module for camera rig systems and multi-camera layouts.

Purpose: Implement camera rigs (tripod, dolly, crane, steadicam, drone) using Blender constraints. Create multi-camera layouts for composite shots with compositor-based grid rendering.

Output: rigs.py module with 8+ exported functions, updated __init__.py exports.
</objective>

<execution_context>
@/Users/bretbouchard/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bretbouchard/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 6.1 Summaries
@.planning/phases/06.1-camera-system/06.1-01-SUMMARY.md
@.planning/phases/06.1-camera-system/06.1-02-SUMMARY.md
@.planning/phases/06.1-camera-system/06.1-03-SUMMARY.md

# Existing codebase
@lib/cinematic/types.py
@lib/cinematic/camera.py
@lib/cinematic/plumb_bob.py
@lib/cinematic/preset_loader.py

# Research with rig setup examples
@.planning/phases/06.1-camera-system/06.1-RESEARCH.md

# Rig presets structure
@configs/cinematic/cameras/rig_presets.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rigs.py module</name>
  <files>lib/cinematic/rigs.py</files>
  <action>
Create lib/cinematic/rigs.py with camera rig functions.

**CRITICAL:** All bpy access must be guarded.

Module structure:

```python
"""
Camera Rig System Module

Provides camera rig configurations using Blender constraints.
Supports tripod, dolly, crane, steadicam, and drone rigs.
Includes multi-camera composite rendering via compositor nodes.
"""

from __future__ import annotations
from typing import Optional, Any, List, Tuple, Dict
from pathlib import Path
import math

from .types import RigConfig, MultiCameraLayout, CameraConfig, Transform3D
from .preset_loader import get_rig_preset
from .camera import create_camera

try:
    import bpy
    from math import sin, cos, pi
    BLENDER_AVAILABLE = True
except ImportError:
    bpy = None
    BLENDER_AVAILABLE = False
```

Functions to implement (from research document):

1. `setup_camera_rig(camera_name: str, config: RigConfig, target_name: str) -> bool`
   - Get camera object by name
   - Clear existing constraints
   - Apply constraints based on rig_type:
     - "tripod": TRACK_TO + lock_location
     - "tripod_orbit": TRACK_TO only
     - "dolly": TRACK_TO + lock_location for 2 axes
     - "dolly_curved": TRACK_TO + follow path constraint (simplified)
     - "crane": TRACK_TO + LIMIT_ROTATION
     - "steadicam": TRACK_TO with influence < 1.0 for smoothness
     - "drone": TRACK_TO with low influence
   - Return True on success

2. `create_rig_controller(rig_type: str, target_position: Tuple[float, float, float]) -> Optional[Any]`
   - Create an empty object to act as rig controller
   - Name it based on rig type (e.g., "tripod_controller", "dolly_controller")
   - Position at target_position
   - Return controller object or None

3. `clear_rig_constraints(camera_name: str) -> bool`
   - Get camera object
   - Remove all constraints
   - Unlock all location/rotation
   - Return True on success

4. `get_rig_type(camera_name: str) -> Optional[str]`
   - Inspect camera constraints
   - Determine rig type from constraint configuration
   - Return rig type string or None if not rigged

5. `apply_rig_preset(camera_name: str, preset_name: str, target_name: str) -> bool`
   - Load preset using get_rig_preset()
   - Create RigConfig from preset
   - Call setup_camera_rig()
   - Return True on success

6. `create_multi_camera_layout(config: MultiCameraLayout, camera_configs: List[CameraConfig]) -> List[str]`
   - Create multiple cameras based on layout_type:
     - "grid": Arrange in NxN grid with spacing
     - "horizontal": Arrange in horizontal line
     - "vertical": Arrange in vertical stack
     - "circle": Arrange in circle around origin
     - "arc": Arrange in 180-degree arc
     - "custom": Use positions from config.positions
   - Apply spacing parameter
   - Return list of created camera names

7. `setup_multi_camera_composite(config: MultiCameraLayout, camera_names: List[str]) -> bool`
   - Setup compositor node tree for multi-camera composite output
   - For each camera, create a Render Layers node
   - Use Translate nodes to position each camera's output in the grid
   - Use Mix/AlphaOver nodes to combine into single output
   - Connect to Composite node
   - Algorithm for grid positioning:
     ```python
     # Calculate grid dimensions
     n = len(camera_names)
     if config.composite_cols > 0:
         cols = config.composite_cols
         rows = (n + cols - 1) // cols
     elif config.composite_rows > 0:
         rows = config.composite_rows
         cols = (n + rows - 1) // rows
     else:
         # Auto-calculate: try to make square-ish grid
         cols = int(math.ceil(math.sqrt(n)))
         rows = (n + cols - 1) // cols

     # For each camera i at position (col, row):
     # - Create Render Layers node with scene pointing to camera
     # - Create Translate node with offset:
     #   x_offset = col * render_width
     #   y_offset = (rows - 1 - row) * render_height  # Top-left origin
     # - Connect to Mix node chain
     ```
   - Set final output resolution to: width * cols, height * rows
   - Return True on success

8. `render_multi_camera_composite(output_path: str, config: MultiCameraLayout, camera_names: List[str]) -> bool`
   - Call setup_multi_camera_composite() to configure nodes
   - Render the scene using bpy.ops.render.render()
   - Save output to output_path
   - Return True on success

9. `clear_multi_camera_composite() -> bool`
   - Remove all multi-camera composite nodes from compositor
   - Reset output resolution to original
   - Return True on success

RIG CONSTRAINT EXAMPLES (from research):
```python
# Tripod: Track to target, lock position
track = camera.constraints.new(type='TRACK_TO')
track.target = plumb_bob
track.track_axis = 'TRACK_NEGATIVE_Z'
track.up_axis = 'UP_Y'
camera.lock_location = (True, True, True)

# Dolly: Track to target, allow one axis movement
track = camera.constraints.new(type='TRACK_TO')
track.target = plumb_bob
camera.lock_location = (False, True, True)  # X movement only

# Steadicam: Soft tracking
copy_loc = camera.constraints.new(type='COPY_LOCATION')
copy_loc.target = plumb_bob
copy_loc.use_offset = True
copy_loc.influence = 0.8  # Some lag for smoothness
```

MULTI-CAMERA COMPOSITOR EXAMPLE:
```python
# Enable compositor
scene.use_nodes = True
tree = scene.node_tree

# Clear existing nodes
for node in tree.nodes:
    tree.nodes.remove(node)

# Create composite output node
composite = tree.nodes.new('CompositorNodeComposite')

# Create render layers for each camera and position in grid
prev_mix = None
for i, cam_name in enumerate(camera_names):
    col = i % cols
    row = i // cols

    # Render layers node
    rl = tree.nodes.new('CompositorNodeRLayers')
    rl.scene = scene
    rl.scene.camera = bpy.data.objects[cam_name]

    # Translate to grid position
    translate = tree.nodes.new('CompositorNodeTranslate')
    translate.inputs[1].default_value = col * render_width   # X offset
    translate.inputs[2].default_value = (rows - 1 - row) * render_height  # Y offset

    # Connect: RL -> Translate
    tree.links.new(rl.outputs['Image'], translate.inputs[0])

    # Mix with previous or use as base
    if prev_mix is None:
        prev_mix = translate
    else:
        mix = tree.nodes.new('CompositorNodeMixRGB')
        mix.blend_type = 'ADD'
        tree.links.new(prev_mix.outputs[0], mix.inputs[1])
        tree.links.new(translate.outputs[0], mix.inputs[2])
        prev_mix = mix

# Connect final to composite
tree.links.new(prev_mix.outputs[0], composite.inputs[0])

# Set output resolution
scene.render.resolution_x = render_width * cols
scene.render.resolution_y = render_height * rows
```

COMMON PITFALLS:
- Use camera.lock_location as tuple (True, True, True)
- Set track_axis to 'TRACK_NEGATIVE_Z' for correct camera orientation
- Clear constraints before adding new ones
- For multi-camera composite, ensure each Render Layers node has correct scene.camera set
- Remember to scale output resolution by grid dimensions
</action>
  <verify>
python3 -c "
from lib.cinematic.rigs import (
    setup_camera_rig, create_rig_controller, clear_rig_constraints,
    get_rig_type, apply_rig_preset, create_multi_camera_layout,
    setup_multi_camera_composite, render_multi_camera_composite,
    clear_multi_camera_composite,
    BLENDER_AVAILABLE
)
from lib.cinematic.types import RigConfig, MultiCameraLayout, CameraConfig

print(f'BLENDER_AVAILABLE: {BLENDER_AVAILABLE}')

# Test config creation
rig_config = RigConfig(rig_type='tripod', constraints={'position_locked': True})
print(f'RigConfig: {rig_config.rig_type}')

# Test multi-camera layout config
layout = MultiCameraLayout(
    layout_type='grid',
    spacing=2.0,
    cameras=['cam1', 'cam2', 'cam3', 'cam4'],
    composite_output=True,
    composite_rows=2,
    composite_cols=2
)
print(f'MultiCameraLayout: {layout.layout_type}, {len(layout.cameras)} cameras')
print(f'Composite output: {layout.composite_output}, grid: {layout.composite_rows}x{layout.composite_cols}')

# Test functions outside Blender (should return False/None)
result = setup_camera_rig('camera', rig_config, 'target')
print(f'setup_camera_rig: {result} (expected False outside Blender)')

ctrl = create_rig_controller('tripod', (0, 0, 0))
print(f'create_rig_controller: {ctrl} (expected None outside Blender)')

rig_type = get_rig_type('camera')
print(f'get_rig_type: {rig_type} (expected None outside Blender)')

composite_result = setup_multi_camera_composite(layout, ['cam1', 'cam2'])
print(f'setup_multi_camera_composite: {composite_result} (expected False outside Blender)')

print('All rigs functions importable')
"
</verify>
  <done>Rigs module with 9 functions created, all rig types implemented with Blender constraints, multi-camera composite rendering via compositor nodes</done>
</task>

<task type="auto">
  <name>Task 2: Update __init__.py with rigs exports</name>
  <files>lib/cinematic/__init__.py</files>
  <action>
Update lib/cinematic/__init__.py to export rigs module functions:

1. Add imports from .rigs:
   - setup_camera_rig
   - create_rig_controller
   - clear_rig_constraints
   - get_rig_type
   - apply_rig_preset
   - create_multi_camera_layout
   - setup_multi_camera_composite
   - render_multi_camera_composite
   - clear_multi_camera_composite

2. Add to __all__ list

3. Update module docstring to mention rigs module

4. Bump __version__ to "0.1.1" (camera system complete - minor version per checker suggestion)
</action>
  <verify>
python3 -c "
from lib.cinematic import (
    setup_camera_rig, create_rig_controller, clear_rig_constraints,
    get_rig_type, apply_rig_preset, create_multi_camera_layout,
    setup_multi_camera_composite, render_multi_camera_composite,
    clear_multi_camera_composite
)
from lib.cinematic import __version__
print(f'Version: {__version__}')
print('All rigs functions exported from lib.cinematic')
"
</verify>
  <done>All rigs functions including multi-camera composite functions exported, version bumped to 0.1.1</done>
</task>

</tasks>

<verification>
1. rigs.py module exists with 9 exported functions
2. All rig types (tripod, dolly, crane, steadicam, drone) implemented
3. Multi-camera layouts work (grid, horizontal, vertical, circle, arc, custom)
4. Multi-camera composite rendering via compositor nodes implemented
5. setup_multi_camera_composite() creates proper node tree with Translate nodes
6. render_multi_camera_composite() renders and saves output
7. Blender constraint system used correctly
8. All bpy access guarded
9. All functions exported from lib.cinematic
10. Version bumped to 0.1.1
</verification>

<success_criteria>
- Rigs module functional with guarded bpy access
- All 9 functions implemented and exported
- All rig types working with correct constraints
- Multi-camera layouts functional
- Multi-camera composite rendering produces grid output via compositor
- Works outside Blender for testing
- Version updated to 0.1.1
</success_criteria>

<output>
After completion, create `.planning/phases/06.1-camera-system/06.1-05-SUMMARY.md`
</output>
