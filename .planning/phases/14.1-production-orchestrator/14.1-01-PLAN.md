# Phase 14.1: Production Orchestrator

**Phase**: 14.1
**Priority**: P0
**Dependencies**: All previous phases
**Est. Duration**: 5-6 days

---

## Goal

Implement the master orchestrator that enables one-command production execution - the final piece that ties all departments together.

---

## Requirements

- REQ-ORCH-01: Load complete production from YAML
- REQ-ORCH-02: Validate production before execution
- REQ-ORCH-03: Execute all phases in order
- REQ-ORCH-04: Progress tracking and resume
- REQ-ORCH-05: Parallel execution where possible
- REQ-ORCH-06: Error handling and rollback

---

## Plans

### Plan 14.1-01: Production Types

**Deliverable**: `lib/production/production_types.py`

```python
@dataclass
class ProductionMeta:
    """Production metadata."""
    title: str
    version: str
    created: datetime
    modified: datetime
    author: str
    description: str = ""

@dataclass
class ProductionConfig:
    """Complete production configuration."""
    meta: ProductionMeta

    # Source material
    script_path: str = ""
    style_preset: str = "cinematic"

    # Characters
    characters: Dict[str, CharacterConfig] = field(default_factory=dict)

    # Locations
    locations: Dict[str, LocationConfig] = field(default_factory=dict)

    # Shots
    shots: List[ShotConfig] = field(default_factory=list)
    shot_list_path: str = ""  # Or load from file

    # Render settings
    render_settings: RenderSettings = field(default_factory=RenderSettings)

    # Output
    output_formats: List[OutputFormat] = field(default_factory=list)

    # Retro settings (optional)
    retro: Optional[RetroConfig] = None

    def validate(self) -> ValidationResult:
        """Validate production configuration."""
        pass

@dataclass
class OutputFormat:
    """Output format specification."""
    name: str
    format: str  # cinema_4k, streaming_1080p, 16bit_game, etc.
    codec: str = "prores_4444"
    resolution: Tuple[int, int] = (4096, 2160)
    frame_rate: int = 24
    retro_config: Optional[RetroConfig] = None

@dataclass
class ProductionResult:
    """Result of production execution."""
    success: bool
    shots_completed: int
    shots_failed: int
    total_time: float
    output_paths: List[str]
    errors: List[str]
    warnings: List[str]

@dataclass
class ExecutionState:
    """Current execution state for resume."""
    production_id: str
    started_at: datetime
    current_phase: str
    current_shot: int
    completed_shots: List[int]
    failed_shots: List[int]
    checkpoint_path: str
```

**Tasks**:
1. Create all dataclasses
2. Implement validation
3. Implement serialization
4. Add helper methods

---

### Plan 14.1-02: Production Loader

**Deliverable**: `lib/production/production_loader.py`

```python
def load_production(yaml_path: str) -> ProductionConfig:
    """Load production from YAML file."""
    pass

def load_production_from_dir(dir_path: str) -> ProductionConfig:
    """Load production from directory (multiple YAMLs)."""
    pass

def resolve_production(config: ProductionConfig) -> ProductionConfig:
    """Resolve all references and presets in production."""
    pass

def expand_shots(config: ProductionConfig) -> ProductionConfig:
    """Expand shot list from script or templates."""
    pass

# YAML structure
"""
production:
  title: "My Film"
  version: "1.0"

  script: "scripts/my_film.fountain"

  style:
    preset: "cinematic_teal_orange"
    era: "present"
    mood: "dramatic"

  characters:
    - name: "Hero"
      model: "assets/characters/hero.blend"
      wardrobe:
        scenes_1_10: "hero_casual"
        scenes_11_20: "hero_formal"

  locations:
    - name: "Warehouse"
      preset: "industrial"
      hdri: "abandoned_warehouse_4k"

  shots:
    - template: "hero_cu"
      scene: 1
      character: "Hero"
    - template: "establishing_wide"
      scene: 1
      location: "Warehouse"

  outputs:
    - format: "cinema_4k"
      path: "output/cinema/"
    - format: "16bit_game"
      retro:
        palette: "snes"
        dither: "error_diffusion"
      path: "output/snes/"
"""
```

**Tasks**:
1. Implement YAML loader
2. Implement directory loader
3. Implement reference resolution
4. Implement shot expansion
5. Test with sample productions

---

### Plan 14.1-03: Production Validator

**Deliverable**: `lib/production/production_validator.py`

```python
@dataclass
class ValidationIssue:
    """Validation problem."""
    path: str  # JSON path to issue
    severity: str  # error, warning, info
    message: str
    suggestion: str = ""

@dataclass
class ValidationResult:
    """Complete validation result."""
    valid: bool
    issues: List[ValidationIssue]
    errors: List[ValidationIssue]
    warnings: List[ValidationIssue]

def validate_production(config: ProductionConfig) -> ValidationResult:
    """Complete production validation."""
    pass

def validate_characters(config: ProductionConfig) -> List[ValidationIssue]:
    """Validate character configurations."""
    pass

def validate_locations(config: ProductionConfig) -> List[ValidationIssue]:
    """Validate location configurations."""
    pass

def validate_shots(config: ProductionConfig) -> List[ValidationIssue]:
    """Validate shot configurations."""
    pass

def validate_dependencies(config: ProductionConfig) -> List[ValidationIssue]:
    """Validate all file references exist."""
    pass

def validate_timeline(config: ProductionConfig) -> List[ValidationIssue]:
    """Validate timeline consistency."""
    pass
```

**Tasks**:
1. Implement main validator
2. Implement character validation
3. Implement location validation
4. Implement shot validation
5. Implement dependency checking
6. Implement timeline validation
7. Generate helpful error messages

---

### Plan 14.1-04: Execution Engine

**Deliverable**: `lib/production/execution_engine.py`

```python
class ExecutionEngine:
    """Main production execution engine."""

    def __init__(self, config: ProductionConfig):
        self.config = config
        self.state = ExecutionState(...)
        self.checkpoint_interval = 10  # shots

    def execute(self) -> ProductionResult:
        """Execute entire production."""
        pass

    def execute_phase(self, phase: str) -> bool:
        """Execute single phase."""
        pass

    def execute_shot(self, shot_index: int) -> bool:
        """Execute single shot."""
        pass

    def save_checkpoint(self) -> None:
        """Save execution state."""
        pass

    def load_checkpoint(self, path: str) -> None:
        """Load execution state for resume."""
        pass

    def estimate_remaining_time(self) -> float:
        """Estimate time remaining."""
        pass

    def get_progress(self) -> Dict:
        """Get current progress info."""
        pass

# Execution phases
EXECUTION_PHASES = [
    "validate",      # Validate configuration
    "prepare",       # Prepare assets and scenes
    "characters",    # Set up characters and costumes
    "locations",     # Set up locations
    "shots",         # Render all shots
    "post_process",  # Apply post-processing
    "export",        # Export all formats
    "finalize",      # Generate manifests, reports
]

def execute_production(config: ProductionConfig) -> ProductionResult:
    """One-command production execution."""
    engine = ExecutionEngine(config)
    return engine.execute()
```

**Tasks**:
1. Implement ExecutionEngine class
2. Implement phase execution
3. Implement shot execution
4. Implement checkpointing
5. Implement progress tracking
6. Implement time estimation
7. Test end-to-end

---

### Plan 14.1-05: Parallel Execution

**Deliverable**: `lib/production/parallel_executor.py`

```python
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor

@dataclass
class ParallelConfig:
    """Parallel execution configuration."""
    max_workers: int = 4
    backend: str = "thread"  # thread, process
    chunk_size: int = 1

class ParallelExecutor:
    """Execute shots in parallel."""

    def __init__(self, config: ParallelConfig):
        self.config = config

    def execute_shots_parallel(self, shots: List[ShotConfig], engine: ExecutionEngine) -> Dict[int, bool]:
        """Execute multiple shots in parallel."""
        pass

    def execute_phase_parallel(self, phase: str, items: List) -> Dict[int, bool]:
        """Execute phase items in parallel."""
        pass

def analyze_dependencies(shots: List[ShotConfig]) -> List[Set[int]]:
    """Analyze shot dependencies for parallel execution."""
    # Group shots that can run in parallel
    pass

def create_execution_graph(shots: List[ShotConfig]) -> Dict:
    """Create dependency graph for execution."""
    pass
```

**Tasks**:
1. Implement parallel executor
2. Implement dependency analysis
3. Implement execution graph
4. Handle errors in parallel context
5. Test with various worker counts

---

### Plan 14.1-06: CLI Interface

**Deliverable**: `lib/production/cli.py`

```python
import click

@click.group()
def production():
    """Production management commands."""
    pass

@production.command()
@click.argument('yaml_path')
@click.option('--validate-only', is_flag=True, help='Only validate, do not execute')
@click.option('--dry-run', is_flag=True, help='Show what would be done')
@click.option('--resume', is_flag=True, help='Resume from checkpoint')
@click.option('--parallel', default=4, help='Number of parallel workers')
def run(yaml_path, validate_only, dry_run, resume, parallel):
    """Execute production from YAML."""
    pass

@production.command()
@click.argument('yaml_path')
def validate(yaml_path):
    """Validate production configuration."""
    pass

@production.command()
@click.argument('yaml_path')
def info(yaml_path):
    """Show production information."""
    pass

@production.command()
@click.argument('yaml_path')
def estimate(yaml_path):
    """Estimate execution time."""
    pass

@production.command()
def list():
    """List all productions in current directory."""
    pass

@production.command()
@click.argument('name')
def create(name):
    """Create new production from template."""
    pass

# Entry point
if __name__ == '__main__':
    production()
```

**Tasks**:
1. Implement CLI commands
2. Implement progress display
3. Implement error reporting
4. Add color output
5. Test all commands

---

## Acceptance Criteria

- [ ] Production loads from YAML
- [ ] Validation catches all errors
- [ ] Execution completes all shots
- [ ] Checkpoints enable resume
- [ ] Parallel execution works
- [ ] CLI provides full control
- [ ] Error messages are helpful

---

## Files

```
lib/production/
├── __init__.py
├── production_types.py    # Data structures
├── production_loader.py   # YAML loading
├── production_validator.py# Validation
├── execution_engine.py    # Main execution
├── parallel_executor.py   # Parallel processing
└── cli.py                 # CLI interface

configs/production/
├── templates/
│   ├── short_film.yaml
│   ├── commercial.yaml
│   └── game_assets.yaml
└── examples/
    └── example_production.yaml
```

---

## Usage

```bash
# Create new production
python -m lib.production create my_film

# Validate
python -m lib.production validate my_film/production.yaml

# View info
python -m lib.production info my_film/production.yaml

# Execute
python -m lib.production run my_film/production.yaml

# Execute with parallel workers
python -m lib.production run my_film/production.yaml --parallel 8

# Resume from checkpoint
python -m lib.production run my_film/production.yaml --resume

# Dry run
python -m lib.production run my_film/production.yaml --dry-run
```
