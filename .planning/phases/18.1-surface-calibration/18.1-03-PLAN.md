# Phase 18.1-03: 4-Point DLT Alignment & Package Exports

**Phase**: 18.1 - Surface Calibration
**Requirement**: REQ-PROJ-02
**Priority**: P0
**Est. Effort**: 1 day
**Depends on**: 18.1-02 (3-Point Alignment)

## Goal

Implement 4-point Direct Linear Transform (DLT) alignment for non-planar/multi-surface targets, and complete package exports for Phase 18.1.

## Background

From the design document:
- 3-point alignment assumes a **planar target surface**
- For multi-surface targets (reading room with cabinets, desks), use **4-point DLT alignment**
- 4-point DLT solves for full projection matrix P (3x4), then decomposes P → K, R, t

## Algorithm Reference

```python
def four_point_dlt_alignment(
    image_points: List[Vector],  # 4+ points in projector UV space
    world_points: List[Vector]   # 4+ corresponding points in world space
) -> Tuple[Matrix, Matrix, Vector]:
    """
    Compute projection matrix from 4+ correspondences using DLT.

    Returns:
        (K, R, t) - Intrinsics, rotation, translation
    """
```

## Tasks

### 1. Create DLT Alignment (`lib/cinematic/projection/physical/calibration/dlt.py`)

```python
import numpy as np
from mathutils import Matrix, Vector
from typing import List, Tuple, Optional

def build_dlt_matrix(
    image_points: List[Tuple[float, float]],
    world_points: List[Tuple[float, float, float]]
) -> np.ndarray:
    """
    Build the DLT coefficient matrix A for solving Ap = 0.

    For each correspondence (u_i, v_i) <-> (X_i, Y_i, Z_i):
    [X_i, Y_i, Z_i, 1, 0, 0, 0, 0, -u_i*X_i, -u_i*Y_i, -u_i*Z_i, -u_i]
    [0, 0, 0, 0, X_i, Y_i, Z_i, 1, -v_i*X_i, -v_i*Y_i, -v_i*Z_i, -v_i]

    Stack all correspondences and solve via SVD.
    """
    n = len(image_points)
    A = np.zeros((2 * n, 12))

    for i, ((u, v), (X, Y, Z)) in enumerate(zip(image_points, world_points)):
        A[2*i] = [X, Y, Z, 1, 0, 0, 0, 0, -u*X, -u*Y, -u*Z, -u]
        A[2*i+1] = [0, 0, 0, 0, X, Y, Z, 1, -v*X, -v*Y, -v*Z, -v]

    return A


def solve_dlt(A: np.ndarray) -> np.ndarray:
    """
    Solve DLT system via SVD.

    The solution p is the right singular vector corresponding to
    the smallest singular value.
    """
    U, S, Vh = np.linalg.svd(A)
    p = Vh[-1]  # Last row of Vh
    return p.reshape(3, 4)


def decompose_projection_matrix(P: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Decompose projection matrix P = K [R | t].

    Uses RQ decomposition to separate K (upper triangular) from [R | t].
    """
    # Extract M = K*R (first 3x3 of P)
    M = P[:, :3]

    # RQ decomposition: M = K @ R
    # (Using QR with reversed columns/rows)
    K, R = rq_decomposition(M)

    # Normalize K so K[2,2] = 1
    K = K / K[2, 2]

    # Extract t from last column of P
    t = np.linalg.inv(K) @ P[:, 3]

    return K, R, t


def rq_decomposition(M: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    RQ decomposition: M = R @ Q where R is upper triangular.

    Implemented using QR decomposition with reversed columns.
    """
    # Reverse columns
    M_rev = M[:, ::-1]

    # QR decomposition
    Q_rev, R_rev = np.linalg.qr(M_rev.T)
    Q_rev = Q_rev.T
    R_rev = R_rev.T

    # Reverse back
    R = R_rev[:, ::-1]
    Q = Q_rev[::-1, :]

    # Ensure positive diagonal
    D = np.diag(np.sign(np.diag(R)))
    R = R @ D
    Q = D @ Q

    return R, Q


def four_point_dlt_alignment(
    projector_points: List[Vector],
    world_points: List[Vector]
) -> Tuple[Matrix, Matrix, Vector, float]:
    """
    Compute projector transform from 4+ correspondences using DLT.

    Args:
        projector_points: 4+ points in projector UV space (0-1 range)
        world_points: 4+ corresponding points in world space (meters)

    Returns:
        (K, R, t, error) - Intrinsics, rotation, translation, RMS error
    """
    if len(projector_points) < 4 or len(world_points) < 4:
        raise ValueError("At least 4 points required for DLT alignment")

    # Convert to numpy arrays
    uv = [(p.x, p.y) for p in projector_points]
    xyz = [(p.x, p.y, p.z) for p in world_points]

    # Build and solve DLT
    A = build_dlt_matrix(uv, xyz)
    P = solve_dlt(A)

    # Decompose
    K, R_np, t_np = decompose_projection_matrix(P)

    # Convert to mathutils
    K_mat = Matrix(K.tolist()).to_4x4()
    R_mat = Matrix(R_np.tolist()).to_quaternion()
    t_vec = Vector(t_np)

    # Compute error
    error = compute_dlt_error(projector_points, world_points, P)

    return K_mat, R_mat, t_vec, error


def compute_dlt_error(
    projector_points: List[Vector],
    world_points: List[Vector],
    P: np.ndarray
) -> float:
    """Compute RMS reprojection error in pixels."""
    errors = []
    for proj_pt, world_pt in zip(projector_points, world_points):
        # Project world point
        X = np.array([world_pt.x, world_pt.y, world_pt.z, 1])
        projected = P @ X
        projected = projected[:2] / projected[2]  # Normalize

        # Compare to actual
        actual = np.array([proj_pt.x, proj_pt.y])
        error = np.linalg.norm(projected - actual)
        errors.append(error)

    return np.sqrt(np.mean(np.array(errors) ** 2))
```

### 2. Update Alignment Module to Support Both Types

```python
# In alignment.py, add:

def align_surface(
    calibration: SurfaceCalibration,
    projector_profile: ProjectorProfile
) -> AlignmentResult:
    """
    Unified alignment function supporting both 3-point and 4-point DLT.

    Automatically selects algorithm based on calibration type.
    """
    projector_pts = [Vector(p.projector_uv) for p in calibration.points]
    world_pts = [Vector(p.world_position) for p in calibration.points]

    if calibration.calibration_type == CalibrationType.THREE_POINT:
        if len(calibration.points) != 3:
            raise ValueError("3-point calibration requires exactly 3 points")
        return compute_alignment_transform(projector_pts, world_pts)

    elif calibration.calibration_type == CalibrationType.FOUR_POINT_DLT:
        if len(calibration.points) < 4:
            raise ValueError("4-point DLT calibration requires at least 4 points")
        K, R, t, error = four_point_dlt_alignment(projector_pts, world_pts)
        # Convert to AlignmentResult format
        # ...

    else:
        raise ValueError(f"Unknown calibration type: {calibration.calibration_type}")
```

### 3. Create Calibration Manager (`lib/cinematic/projection/physical/calibration/manager.py`)

```python
class CalibrationManager:
    """Manage calibration workflows for projection surfaces."""

    def __init__(self, projector_profile: ProjectorProfile):
        self.profile = projector_profile
        self.calibrations: Dict[str, SurfaceCalibration] = {}

    def create_calibration(
        self,
        name: str,
        calibration_type: CalibrationType,
        points: List[CalibrationPoint]
    ) -> SurfaceCalibration:
        """Create new calibration from points."""
        pass

    def align_projector(
        self,
        calibration_name: str,
        projector_object: bpy.types.Object
    ) -> AlignmentResult:
        """Align projector camera to surface using calibration."""
        calibration = self.calibrations[calibration_name]
        result = align_surface(calibration, self.profile)

        # Apply transform to projector camera
        projector_object.matrix_world = result.transform

        return result

    def validate_calibration(
        self,
        calibration: SurfaceCalibration
    ) -> Tuple[bool, List[str]]:
        """Validate calibration points are not degenerate."""
        errors = []

        # Check point count
        if calibration.calibration_type == CalibrationType.THREE_POINT:
            if len(calibration.points) != 3:
                errors.append("3-point calibration requires exactly 3 points")
        elif calibration.calibration_type == CalibrationType.FOUR_POINT_DLT:
            if len(calibration.points) < 4:
                errors.append("4-point DLT requires at least 4 points")

        # Check for collinear points (3-point)
        if calibration.calibration_type == CalibrationType.THREE_POINT:
            pts = [Vector(p.world_position) for p in calibration.points]
            if are_collinear(pts):
                errors.append("Calibration points are collinear (degenerate)")

        return len(errors) == 0, errors
```

### 4. Update Package Exports (`lib/cinematic/projection/physical/calibration/__init__.py`)

```python
"""
Surface calibration for physical projector mapping.

Provides 3-point alignment for planar surfaces and 4-point DLT
for non-planar/multi-surface targets.
"""

# Types
from .types import (
    CalibrationPoint,
    CalibrationType,
    SurfaceCalibration,
    CalibrationPattern,
    PatternType,
    AlignmentResult,
)

# Alignment algorithms
from .alignment import (
    compute_alignment_transform,
    align_surface,
    build_orthonormal_basis,
)

from .dlt import (
    four_point_dlt_alignment,
    build_dlt_matrix,
    solve_dlt,
    decompose_projection_matrix,
)

# Pattern generation
from .patterns import (
    generate_checkerboard_pattern,
    generate_color_bars_pattern,
    generate_grid_pattern,
    generate_gradient_pattern,
)

# Keystone correction
from .keystone import (
    compute_keystone_correction,
    apply_keystone_to_camera,
)

# Transform utilities
from .surface_transform import (
    SurfaceTransform,
    calculate_surface_transform,
)

# Manager
from .manager import CalibrationManager

__all__ = [
    # Types
    'CalibrationPoint',
    'CalibrationType',
    'SurfaceCalibration',
    'CalibrationPattern',
    'PatternType',
    'AlignmentResult',

    # Alignment
    'compute_alignment_transform',
    'align_surface',
    'build_orthonormal_basis',
    'four_point_dlt_alignment',

    # Patterns
    'generate_checkerboard_pattern',
    'generate_color_bars_pattern',
    'generate_grid_pattern',
    'generate_gradient_pattern',

    # Keystone
    'compute_keystone_correction',
    'apply_keystone_to_camera',

    # Transform
    'SurfaceTransform',
    'calculate_surface_transform',

    # Manager
    'CalibrationManager',
]
```

## Deliverables

```
lib/cinematic/projection/physical/calibration/
├── __init__.py           # Package exports
├── types.py              # Calibration types
├── alignment.py          # 3-point alignment
├── dlt.py                # 4-point DLT alignment
├── patterns.py           # Calibration pattern generation
├── keystone.py           # Keystone correction
├── surface_transform.py  # Surface transform calculator
└── manager.py            # Calibration workflow manager
```

## Tests

- `test_dlt.py`: DLT algorithm tests with known projection matrices
- `test_calibration_manager.py`: Manager workflow tests
- Test with 4+ points, degenerate configurations

## Acceptance Criteria

- [ ] 4-point DLT alignment produces correct projection matrix
- [ ] DLT decomposition extracts K, R, t correctly
- [ ] CalibrationManager handles both calibration types
- [ ] Package exports complete with 30+ exports
- [ ] 25+ unit tests passing for Phase 18.1
