"""
BSP Solver Unit Tests

Tests for: lib/interiors/bsp_solver.py (to be implemented in Phase 3)
Coverage target: 90%+

These tests define the contract for the BSP solver implementation.
They will initially be skipped until the module is created.
"""

import pytest
import json
from pathlib import Path
from dataclasses import dataclass
from typing import List, Tuple, Optional

# Import Oracle for deterministic validation
from lib.oracle import (
    compare_numbers,
    compare_vectors,
    compare_within_range,
    Oracle,
)

# Import fixtures
import sys
sys.path.insert(0, str(Path(__file__).parent.parent))
from fixtures.scene_generation import FIXTURES_DIR


# ============================================================
# TEST DATA TYPES (Mirror expected implementation)
# ============================================================

@dataclass
class Rect:
    """Rectangle for BSP subdivision."""
    x: float
    y: float
    width: float
    height: float

    @property
    def area(self) -> float:
        return self.width * self.height

    @property
    def center(self) -> Tuple[float, float]:
        return (self.x + self.width / 2, self.y + self.height / 2)


@dataclass
class Room:
    """Room generated by BSP."""
    id: str
    rect: Rect
    room_type: str = "generic"
    doors: List[dict] = None
    windows: List[dict] = None

    def __post_init__(self):
        if self.doors is None:
            self.doors = []
        if self.windows is None:
            self.windows = []


@dataclass
class Connection:
    """Connection between rooms."""
    room_a: str
    room_b: str
    position: Tuple[float, float]
    width: float = 0.9


@dataclass
class FloorPlan:
    """Complete floor plan from BSP solver."""
    rooms: List[Room]
    connections: List[Connection]
    dimensions: Tuple[float, float]

    def is_connected(self) -> bool:
        """Check if all rooms are connected via graph traversal."""
        if len(self.rooms) <= 1:
            return True

        # Build adjacency list
        adj = {r.id: set() for r in self.rooms}
        for c in self.connections:
            adj[c.room_a].add(c.room_b)
            adj[c.room_b].add(c.room_a)

        # BFS from first room
        visited = set()
        queue = [self.rooms[0].id]
        while queue:
            current = queue.pop(0)
            if current in visited:
                continue
            visited.add(current)
            queue.extend(adj[current] - visited)

        return len(visited) == len(self.rooms)

    def has_overlapping_rooms(self) -> bool:
        """Check for overlapping rooms (simplified check)."""
        for i, r1 in enumerate(self.rooms):
            for r2 in self.rooms[i+1:]:
                # Simple AABB overlap check
                if (r1.rect.x < r2.rect.x + r2.rect.width and
                    r1.rect.x + r1.rect.width > r2.rect.x and
                    r1.rect.y < r2.rect.y + r2.rect.height and
                    r1.rect.y + r1.rect.height > r2.rect.y):
                    return True
        return False


# ============================================================
# FIXTURES
# ============================================================

@pytest.fixture
def sample_floor_plans():
    """Load sample floor plan fixtures."""
    fixture_path = FIXTURES_DIR / "scene_generation" / "sample_floor_plans.json"
    with open(fixture_path) as f:
        return json.load(f)


@pytest.fixture
def bsp_solver():
    """Create BSP solver instance (will fail until implemented)."""
    pytest.skip("BSP solver not yet implemented - Phase 3")
    # When implemented:
    # from lib.interiors.bsp_solver import BSPSolver
    # return BSPSolver()


# ============================================================
# BSP SOLVER TESTS
# ============================================================

class TestBSPSolverCreation:
    """Tests for BSP solver instantiation."""

    def test_create_with_defaults(self, bsp_solver):
        """Solver should be creatable with default parameters."""
        # When implemented:
        # solver = BSPSolver()
        # Oracle.assert_not_none(solver)
        pass

    def test_create_with_seed(self, bsp_solver):
        """Solver with seed should produce deterministic results."""
        # When implemented:
        # solver1 = BSPSolver(seed=42)
        # solver2 = BSPSolver(seed=42)
        # plan1 = solver1.generate(10, 8, 5)
        # plan2 = solver2.generate(10, 8, 5)
        # Oracle.assert_equal(len(plan1.rooms), len(plan2.rooms))
        pass


class TestBSPSolverGeneration:
    """Tests for floor plan generation."""

    def test_generate_simple_floor_plan(self, bsp_solver, sample_floor_plans):
        """Generate a simple 5-room floor plan."""
        fixture = sample_floor_plans["floor_plans"][0]  # simple_5room

        # When implemented:
        # plan = bsp_solver.generate(
        #     width=fixture["dimensions"]["width"],
        #     height=fixture["dimensions"]["height"],
        #     room_count=fixture["room_count"],
        #     seed=fixture["seed"]
        # )

        # Oracle assertions
        # Oracle.assert_equal(len(plan.rooms), fixture["room_count"])
        # Oracle.assert_equal(len(plan.connections), fixture["expected_connections"])
        pass

    def test_generated_rooms_within_bounds(self, bsp_solver):
        """All generated rooms should be within floor plan bounds."""
        width, height = 10.0, 8.0

        # When implemented:
        # plan = bsp_solver.generate(width=width, height=height, room_count=5)
        #
        # for room in plan.rooms:
        #     compare_within_range(room.rect.x, 0, width, "Room X position")
        #     compare_within_range(room.rect.y, 0, height, "Room Y position")
        #     compare_within_range(room.rect.x + room.rect.width, 0, width, "Room right edge")
        #     compare_within_range(room.rect.y + room.rect.height, 0, height, "Room top edge")
        pass

    def test_all_rooms_connected(self, bsp_solver):
        """Generated floor plan should have all rooms connected."""
        # When implemented:
        # plan = bsp_solver.generate(width=10, height=8, room_count=5)
        # Oracle.assert_true(plan.is_connected(), "All rooms should be connected")
        pass

    def test_no_overlapping_rooms(self, bsp_solver):
        """Generated rooms should not overlap."""
        # When implemented:
        # plan = bsp_solver.generate(width=10, height=8, room_count=5)
        # Oracle.assert_false(plan.has_overlapping_rooms(), "Rooms should not overlap")
        pass

    def test_minimum_room_area(self, bsp_solver):
        """Each room should meet minimum area requirement."""
        min_area = 6.0

        # When implemented:
        # plan = bsp_solver.generate(width=10, height=8, room_count=5)
        # for room in plan.rooms:
        #     Oracle.assert_greater_than_or_equal(
        #         room.rect.area, min_area,
        #         f"Room {room.id} area"
        #     )
        pass


class TestBSPSolverDeterminism:
    """Tests for deterministic generation."""

    def test_same_seed_same_result(self, bsp_solver):
        """Same seed should produce identical floor plans."""
        # When implemented:
        # from lib.interiors.bsp_solver import BSPSolver
        # solver1 = BSPSolver(seed=42)
        # solver2 = BSPSolver(seed=42)
        #
        # plan1 = solver1.generate(10, 8, 5)
        # plan2 = solver2.generate(10, 8, 5)
        #
        # Oracle.assert_equal(len(plan1.rooms), len(plan2.rooms))
        # for r1, r2 in zip(plan1.rooms, plan2.rooms):
        #     compare_vectors(r1.rect.center, r2.rect.center, tolerance=0.001)
        pass

    def test_different_seed_different_result(self, bsp_solver):
        """Different seeds should produce different floor plans."""
        # When implemented:
        # from lib.interiors.bsp_solver import BSPSolver
        # solver1 = BSPSolver(seed=42)
        # solver2 = BSPSolver(seed=123)
        #
        # plan1 = solver1.generate(10, 8, 5)
        # plan2 = solver2.generate(10, 8, 5)
        #
        # # At least one room should be in a different position
        # centers1 = [r.rect.center for r in plan1.rooms]
        # centers2 = [r.rect.center for r in plan2.rooms]
        # Oracle.assert_not_equal(centers1, centers2)
        pass


class TestBSPSolverJSON:
    """Tests for JSON export."""

    def test_to_json_structure(self, bsp_solver):
        """Generated JSON should have correct structure."""
        # When implemented:
        # plan = bsp_solver.generate(10, 8, 5)
        # json_data = plan.to_json()
        #
        # Oracle.assert_in("version", json_data)
        # Oracle.assert_in("rooms", json_data)
        # Oracle.assert_in("connections", json_data)
        # Oracle.assert_in("dimensions", json_data)
        pass

    def test_json_rooms_have_required_fields(self, bsp_solver):
        """Each room in JSON should have required fields."""
        # When implemented:
        # plan = bsp_solver.generate(10, 8, 5)
        # json_data = plan.to_json()
        #
        # for room in json_data["rooms"]:
        #     Oracle.assert_in("id", room)
        #     Oracle.assert_in("type", room)
        #     Oracle.assert_in("polygon", room)
        pass


class TestBSPSolverEdgeCases:
    """Tests for edge cases and error handling."""

    def test_single_room(self, bsp_solver):
        """Should handle single room request."""
        # When implemented:
        # plan = bsp_solver.generate(5, 5, 1)
        # Oracle.assert_length(plan.rooms, 1)
        # Oracle.assert_length(plan.connections, 0)
        pass

    def test_too_many_rooms_for_space(self, bsp_solver):
        """Should handle impossible room counts gracefully."""
        # When implemented:
        # with pytest.raises(ValueError):
        #     bsp_solver.generate(5, 5, 20)  # Too many rooms for space
        pass

    def test_zero_dimensions(self, bsp_solver):
        """Should reject zero dimensions."""
        # When implemented:
        # with pytest.raises(ValueError):
        #     bsp_solver.generate(0, 8, 5)
        # with pytest.raises(ValueError):
        #     bsp_solver.generate(10, 0, 5)
        pass


# Run tests if executed directly
if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
