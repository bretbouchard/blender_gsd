"""
Init Command

Creates new Blender GSD projects from templates.

Usage:
    blender-gsd init my-project
    blender-gsd init my-project --template cinematic
    blender-gsd init my-project --no-git --no-beads
"""

from __future__ import annotations
import os
import sys
import shutil
from datetime import datetime
from pathlib import Path
from typing import Optional, List

from .types import ProjectConfig, ProjectTemplate, TEMPLATE_REGISTRY


class InitCommand:
    """
    Initialize a new Blender GSD project.

    Creates project structure from templates with customizable options.
    """

    def __init__(self, cli_config=None):
        """Initialize command."""
        self.cli_config = cli_config

    def create_project(self, config: ProjectConfig) -> Path:
        """
        Create a new project from configuration.

        Args:
            config: Project configuration

        Returns:
            Path to created project

        Raises:
            ValueError: If project already exists or invalid config
        """
        # Determine output path
        output_path = config.output_path or Path.cwd() / config.name
        output_path = Path(output_path).resolve()

        # Check if project already exists
        if output_path.exists():
            raise ValueError(f"Project directory already exists: {output_path}")

        # Get template info
        template_id = config.template.value
        if template_id not in TEMPLATE_REGISTRY:
            raise ValueError(f"Unknown template: {template_id}")

        # Create project structure
        self._create_directory_structure(output_path, config)
        self._create_readme(output_path, config)
        self._create_makefile(output_path, config)
        self._create_planning_structure(output_path, config)
        self._create_vscode_settings(output_path, config)
        self._create_gitignore(output_path, config)

        # Initialize git if requested
        if config.init_git:
            self._init_git(output_path, config)

        # Initialize beads if requested
        if config.init_beads:
            self._init_beads(output_path, config)

        return output_path

    def _create_directory_structure(self, path: Path, config: ProjectConfig) -> None:
        """Create basic directory structure."""
        template_id = config.template.value

        # Always create these directories
        dirs_to_create = ["tasks", "scripts", "build"]

        # Add template-specific directories
        if template_id == "control-surface":
            dirs_to_create.extend(["configs/controls", "configs/presets"])
        elif template_id == "cinematic":
            dirs_to_create.extend(["shots", "configs/cinematic"])
        elif template_id == "production":
            dirs_to_create.extend(["configs/production", "assets"])
        elif template_id == "charlotte":
            dirs_to_create.extend(["data", "maps"])

        for dir_name in dirs_to_create:
            dir_path = path / dir_name
            dir_path.mkdir(parents=True, exist_ok=True)

            # Create .gitkeep for empty directories
            gitkeep = dir_path / ".gitkeep"
            gitkeep.touch()

    def _create_readme(self, path: Path, config: ProjectConfig) -> None:
        """Create README.md."""
        template_info = TEMPLATE_REGISTRY.get(config.template.value)

        content = f"""# {config.name}

{config.description or f"A Blender GSD project using the {template_info.name if template_info else 'default'} template."}

## Getting Started

### Prerequisites

- Blender 4.0+
- Python 3.11+
- Blender GSD framework

### Setup

```bash
# If blender_gsd is a submodule
git submodule update --init --recursive

# Or install via pip (if published)
pip install blender-gsd
```

### Usage

```bash
# Run a task
make run TASK=tasks/my_artifact.yaml

# Run all tasks
make all

# Validate project
make validate
```

## Project Structure

```
{config.name}/
├── tasks/              # Task definitions (YAML)
├── scripts/            # Artifact scripts (Python)
├── build/              # Generated outputs (gitignored)
├── .planning/          # GSD planning documents
├── Makefile            # Common commands
└── README.md           # This file
```

## Features

"""
        if template_info:
            for feature in template_info.features:
                content += f"- {feature}\n"

        content += f"""
## Author

{config.author or "Your Name"}

## Created

{datetime.now().strftime("%Y-%m-%d")}
"""

        readme_path = path / "README.md"
        readme_path.write_text(content)

    def _create_makefile(self, path: Path, config: ProjectConfig) -> None:
        """Create Makefile."""
        template_id = config.template.value

        content = f"""# {config.name} Makefile
# Generated by blender-gsd init

# Configuration
BLENDER_GSD ?= ./lib/blender_gsd
BLENDER ?= blender
PYTHON ?= python3

# Directories
TASKS_DIR = tasks
SCRIPTS_DIR = scripts
BUILD_DIR = build

# Colors for output
RED = \\033[0;31m
GREEN = \\033[0;32m
YELLOW = \\033[0;33m
CYAN = \\033[0;36m
NC = \\033[0m

.PHONY: all clean run validate help init

# Default target
all: validate build

## Build all tasks
build:
\t@echo "$(CYAN)Building all tasks...$(NC)"
\t@mkdir -p $(BUILD_DIR)
\t@for task in $(TASKS_DIR)/*.yaml; do \\
\t\techo "Processing $$task"; \\
\t\t$(PYTHON) -m blender_gsd run $$task --output $(BUILD_DIR); \\
\tdone

## Run a specific task
run:
\t@echo "$(CYAN)Running task: $(TASK)$(NC)"
\t@$(PYTHON) -m blender_gsd run $(TASK)

## Validate project structure
validate:
\t@echo "$(CYAN)Validating project...$(NC)"
\t@$(PYTHON) -m blender_gsd validate .
\t@echo "$(GREEN)Validation complete$(NC)"

## Clean build artifacts
clean:
\t@echo "$(YELLOW)Cleaning build directory...$(NC)"
\t@rm -rf $(BUILD_DIR)/*
\t@echo "$(GREEN)Clean complete$(NC)"

## Initialize planning structure
init-planning:
\t@echo "$(CYAN)Creating planning structure...$(NC)"
\t@mkdir -p .planning
\t@touch .planning/PROJECT.md
\t@touch .planning/REQUIREMENTS.md
\t@touch .planning/ROADMAP.md
"""

        # Add template-specific targets
        if template_id == "control-surface":
            content += """
## Generate control surface
generate-controls:
\t@echo "$(CYAN)Generating control surface...$(NC)"
\t@$(PYTHON) scripts/generate_controls.py

## Render product shot
render-product:
\t@echo "$(CYAN)Rendering product shot...$(NC)"
\t@$(BLENDER) -b -P scripts/render_product.py
"""

        elif template_id == "cinematic":
            content += """
## Render shot
render-shot:
\t@echo "$(CYAN)Rendering shot: $(SHOT)$(NC)"
\t@$(BLENDER) -b -P scripts/render_shot.py -- $(SHOT)

## Render all shots
render-all:
\t@echo "$(CYAN)Rendering all shots...$(NC)"
\t@for shot in shots/*.yaml; do \\
\t\t$(MAKE) render-shot SHOT=$$shot; \\
\tdone
"""

        elif template_id == "production":
            content += """
## Run production
run-production:
\t@echo "$(CYAN)Running production...$(NC)"
\t@$(PYTHON) -m lib.production.cli run configs/production/production.yaml

## Validate production
validate-production:
\t@echo "$(CYAN)Validating production...$(NC)"
\t@$(PYTHON) -m lib.production.cli validate configs/production/production.yaml

## Generate 1-sheets
generate-onesheets:
\t@echo "$(CYAN)Generating 1-sheets...$(NC)"
\t@$(PYTHON) -m lib.production.onesheet generate-all
"""

        content += """
## Show help
help:
\t@echo "Usage: make [target]"
\t@echo ""
\t@echo "Targets:"
\t@sed -n 's/^## //p' $(MAKEFILE_LIST) | column -t -s ':'
"""

        makefile_path = path / "Makefile"
        makefile_path.write_text(content)

    def _create_planning_structure(self, path: Path, config: ProjectConfig) -> None:
        """Create .planning directory structure."""
        if not config.init_planning:
            return

        planning_path = path / ".planning"
        planning_path.mkdir(parents=True, exist_ok=True)

        # Create PROJECT.md
        project_md = planning_path / "PROJECT.md"
        project_md.write_text(f"""# Project: {config.name}

**Created:** {datetime.now().strftime("%Y-%m-%d")}
**Template:** {config.template.value}

## Overview

{config.description or "Project description goes here."}

## Goals

- Goal 1
- Goal 2
- Goal 3

## Scope

### In Scope
-

### Out of Scope
-

## Success Criteria

- [ ] Criterion 1
- [ ] Criterion 2

## Constraints

-

## Dependencies

-

## Timeline

| Phase | Description | Status |
|-------|-------------|--------|
| 1 | Foundation | Planned |
| 2 | Core Features | Planned |
| 3 | Polish | Planned |

## Notes

-
""")

        # Create REQUIREMENTS.md
        requirements_md = planning_path / "REQUIREMENTS.md"
        requirements_md.write_text(f"""# Requirements: {config.name}

## Requirements Index

| ID | Category | Description | Priority | Status |
|----|----------|-------------|----------|--------|
| REQ-01 | Core | Requirement description | P1 | Planned |

## REQ-01: Requirement Name

**Category:** Core
**Priority:** P1
**Status:** Planned

### Description

Detailed requirement description.

### Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2

### Dependencies

- None

### Notes

-
""")

        # Create ROADMAP.md
        roadmap_md = planning_path / "ROADMAP.md"
        roadmap_md.write_text(f"""# Roadmap: {config.name}

## Milestone: v0.1 - Foundation
**Target:** TBD

### Phase 1: Setup
- [ ] Project initialization
- [ ] Development environment
- [ ] CI/CD setup

---

## Milestone: v1.0 - Release
**Target:** TBD

### Phase 2: Core Features
- [ ] Feature A
- [ ] Feature B

### Phase 3: Polish
- [ ] Documentation
- [ ] Testing
- [ ] Release preparation
""")

        # Create STATE.md
        state_md = planning_path / "STATE.md"
        state_md.write_text(f"""# Project State

**Last Updated:** {datetime.now().strftime("%Y-%m-%d %H:%M")}

## Current Position

**Phase:** 1
**Status:** Setup

## Recent Activity

| Date | Action | Result |
|------|--------|--------|
| {datetime.now().strftime("%Y-%m-%d")} | Project initialized | Success |

## Blockers

None currently.

## Next Steps

1. Define requirements
2. Create roadmap
3. Begin Phase 1

## Notes

-
""")

    def _create_vscode_settings(self, path: Path, config: ProjectConfig) -> None:
        """Create VS Code settings."""
        vscode_path = path / ".vscode"
        vscode_path.mkdir(parents=True, exist_ok=True)

        # settings.json
        settings = {
            "python.defaultInterpreterPath": "${workspaceFolder}/.venv/bin/python",
            "python.analysis.typeCheckingMode": "basic",
            "python.analysis.autoImportCompletions": True,
            "editor.formatOnSave": True,
            "editor.codeActionsOnSave": {
                "source.organizeImports": "explicit"
            },
            "files.exclude": {
                "**/__pycache__": True,
                "**/*.pyc": True,
                "**/.pytest_cache": True,
                "**/build": True
            },
            "files.watcherExclude": {
                "**/build/**": True,
                "**/.venv/**": True
            },
            "yaml.schemas": {
                "./lib/blender_gsd/schemas/task.json": "tasks/*.yaml",
                "./lib/blender_gsd/schemas/shot.json": "shots/*.yaml"
            },
            "[python]": {
                "editor.defaultFormatter": "ms-python.black-formatter",
                "editor.tabSize": 4
            },
            "[yaml]": {
                "editor.tabSize": 2,
                "editor.insertSpaces": True
            },
            "makefile.launchConfigurations": [
                {
                    "cwd": "${workspaceFolder}",
                    "binaryPath": "/usr/bin/make"
                }
            ]
        }

        import json
        settings_path = vscode_path / "settings.json"
        settings_path.write_text(json.dumps(settings, indent=2))

        # extensions.json
        extensions = {
            "recommendations": [
                "ms-python.python",
                "ms-python.vscode-pylance",
                "ms-python.black-formatter",
                "redhat.vscode-yaml",
                "tamasfe.even-better-toml",
                "editorconfig.editorconfig"
            ]
        }

        extensions_path = vscode_path / "extensions.json"
        extensions_path.write_text(json.dumps(extensions, indent=2))

        # launch.json for debugging
        launch = {
            "version": "0.2.0",
            "configurations": [
                {
                    "name": "Python: Current File",
                    "type": "debugpy",
                    "request": "launch",
                    "program": "${file}",
                    "console": "integratedTerminal"
                },
                {
                    "name": "Python: Run Task",
                    "type": "debugpy",
                    "request": "launch",
                    "module": "blender_gsd",
                    "args": ["run", "${input:taskFile}"],
                    "console": "integratedTerminal"
                }
            ],
            "inputs": [
                {
                    "id": "taskFile",
                    "type": "promptString",
                    "description": "Task file path"
                }
            ]
        }

        launch_path = vscode_path / "launch.json"
        launch_path.write_text(json.dumps(launch, indent=2))

    def _create_gitignore(self, path: Path, config: ProjectConfig) -> None:
        """Create .gitignore."""
        content = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
.venv/
venv/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/
.nox/

# Build outputs
build/
*.blend1
*.blend2

# OS files
.DS_Store
Thumbs.db

# Beads
.beads/

# Checkpoints
.checkpoints/

# Local config
.env
*.local.yaml
"""

        gitignore_path = path / ".gitignore"
        gitignore_path.write_text(content)

    def _init_git(self, path: Path, config: ProjectConfig) -> None:
        """Initialize git repository."""
        import subprocess

        try:
            # Initialize git
            subprocess.run(
                ["git", "init"],
                cwd=path,
                check=True,
                capture_output=True
            )

            # Add all files
            subprocess.run(
                ["git", "add", "."],
                cwd=path,
                check=True,
                capture_output=True
            )

            # Initial commit
            subprocess.run(
                ["git", "commit", "-m", f"Initial commit: {config.name}"],
                cwd=path,
                check=True,
                capture_output=True
            )

        except subprocess.CalledProcessError as e:
            print(f"Warning: Git initialization failed: {e}", file=sys.stderr)

    def _init_beads(self, path: Path, config: ProjectConfig) -> None:
        """Initialize beads tracking."""
        import subprocess

        try:
            # Check if beads is installed
            result = subprocess.run(
                ["which", "bd"],
                capture_output=True
            )

            if result.returncode != 0:
                print("Warning: beads (bd) not installed. Skipping beads init.", file=sys.stderr)
                return

            # Initialize beads
            subprocess.run(
                ["bd", "init"],
                cwd=path,
                check=True,
                capture_output=True
            )

        except subprocess.CalledProcessError as e:
            print(f"Warning: Beads initialization failed: {e}", file=sys.stderr)


def create_project(
    name: str,
    template: str = "default",
    output_path: Optional[str] = None,
    description: str = "",
    author: str = "",
    init_git: bool = True,
    init_beads: bool = True,
    init_planning: bool = True,
) -> Path:
    """
    Convenience function to create a project.

    Args:
        name: Project name
        template: Template to use
        output_path: Where to create project
        description: Project description
        author: Project author
        init_git: Initialize git
        init_beads: Initialize beads
        init_planning: Create planning structure

    Returns:
        Path to created project
    """
    config = ProjectConfig(
        name=name,
        template=ProjectTemplate(template),
        output_path=Path(output_path) if output_path else None,
        description=description,
        author=author,
        init_git=init_git,
        init_beads=init_beads,
        init_planning=init_planning,
    )

    cmd = InitCommand()
    return cmd.create_project(config)
