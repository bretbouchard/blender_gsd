"""
Tracking Export Module

Implements export of tracking data to various formats:
- JSON (generic)
- After Effects (null objects)
- Nuke (.chan format)
- Blender (markers/empties)

All exporters support frame range export and format-specific options.
"""

from __future__ import annotations
from typing import Dict, Any, List, Optional
import json
import math
from pathlib import Path

from .tracking_types import TrackingData, TrackingExportResult, ExportFormat
from .tracking_solver import interpolate_position

# Check if Blender is available
try:
    import bpy
    BLENDER_AVAILABLE = True
except ImportError:
    BLENDER_AVAILABLE = False


def export_tracking_json(
    data: Dict[str, TrackingData],
    path: str,
    frame_start: int = 1,
    frame_end: int = 250
) -> TrackingExportResult:
    """
    Export tracking data as JSON.

    Creates a human-readable JSON file with all tracking data
    including positions, velocities, and accelerations.

    Args:
        data: Dictionary of marker_name -> TrackingData
        path: Output file path
        frame_start: First frame to export
        frame_end: Last frame to export

    Returns:
        ExportResult with status information
    """
    result = TrackingExportResult(
        format="json",
        output_path=path,
    )

    try:
        export_data = {
            "format": "blender_gsd_tracking",
            "version": "1.0",
            "frame_range": [frame_start, frame_end],
            "markers": {}
        }

        total_frames = 0
        for marker_name, tracking_data in data.items():
            marker_export = {
                "name": marker_name,
                "positions": {},
                "velocities": {},
                "accelerations": {}
            }

            for frame in range(frame_start, frame_end + 1):
                pos = interpolate_position(tracking_data, frame)
                if pos is not None:
                    marker_export["positions"][str(frame)] = list(pos)
                    total_frames += 1

                vel = tracking_data.get_velocity_at_frame(frame)
                if vel is not None:
                    marker_export["velocities"][str(frame)] = list(vel)

                acc = tracking_data.get_acceleration_at_frame(frame)
                if acc is not None:
                    marker_export["accelerations"][str(frame)] = list(acc)

            export_data["markers"][marker_name] = marker_export

        # Write JSON file
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w') as f:
            json.dump(export_data, f, indent=2)

        result.marker_count = len(data)
        result.frame_count = total_frames
        result.success = True

    except Exception as e:
        result.success = False
        result.error_message = str(e)

    return result


def export_tracking_ae(
    data: Dict[str, TrackingData],
    path: str,
    frame_start: int = 1,
    frame_end: int = 250,
    resolution: tuple = (1920, 1080)
) -> TrackingExportResult:
    """
    Export tracking data for After Effects.

    Creates a JSX script that generates null objects in After Effects
    matching the tracked positions.

    Args:
        data: Dictionary of marker_name -> TrackingData
        path: Output file path (.jsx)
        frame_start: First frame to export
        frame_end: Last frame to export
        resolution: Comp resolution for coordinate conversion

    Returns:
        ExportResult with status information
    """
    result = TrackingExportResult(
        format="ae",
        output_path=path,
    )

    try:
        lines = [
            "// After Effects Tracking Import Script",
            "// Generated by Blender GSD",
            "",
            "var comp = app.project.activeItem;",
            "if (comp == null || !(comp instanceof CompItem)) {",
            "    alert('Please select a composition first.');",
            "} else {",
        ]

        total_frames = 0
        for marker_name, tracking_data in data.items():
            # Create null layer for this marker
            safe_name = marker_name.replace(" ", "_").replace("-", "_")
            lines.append(f"    // Marker: {marker_name}")
            lines.append(f"    var null_{safe_name} = comp.layers.addNull();")
            lines.append(f"    null_{safe_name}.name = '{marker_name}';")

            for frame in range(frame_start, frame_end + 1):
                pos = interpolate_position(tracking_data, frame)
                if pos is None:
                    continue

                total_frames += 1

                # Convert 3D position to 2D screen space
                # After Effects uses top-left origin, Y-down
                # Blender uses bottom-left origin, Y-up
                screen_x = pos[0] * resolution[0]
                screen_y = resolution[1] - (pos[1] * resolution[1])

                # After Effects frame numbering starts at 0
                ae_frame = frame - frame_start

                lines.append(f"    null_{safe_name}.position.setValueAtTime({ae_frame} * comp.frameDuration, [{screen_x}, {screen_y}]);")

        lines.append("}")
        lines.append("")

        # Write JSX file
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w') as f:
            f.write("\n".join(lines))

        result.marker_count = len(data)
        result.frame_count = total_frames
        result.success = True

    except Exception as e:
        result.success = False
        result.error_message = str(e)

    return result


def export_tracking_nuke(
    data: Dict[str, TrackingData],
    path: str,
    frame_start: int = 1,
    frame_end: int = 250
) -> TrackingExportResult:
    """
    Export tracking data for Nuke (.chan format).

    Creates .chan files that can be imported into Nuke's CameraTracker
    or Transform nodes.

    .chan format: frame tx ty tz rx ry rz fov
    - Positions in world units (meters)
    - Rotations in degrees (XYZ Euler)
    - FOV in degrees

    Args:
        data: Dictionary of marker_name -> TrackingData
        path: Output directory path (one .chan file per marker)
        frame_start: First frame to export
        frame_end: Last frame to export

    Returns:
        ExportResult with status information
    """
    result = TrackingExportResult(
        format="nuke",
        output_path=path,
    )

    try:
        Path(path).mkdir(parents=True, exist_ok=True)
        total_frames = 0

        for marker_name, tracking_data in data.items():
            # Create .chan file for this marker
            safe_name = marker_name.replace(" ", "_").replace("/", "_")
            chan_path = Path(path) / f"{safe_name}.chan"

            lines = []
            for frame in range(frame_start, frame_end + 1):
                pos = interpolate_position(tracking_data, frame)
                if pos is None:
                    continue

                total_frames += 1

                # Calculate rotation from velocity direction
                # For static markers, use zero rotation
                vel = tracking_data.get_velocity_at_frame(frame)
                if vel is not None and (vel[0] != 0 or vel[1] != 0 or vel[2] != 0):
                    # Calculate look direction
                    speed = math.sqrt(vel[0]**2 + vel[1]**2 + vel[2]**2)
                    if speed > 0.001:
                        rx = math.degrees(math.atan2(-vel[2], speed))
                        ry = math.degrees(math.atan2(vel[0], vel[2]))
                        rz = 0.0
                    else:
                        rx, ry, rz = 0.0, 0.0, 0.0
                else:
                    rx, ry, rz = 0.0, 0.0, 0.0

                # Default FOV for tracking markers
                fov = 50.0

                # Format: frame tx ty tz rx ry rz fov
                line = f"{frame} {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f} {rx:.4f} {ry:.4f} {rz:.4f} {fov:.2f}"
                lines.append(line)

            with open(chan_path, 'w') as f:
                f.write("\n".join(lines))

        result.marker_count = len(data)
        result.frame_count = total_frames
        result.success = True

    except Exception as e:
        result.success = False
        result.error_message = str(e)

    return result


def export_tracking_blender(
    data: Dict[str, TrackingData],
    prefix: str = "track_",
    frame_start: int = 1,
    frame_end: int = 250
) -> TrackingExportResult:
    """
    Export tracking data as Blender markers/empties.

    Creates empty objects in the current Blender scene that follow
    the tracked positions. Useful for visualization and further work.

    Args:
        data: Dictionary of marker_name -> TrackingData
        prefix: Prefix for created objects
        frame_start: First frame to export
        frame_end: Last frame to export

    Returns:
        ExportResult with status information
    """
    result = TrackingExportResult(
        format="blender",
        output_path="scene",
    )

    if not BLENDER_AVAILABLE:
        result.success = False
        result.error_message = "Blender not available"
        return result

    try:
        total_frames = 0

        for marker_name, tracking_data in data.items():
            # Create empty object
            empty_name = f"{prefix}{marker_name}"
            empty = bpy.data.objects.new(empty_name, None)
            empty.empty_display_type = 'SPHERE'
            empty.empty_display_size = 0.05

            # Link to scene
            bpy.context.collection.objects.link(empty)

            # Animate position
            for frame in range(frame_start, frame_end + 1):
                pos = interpolate_position(tracking_data, frame)
                if pos is None:
                    continue

                total_frames += 1
                empty.location = pos
                empty.keyframe_insert(data_path="location", frame=frame)

        result.marker_count = len(data)
        result.frame_count = total_frames
        result.success = True

    except Exception as e:
        result.success = False
        result.error_message = str(e)

    return result


def export_tracking(
    data: Dict[str, TrackingData],
    path: str,
    format: str = "json",
    frame_start: int = 1,
    frame_end: int = 250,
    **kwargs
) -> TrackingExportResult:
    """
    Export tracking data in the specified format.

    Convenience function that dispatches to the appropriate exporter
    based on format string.

    Args:
        data: Dictionary of marker_name -> TrackingData
        path: Output path (file or directory depending on format)
        format: Export format (json, ae, nuke, blender)
        frame_start: First frame to export
        frame_end: Last frame to export
        **kwargs: Additional format-specific options

    Returns:
        ExportResult with status information
    """
    format_lower = format.lower()

    if format_lower == "json":
        return export_tracking_json(data, path, frame_start, frame_end)
    elif format_lower in ("ae", "after_effects", "aftereffects"):
        resolution = kwargs.get("resolution", (1920, 1080))
        return export_tracking_ae(data, path, frame_start, frame_end, resolution)
    elif format_lower == "nuke":
        return export_tracking_nuke(data, path, frame_start, frame_end)
    elif format_lower == "blender":
        prefix = kwargs.get("prefix", "track_")
        return export_tracking_blender(data, prefix, frame_start, frame_end)
    else:
        result = TrackingExportResult(
            format=format,
            output_path=path,
            success=False,
            error_message=f"Unknown export format: {format}"
        )
        return result
